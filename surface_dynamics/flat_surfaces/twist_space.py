# encoding=utf-8
r"""
Homology of cylinder decomposition.
"""
#*****************************************************************************
#       Copyright (C) 2023 Christopher Zhang <christophertzhang@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  https://www.gnu.org/licenses/
#*****************************************************************************

from collections import defaultdict

from sage.all import QQ, matrix, vector, span

class TwistSpace:
    r"""
    Subspace of relative homology generated by horizontal saddle connections.

    This subspace contains the core curves of cylinders. The subspace spanned by the
    latter is an isotropic subspace of absolute homology.

    EXAMPLES::

        sage: from surface_dynamics import CylinderDiagram
        sage: from surface_dynamics.flat_surfaces.twist_space import TwistSpace
        sage: cd = CylinderDiagram("(0,1)-(0,5) (2)-(4) (3,4)-(1) (5)-(2,3)")
        sage: tw = TwistSpace(cd)
        sage: tw
        TwistSpace('(0,1)-(0,5) (2)-(4) (3,4)-(1) (5)-(2,3)')
        sage: tw.homologous_cylinders()
        [[2, 3]]
        sage: tw.cylinder_dimension()
        3

    In this example, we get that the last two cylinders (3,4)-(1) and (5)-(2,3)
    are homologous.
    """
    def __init__(self, cd):
        self._cylinder_diagram = cd

        # A list of tuples. Each tuple is a cylinder (bot, top), where
        # `bot` is a tuple containing the bottom saddles of the cylinder
        # `top` is a tuple containing the top saddles of the cylinder
        cylinders = cd.cylinders()

        # `relations` is a matrix. Each row has #saddles entries.
        # Each row gives an equation Î£_i row[i]*saddle[i] = 0
        relations = []

        # Using the equations, write some saddles as linear combinations of
        # other saddles.
        # Subset of the saddles will be linearly independent elements of
        # H^1(M, Sigma).
        # We will be able to write the elements of twist space as linear
        # combinations of these elements.
        equations = {}

        # Write the core curves in terms of the above basis.
        # self._core_curves is a list of vectors
        # A vector is an instance of
        # `sage.modules.vector_rational_dense.Vector_rational_dense`
        self._core_curves = []

        # All relations come from: top of cylinder = bottom of cylinder
        for bot, top in cylinders:
            row = [0] * cd.degree() # degree() gives the number of saddles
            for s in bot:
                row[s] += 1
            for s in top:
                row[s] -= 1
            relations.append(row)
        relations = matrix(QQ, relations)

        # Derives `equations` from `relations`.
        for row in relations.rref(): # rref() is reduced row echelon form
            for i, elt in enumerate(row):
                if elt == 1:
                    eq = vector([-r for r in row])
                    eq[i] = 0
                    equations[i] = eq
                    break

        # Compute self._core_curves
        for i, (bot, _) in enumerate(cylinders):
            vec = vector(QQ, [0] * cd.degree())
            for s in bot:
                vec[s] += 1
            for n in equations:
                if vec[n] == 1:
                    vec[n] = 0
                    vec = vec + equations[n]
            vec.set_immutable()
            self._core_curves.append(vec)

    def __repr__(self):
        return f"TwistSpace('{self._cylinder_diagram}')"

    def homologous_cylinders(self):
        r"""
        Return the list of homologous cylinders.

        OUTPUT: a list of lists. Each sublist is an equivalence class of > 1
        homologous cylinders.

        EXAMPLES::

            sage: from surface_dynamics import AbelianStratum
            sage: from surface_dynamics.flat_surfaces.twist_space import TwistSpace
            sage: for cd in AbelianStratum(1,1,1,1).cylinder_diagrams(2):
            ....:     hom_cyls = TwistSpace(cd).homologous_cylinders()
            ....:     if hom_cyls:
            ....:         print(cd)
            ....:         print(hom_cyls)
            (0,7,1,2)-(3,6,4,5) (3,6,4,5)-(0,7,1,2)
            [[0, 1]]
        """
        # Build the dictionary "homology vector" -> list of cylinder diagrams
        homologous_cylinders_partition = defaultdict(list)
        for i, vec in enumerate(self._core_curves):
            homologous_cylinders_partition[vec].append(i)

        # Filter the classes with more than one cylinder
        output = []
        for homology_class in homologous_cylinders_partition.values():
            if len(homology_class) > 1:
                output.append(homology_class)
        return output

    def cylinder_dimension(self):
        r"""
        Return the dimension of the span of core curves.

        See also :meth:`~surface_dynamics.separatrix_diagram.CylinderDiagram.homological_dimension_of_cylinders`.

        EXAMPLES::

            sage: from surface_dynamics import AbelianStratum
            sage: from surface_dynamics.flat_surfaces.twist_space import TwistSpace
            sage: for cd in AbelianStratum(1,1,1,1).cylinder_diagrams():
            ....:     assert TwistSpace(cd).cylinder_dimension() == cd.homological_dimension_of_cylinders()
        """
        from sage.matrix.constructor import matrix
        return matrix(self._core_curves).rank()
