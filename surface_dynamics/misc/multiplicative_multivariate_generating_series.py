r"""
Multiplicative rational multivariate functions

This module implements the algebra generated by rational functions of the
form

.. MATH::

    \frac{P}{\prod (1 - m_i)^{d_i}}

where the `m_i` are monomials and `d_i` are positive integers.

REFERENCES:

[LHTY] De Loera, R. Hemmecke, J. Tauzer, R. Yoshida
 "Effective lattice point counting in rational convex polytopes"
 (LattE)

[Ba] Barvinok

[St] Stanley
"Enumerative Combinatorics"
Volume I
Cambridge Studies in Advanced Mathematics 49 (1997)

.. TODO::

 - make it barvinok compatible, the data-structure is
   a term is a ``struct short_rat`` while the generating
   series is a ``struct gen_fun``
"""
#*****************************************************************************
#       Copyright (C) 2019 Vincent Delecroix <20100.delecroix@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  https://www.gnu.org/licenses/
#*****************************************************************************

from __future__ import print_function, absolute_import
from six.moves import range, map, filter, zip

from .factored_denominator import FactoredDenominator, AbstractMSum, AbstractMSumRing, laurent_monomial

import numbers

from sage.misc.cachefunc import cached_method
from sage.rings.rational_field import QQ

# custom latte count
def latte_generating_series(L, M=None):
    r"""
    EXAMPLES::

        sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import latte_generating_series
        sage: ieqs = [[0, 1, 0, 0, 0, 0, 0],
        ....:         [0, 0, 1, -1, 1, 0, 0],
        ....:         [0, 0, 0, 0, 1, 0, 0],
        ....:         [0, 0, 0, 1, 0, 0, 0],
        ....:         [0, 0, 1, 0, 0, 0, 0]]
        sage: eqns = [[0, 0, 1, -1, 1, 0, -1], [0, 0, 1, -1, 1, -1, 0]]
        sage: L = Polyhedron(ieqs=ieqs, eqns=eqns)
        sage: latte_generating_series(L)   # optional - latte_int
        (1)/((1 - x2^-1*x4*x5)*(1 - x2*x3)*(1 - x1*x2)*(1 - x0)) + (1)/((1 - x3*x4*x5)*(1 - x2*x4^-1*x5^-1)*(1 - x1*x4*x5)*(1 - x0))
    """
    if M is None:
        M = MultiplicativeMultivariateGeneratingSeriesRing('x', L.ambient_dim())
    try:
        from sage.interfaces.latte import count
    except ImportError:
        from sage.version import version
        raise ValueError('your Sage version is too old ({}) to use this function'.format(version))
    ans = count(L.cdd_Hrepresentation(), cdd=True, multivariate_generating_function=True, raw_output=True)
    return parse_latte_generating_series(M, ans)

def parse_latte_generating_series(M, s):
    r"""
    INPUT:

    - ``M`` - a multivariate generating series ring

    - ``s`` - a string as given by LattE

    OUTPUT: multivariate short rational function
    """
    n = M.ngens()
    R = M.polynomial_ring()
    V = M.free_module()

    terms = s.strip().split('\n + ')
    m = M.zero()
    for term in terms:
        num, den = term.split('/')
        m_den = {}
        for term in den[2:-2].split(')*('):
            mon = V(0)
            assert term.startswith('1-')
            term = term[2:].split('*')
            for v in term:
                if '^' in v:
                    v, mult = v.split('^')
                    if mult.startswith('(') and mult.endswith(')'):
                        mult = mult[1:-1]
                    mult = int(mult)
                else:
                    mult = 1

                assert v.startswith('x[') and v.endswith(']'), (s, term, v)
                i = int(v[2:-1])
                mon[i] += mult
            mon.set_immutable()
            if mon in m_den:
                m_den[mon] += 1
            else:
                m_den[mon] = 1
        m += M.term(R(num), list(m_den.items()))

    return m



class MultiplicativeMultivariateGeneratingSeries(AbstractMSum):
    def _den_str(self, den):
        var_names = self.parent().polynomial_ring().variable_names()
        return den.str_monomials(var_names)

    def __nonzero__(self):
        return bool(self._data)

    def numerator(self):
        r"""
        Return the numerator if there is at most one summand.

        EXAMPLES::

            sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing
            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 3)
            sage: x0, x1, x2 = M.polynomial_ring().gens()

            sage: f = M.term(x0 + x1^2*x2, [([1,3,0],1),([1,0,-1],1)])
            sage: f.numerator()
            x1^2*x2 + x0
            sage: g = M.term(1 - x2, [([1,1,0],1),([1,0,-1],2)])
            sage: (f + g).numerator()
            Traceback (most recent call last):
            ...
            ValueError: not a simple fraction
            sage: (f + g).factor().numerator()
            x0^2*x1^3 - x0*x1^3 + x0^3*x1*x2^-1 - x0^2*x1 - x0*x1^2 + x1^2*x2 - x0^2*x2^-1 + x0 - x2 + 1
        """
        if len(self._data) > 1:
            raise ValueError("not a simple fraction")
        if not self._data:
            return self.parent().polynomial_ring().zero()
        else:
            return list(self._data.values())[0]

    def numerator_subs(self, *args, **kwds):
        M = self.parent()
        R = M.polynomial_ring()

        ans = M.zero()
        for den, num in self._data.items():
            ans += M.term(num.subs(*args, **kwds), den)
        return ans

    def summands(self):
        r"""
        Return the list of elementary summands

        EXAMPLES::

           sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import *
           sage: M = MultiplicativeMultivariateGeneratingSeriesRing(2, 'x')
           sage: m1 = M.term(1, [((1,-1),1), ((0,1),1)])
           sage: m2 = M.term(1, [((-1,1),1), ((1,0),1)])
           sage: f = (m1 + m2)**2
           sage: for s in f.summands(): print(s)
           (2)/((1 - x0^-1*x1)*(1 - x1)*(1 - x0*x1^-1)*(1 - x0))
           (1)/((1 - x0^-1*x1)^2*(1 - x0)^2)
           (1)/((1 - x1)^2*(1 - x0*x1^-1)^2)
        """
        M = self.parent()
        res = []
        for den in sorted(self._data):
            num = self._data[den]
            res.append(M.term(num,den))
        return res

    # TODO: this is only working term by term. It completely ignores pole cancellation between
    # the terms
    #
    # 1 / (1 - x0 x1^-1) (1 - x1) + 1 / (1 - x0^-1 x1) (1 - x0)
    #
    #     sage: M = MultiplicativeMultivariateGeneratingSeriesRing(2)
    #     sage: m1 = M.term(1, [((1,-1),1), ((0,1),1)])
    #     sage: m2 = M.term(1, [((-1,1),1), ((1,0),1)])
    #     sage: f = m1 + m2
    #
    # This is solved by applying the monomial substitution as in
    # Barvinok Woods 2003 "Short rational generating functions for lattice point problems"
    # (possible alternative in Verdoolaege)
    #
#    def monomial_substitution(self, arg, M=None):
#        r"""
#        Perform a monomial substitution
#
#        - ``arg`` - a list of monomials or vectors or a matrix
#
#        - ``M`` - an optional codomain
#
#        EXAMPLES::
#
#            sage: M = MultiplicativeMultivariateGeneratingSeriesRing(2)
#            sage: R = M.polynomial_ring()
#            sage: x0,x1 = R.gens()
#
#            sage: f = M.term(x0, [((1,0),2),((0,1),1)])
#            sage: f
#            (x0)/((1 - x1)*(1 - x0)^2)
#            sage: f.monomial_substitution(matrix(2, [1,1,1,1]))
#            (x0*x1)/((1 - x0*x1)^3)
#
#            sage: C = MultiplicativeMultivariateGeneratingSeriesRing(3, 'z')
#            sage: f.monomial_substitution(matrix(2, 3, [1,0,1,0,1,1]), C)
#            (z0*z2)/((1 - z1*z2)*(1 - z0*z2)^2)
#        """
#        M_domain = self.parent()
#        R_domain = M_domain.polynomial_ring()
#
#        if M is None:
#            M_codomain = M_domain
#            R_codomain = R_domain
#        else:
#            M_codomain = M
#            R_codomain = M.polynomial_ring()
#
#        if arg.nrows() != M_domain.ngens() or arg.ncols() != M_codomain.ngens():
#            raise ValueError('wrong number of rows or columns')
#
#        s_dict = {R_domain.gen(i): R_codomain.monomial(*row) for i,row in enumerate(arg)}
#
#        # the monomial substitution also depends on the numerator !!
#        new_data = {}
#        for den, num in self._data.items():
#            monomial_substitution(arg, num, den, M_codomain)
#            assert num.parent() is R_domain
#            num = R_codomain(num.subs(s_dict))
#            if den in new_data:
#                new_data[den] += num
#            else:
#                new_data[den] = num
#
#        return M_codomain.element_class(M_codomain, new_data)

    # TODO: this does not make any sense
    # the residue is 1 / L1(h) ... Ld(h) where the Li are linear forms. At
    # no point we are asking for a sum of them!!
    # In other words, this method should just return a function h -> 1 / prod(Li)
    def residue(self):
        r"""
        denominator: each (1 - mon)^k in denom is replaced with -> mon^k
        numerator: evaluate at (1,1,...,1)

        OUTPUT: a pair '(degree, value)`

        EXAMPLES::

            sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing

            sage: M = MultiplicativeMultivariateGeneratingSeriesRing(2, 'x')
            sage: R = M.polynomial_ring()
            sage: x0,x1 = R.gens()
            sage: f = M.term(x0, [((1,1),2)])
            sage: f.residue()
            (2, [(1, {(1, 1): 2})])
            sage: f = M.term(x0, [((1,1),2)]) + M.term(1, [((1,0),1),((0,1),1),((1,1),1)])
            sage: r = f.residue()
            sage: r # random
            (3, [(1, {(1, 0): 1, (0, 1): 1, (1, 1): 1})])
            sage: f = M.term(x0, [((1,1),2)]) + M.term(1, [((1,0),1),((1,1),1)])
            sage: r = f.residue()
            sage: r # random
            (2, [(1, {(1, 1): 2}), (1, {(1, 0): 1, (1, 1): 1})])
        """
        R = self.parent().polynomial_ring()
        one = QQ.one()
        values = {g: one for g in R.gens()}
        ans = []
        d = -1
        for den, num in self._data.items():
            if den.degree() >= d:
                if den.degree() > d:
                    ans = []
                    d = den.degree()
                num = QQ(num.subs(values))
                if num.is_zero():
                    raise NotImplementedError('zero numerator')
                ans.append((num, den))
        return d, ans

    def derivative(self, var):
        r"""
        EXAMPLES::

            sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing

            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 2)
            sage: R = M.polynomial_ring()
            sage: x0, x1 = R.gens()

            sage: f = M.term(1, [((1,0),1)])
            sage: f.derivative(0)
            (1)/((1 - x0)^2)
            sage: f.derivative(0).derivative(0)
            (2)/((1 - x0)^3)

            sage: xx0, xx1 = R.polynomial_ring().gens()
            sage: f.taylor(10).derivative(xx0) == f.derivative(0).taylor(9)
            True
            sage: f.derivative(1)
            0

            sage: f = M.term(x0 * x1, [((1,1),2)])
            sage: f.derivative(0)
            (x1)/((1 - x0*x1)^2) + (2*x0*x1^2)/((1 - x0*x1)^3)
            sage: f.derivative(0).taylor(10) - f.taylor(10).derivative(xx0)
            30*x0^5*x1^6

            sage: f = M.term(1, [((1,2),2), ((0,1),2), ((1,0),2), ((1,1),2)])
            sage: min((f.taylor(10).derivative(xx0) - f.derivative(0).taylor(10)).degrees())
            9
            sage: min((f.taylor(10).derivative(xx1) - f.derivative(1).taylor(10)).degrees())
            10

            sage: f = M.term(1, [((1,0),2), ((1,1),1)])
            sage: f.taylor(10).derivative(xx0).derivative(xx1) - f.derivative(0).derivative(1).taylor(9)
            -18*x0^9*x1 - 42*x0^8*x1^2 - ... - 72*x0^5*x1^3 - 25*x0^4*x1^4

            sage: f = M.zero() + M.term(1/1*x0^2 * x1, [((1,0),1), ((1,1),1)])
            sage: f.derivative(0)
            (2*x0*x1)/((1 - x0)*(1 - x0*x1)) + (x0^2*x1^2)/((1 - x0)*(1 - x0*x1)^2) + (x0^2*x1)/((1 - x0)^2*(1 - x0*x1))

        You can indistinctly use integers, strings or polynomial variables for ``var``::

            sage: f = M.term(1, [((1,1),1)])
            sage: f.derivative('x0')
            (x1)/((1 - x0*x1)^2)
            sage: f.derivative(0)
            (x1)/((1 - x0*x1)^2)
            sage: f.derivative(R.gen(0))
            (x1)/((1 - x0*x1)^2)

        Checking errors in the input::

            sage: f.derivative(-1)
            Traceback (most recent call last):
            ...
            ValueError: generator not defined
            sage: f.derivative('q')
            Traceback (most recent call last):
            ...
            ValueError: 'q' not valid as a variable
        """
        M = self.parent()
        R = M.polynomial_ring()

        if isinstance(var, numbers.Integral):
            j = var
        else:
            try:
                j = R.gens().index(R(var))
            except (ValueError, TypeError):
                raise ValueError('%r not valid as a variable' % var)

        var = R.gen(j)

        ans = M.zero()
        for den, num in self._data.items():
            ans += M.term(num.derivative(var), den)
            s = sum(mul * laurent_monomial(R, v) * M.term(1, mon) for mul, v, mon in den.logarithmic_minus_derivative(j))
            ans += M.term(num, den) * s
        return ans

    def derivative_up_to_lower_order_terms(self, var):
        r"""
        Each term ``u/v`` is replaced by ``-u v'/v^2``.

        This corresponds to one half of the derivative, the other half
        being ``u' / v``. This second part can be ignored when asymptotics
        question are considered.

        EXAMPLES::

            sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing

            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 2)
            sage: f = M.term(1, [((1,0),2)])
            sage: f
            (1)/((1 - x0)^2)
            sage: f.derivative_up_to_lower_order_terms(0)
            (2)/((1 - x0)^3)

            sage: f = M.term(1, [((1,0),1),((0,1),1),((1,1),1)])
        """
        M = self.parent()
        R = M.polynomial_ring()

        ans = M.zero()
        for den, num in self._data.items():
            s = M.zero()
            for m,v,d in den.logarithmic_minus_derivative(var):
                s += M.term(m * laurent_monomial(R,v), [(d,1)])
            ans += M.term(num, den) * s

        return ans

    def delta(self):
        r"""
        Take a derivative (up to lower order terms) with respect to each of the variables.
        """
        a = self
        for i in range(self.parent().ngens()):
            a = a.derivative_up_to_lower_order_terms(i)
        return a

    # what does prec means for Laurent polynomials!?
    def taylor(self, prec, R=None):
        r"""
        EXAMPLES::

            sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing

            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('t,u')
            sage: t,u = M.polynomial_ring().gens()
            sage: f = M.term(t + u^3, [((1,1), 1), ((1,2),2)])
            sage: f
            (u^3 + t)/((1 - t*u)*(1 - t*u^2)^2)
            sage: f.taylor(10)
            2*t^4*u^8 + 4*t^3*u^9 + t^4*u^7 + 3*t^3*u^8 + ... + t*u^4 + 2*t^2*u^2 + t^2*u + u^3 + t

        TODO: this is only working term by term but for example containing negative
        powers as::

            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 2)   # not tested
            sage: m1 = M.term(1, [((1,-1),1), ((0,1),1)])   # not tested
            sage: m2 = M.term(1, [((-1,1),1), ((1,0),1)])   # not tested
            sage: f = m1 + m2                               # not tested
            sage: f.taylor(10)                              # not tested

        TESTS::

            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 2)
            sage: R = M.polynomial_ring()
            sage: x0, x1 = R.gens()
            sage: type(M.term(1, [((1,0),1)]).taylor(10))
            <type 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular'>
        """
        M = self.parent()
        R = M.polynomial_ring().polynomial_ring()
        S = M.polynomial_ring().polynomial_ring()['EXTRA_VAR']
        ans = S.zero()
        for den, num in self._data.items():
            ans += (S(num) * den.to_multiplicative_polynomial(S, extra_var=True).inverse_series_trunc(prec)).truncate(prec)
        return R(ans.subs({S.gen(): R.one()}))

    def is_zero(self):
        if self.is_trivial_zero():
            return True
        raise NotImplementedError

    def is_one(self):
        if self.is_trivial_one():
            return True
        raise NotImplementedError

    def subs_numerator(self, *args, **kwds):
        r"""
        TESTS::

            sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing
            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 2)
            sage: R = M.polynomial_ring()
            sage: x0, x1 = R.gens()
            sage: f = M.term(-x0 + 2*x0*x1^3, [((1,1), 1), ((1,2),2)])
            sage: f.subs_numerator(x0=1, x1=1)
            (1)/((1 - x0*x1)*(1 - x0*x1^2)^2)
        """
        M = self.parent()
        res = M.zero()
        for den, num in self._data.items():
            res += M.term(num.subs(*args, **kwds), den)
        return res

    def factor(self):
        """
        Group all the partial fractions into a unique fraction.

        EXAMPLES::

            sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing
            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 3)

            sage: f = M.term(1, [([1,3,0],1),([1,0,-1],1)])
            sage: g = M.term(1, [([1,1,0],1),([1,0,-1],2)])
            sage: (f + g).factor()
            (-x0*x1^3 + x0^2*x1*x2^-1 - x0*x1 - x0*x2^-1 + 2)/((1 - x0*x2^-1)^2*(1 - x0*x1)*(1 - x0*x1^3))

            sage: x0, x1, x2 = M.polynomial_ring().gens()
            sage: f = M.term(x0 + x1, [([1,3,0],1),([1,0,1],1)])
            sage: g = M.term(x2 - 1, [([1,1,0],1),([1,0,1],2)])
            sage: h = f + g
            sage: t1 = h.taylor(8)
            sage: t2 = h.factor().taylor(8)
            sage: assert all(sum(e) >= 8 for e in (t1 - t2).exponents())

        Simplification::

            sage: f1 = M.term(x0, [([1,0,0],1)])
            sage: f2 = M.term(x1, [([0,1,0],1)])
            sage: f3 = M.term(x0*x1 - 1, [([1,0,0],1), ([0,1,0],1)])
            sage: (f1 + f2 + f3).factor()
            (-1)

            sage: f1 + f2 + 1 == -f3  # indirect doctest
            True
        """
        M = self.parent()

        # compute the product of denominators
        V = M.free_module()
        D = FactoredDenominator([], V)
        for den, num in self._data.items():
            D.lcm_update(den)

        L = M.polynomial_ring()
        N = L.zero()
        for den,num in self._data.items():
            N += num * (D / den).to_multiplicative_polynomial(L)

        # Look for simplifications. In the case of Laurent polynomials, we do not
        # do anything.
        # TODO: do something for Laurent polynomials
        if any(i < 0 for den in self._data for v in den._dict for i in v) or \
           any(i < 0 for num in self._data.values() for e in num.exponents() for i in e):
            return M.term(N, D)

        P = L.polynomial_ring()
        N = P(N)
        gt = False
        for mon,mult in list(D._dict.items()):
            pmon = P.one() - P.monomial(*mon)
            q,r = N.quo_rem(pmon)
            while mult and not r:
                gt = True
                mult -= 1
                N = q
                q,r = N.quo_rem(pmon)

            if mult:
                D._dict[mon] = mult
            else:
                del D._dict[mon]

        if gt:
            D._tuple = tuple(sorted(D._dict.items()))

        return M.term(N, D)

    def as_symbolic(self):
        from sage.symbolic.ring import SR
        return SR(str(self))

# TODO: this should actually be an algebra over QQ[x0, x1, ..., xn]
# TODO: we should have two versions, as an algebra over the polynomial
#       ring QQ[x0, x1, ..., xn] and as an algebra over the Laurent
#       polynomial ring QQ[x0, x0^-1, x1, x1^-1, ..., xn, xn^-1]
class MultiplicativeMultivariateGeneratingSeriesRing(AbstractMSumRing):
    r"""
    EXAMPLES::

        sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing

        sage: MultiplicativeMultivariateGeneratingSeriesRing('x', 3)
        Multiplicative multivariate generating series on x0, x1, x2

        sage: MultiplicativeMultivariateGeneratingSeriesRing(['x', 'y', 'z'])
        Multiplicative multivariate generating series on x, y, z

        sage: MultiplicativeMultivariateGeneratingSeriesRing('a,b,c')
        Multiplicative multivariate generating series on a, b, c

        sage: MultiplicativeMultivariateGeneratingSeriesRing('y', 2)
        Multiplicative multivariate generating series on y0, y1

        sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 3)
        sage: M.zero()
        0
        sage: M.one()
        (1)
        sage: m1 = M.term(1, [((1,1,0),1)])
        sage: m1
        (1)/((1 - x0*x1))
        sage: m2 = M.term(-2, [((1,0,0),1),((0,1,0),2)])
        sage: m2
        (-2)/((1 - x1)^2*(1 - x0))
    """
    Element = MultiplicativeMultivariateGeneratingSeries

    @staticmethod
    def __classcall__(cls, *args):
        if len(args) == 1 and isinstance(args[0], AbstractMSumRing):
            poly_ring = args[0]._polynomial_ring
        else:
            if len(args) == 1 and not isinstance(args[0], (tuple, str)):
                args = (tuple(args[0]),)
            from sage.rings.polynomial.laurent_polynomial_ring import LaurentPolynomialRing
            poly_ring = LaurentPolynomialRing(QQ, *args)

        return super(AbstractMSumRing, cls).__classcall__(cls, poly_ring)

    def _critical_point(self):
        r"""
        EXAMPLES::

            sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing
            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 3)
            sage: M._critical_point()
            [1, 1, 1]
        """
        return [self.base_ring().one()] * self.ngens()

    @cached_method
    def residue_ring(self):
        r"""
        Return the residue ring (the additive version of self).

        EXAMPLES::

            sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing
            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 3)
            sage: M.residue_ring()
            Additive multivariate generating series on x0, x1, x2
        """
        from .additive_multivariate_generating_series import AdditiveMultivariateGeneratingSeriesRing
        return AdditiveMultivariateGeneratingSeriesRing(self)

    def _repr_(self):
        vars_string = ', '.join(self.polynomial_ring().variable_names())
        return 'Multiplicative multivariate generating series on ' + vars_string

    def _coerce_map_from_(self, other):
        r"""
        EXAMPLES::

            sage: from surface_dynamics.misc.multiplicative_multivariate_generating_series import MultiplicativeMultivariateGeneratingSeriesRing

            sage: M = MultiplicativeMultivariateGeneratingSeriesRing('x', 2)

            sage: M.has_coerce_map_from(ZZ)
            True
            sage: M.coerce_map_from(ZZ)
            Co...ion map:
              From: Integer Ring
              To:   Multiplicative multivariate generating series on x0, x1

            sage: M.has_coerce_map_from(QQ)
            True

            sage: M.has_coerce_map_from(M.polynomial_ring())
            True
        """
        if self.polynomial_ring().has_coerce_map_from(other):
            return True

    def _den_to_polynomial(self, den):
        return den.to_multiplicative_polynomial()
