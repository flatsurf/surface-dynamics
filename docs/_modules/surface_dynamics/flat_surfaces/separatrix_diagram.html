<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 7.3.7 and Furo 2024.05.06 -->
        <title>surface_dynamics.flat_surfaces.separatrix_diagram - surface-dynamics 0.5.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=387cc868" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="https://doc.sagemath.org/html/en/reference/_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" /
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">surface-dynamics 0.5.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">surface-dynamics 0.5.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/interval_exchanges.html">Interval exchange transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/square_tiled_surfaces.html">Square-tiled surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/rank2_genus3_classification.html">Filtering Possible <span class="math notranslate nohighlight">\(\mathcal M\)</span>-Parallel Classes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../strata.html">Strata of Abelian and quadratic differentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../surface_topology.html">Surface topology and geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../origamis.html">Origamis</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../interval_exchanges/index.html">Interval exchange transformations</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Interval exchange transformations</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/constructors.html">Interval exchange constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/template.html">Permutation template</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/labelled.html">Labelled permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/reduced.html">Reduced permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/rauzy_class_cardinality.html">Rauzy class cardinality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/cover.html">Covering construction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/iet.html">Interval exchange transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/integer_iet.html">Integral interval exchanges</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/iet_family.html">Interval exchange families</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/flip_sequence.html">Flip sequences</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../database.html">Database of cylinder diagrams and quadratic permutations</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../topological_recursion/index.html">Topological recursion</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Topological recursion</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../topological_recursion/topological_recursion.html">Generic topological recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../topological_recursion/kontsevich.html">Kontsevich topological recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../topological_recursion/masur_veech.html">Masur-Veech topological recursion</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../misc/index.html">Miscellaneous</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Miscellaneous</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/constellation.html">Constellations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/group_representation.html">Finite group representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/plane_tree.html">Plane trees</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for surface_dynamics.flat_surfaces.separatrix_diagram</h1><div class="highlight"><pre>
<span></span><span class="c1"># encoding=utf-8</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Separatrix diagrams and cylinder diagrams</span>

<span class="sd">A separatrix diagram is a couple of permutation ``(bot,top)`` that have the same</span>
<span class="sd">number of cycles in their cycle decompositions. A cylinder diagram is a</span>
<span class="sd">separatrix diagram together with a bijection between the cycles of ``bot`` and</span>
<span class="sd">``top``.</span>

<span class="sd">A cylinder diagram encodes the combinatorics of cylinder decomposition of a</span>
<span class="sd">completely periodic direction in a translation surface. If we adjoin coordinates</span>
<span class="sd">to this combinatorial datum, we have a complete description of the underlying</span>
<span class="sd">surface. In the case of arithmetic curves, the coordinates can be taken to be</span>
<span class="sd">rational numbers.</span>

<span class="sd">This representation of a surface is used in various constructions:</span>

<span class="sd">- square tiled surfaces</span>

<span class="sd">- Thurston-Veech construction of pseudo-Anosov diffeomorphism</span>

<span class="sd">- description of the cusp of Teichmueller curves</span>

<span class="sd">.. TODO::</span>

<span class="sd">    - We need a more general structure to encode configurations of structure of</span>
<span class="sd">      saddle connections (which need not be completely periodic directions (see</span>
<span class="sd">      [EskMasZor03]_)</span>

<span class="sd">    - Gray code for conjugacy classes of permutation in order to optimize the</span>
<span class="sd">      generation of separatrix and cylinder diagrams.</span>

<span class="sd">    - Implement separatrix diagram as a list of ribbon graphs with a pairing</span>
<span class="sd">      of its faces. In the Abelian case, the maps are endowed with bicoloration</span>
<span class="sd">      of the faces and the pairing is a pair of faces with different colors.</span>
<span class="sd">      (alternative for quadratic case: orientable + involution)</span>

<span class="sd">    - enumerators for fat graphs of genus g with prescribed vertex degrees</span>
<span class="sd">      (possibly up to isomorphism)</span>

<span class="sd">    - enumerators for fat graphs of genus g with prescribed vertex degrees</span>
<span class="sd">      (possibly up to isomorphism)</span>

<span class="sd">EXAMPLES::</span>

<span class="sd">    sage: from surface_dynamics import *</span>

<span class="sd">Separatrix diagrams::</span>

<span class="sd">    sage: s = SeparatrixDiagram(&#39;(0,1,2)(3,4)(5,6,7)&#39;,&#39;(0,4,1,2)(3,7)(5,6)&#39;)</span>
<span class="sd">    sage: s</span>
<span class="sd">    (0,1,2)(3,4)(5,6,7)-(0,4,1,2)(3,7)(5,6)</span>
<span class="sd">    sage: s.bot_cycle_tuples()</span>
<span class="sd">    [(0, 1, 2), (3, 4), (5, 6, 7)]</span>
<span class="sd">    sage: s.top_cycle_tuples()</span>
<span class="sd">    [(0, 4, 1, 2), (3, 7), (5, 6)]</span>

<span class="sd">Cylinder diagrams::</span>

<span class="sd">    sage: c = CylinderDiagram([((0,),(4,)),((1,2),(0,1,3)),((3,4),(2,))])</span>
<span class="sd">    sage: print(c)</span>
<span class="sd">    (0)-(4) (1,2)-(0,1,3) (3,4)-(2)</span>
<span class="sd">    sage: print(c.separatrix_diagram())</span>
<span class="sd">    (0)(1,2)(3,4)-(0,1,3)(2)(4)</span>

<span class="sd">They can also be built from separatrix diagram::</span>

<span class="sd">    sage: s = SeparatrixDiagram(&#39;(0,1,2)(3,4)(5,6,7)&#39;,&#39;(0,4,1,2)(3,7)(5,6)&#39;)</span>
<span class="sd">    sage: s</span>
<span class="sd">    (0,1,2)(3,4)(5,6,7)-(0,4,1,2)(3,7)(5,6)</span>
<span class="sd">    sage: s.to_cylinder_diagram([(0,1),(1,0),(2,2)])</span>
<span class="sd">    (0,1,2)-(3,7) (3,4)-(0,4,1,2) (5,6,7)-(5,6)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#*****************************************************************************</span>
<span class="c1">#       Copyright (C) 2010-2019 Vincent Delecroix &lt;20100.delecroix@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1">#  Distributed under the terms of the GNU General Public License (GPL)</span>
<span class="c1">#  as published by the Free Software Foundation; either version 2 of</span>
<span class="c1">#  the License, or (at your option) any later version.</span>
<span class="c1">#                  https://www.gnu.org/licenses/</span>
<span class="c1">#*****************************************************************************</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">iteritems</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">total_ordering</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">numbers</span>

<span class="kn">from</span> <span class="nn">sage.structure.sage_object</span> <span class="kn">import</span> <span class="n">SageObject</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">sage.arith.misc</span> <span class="k">as</span> <span class="nn">arith</span>
<span class="kn">from</span> <span class="nn">sage.rings.integer</span> <span class="kn">import</span> <span class="n">Integer</span>

<span class="kn">from</span> <span class="nn">sage.graphs.digraph</span> <span class="kn">import</span> <span class="n">DiGraph</span>

<span class="kn">from</span> <span class="nn">surface_dynamics.misc.permutation</span> <span class="kn">import</span> <span class="p">(</span><span class="n">perm_check</span><span class="p">,</span> <span class="n">equalize_perms</span><span class="p">,</span> <span class="n">perm_init</span><span class="p">,</span>
        <span class="n">perm_cycles</span><span class="p">,</span> <span class="n">perm_cycle_type</span><span class="p">,</span> <span class="n">perm_compose_i</span><span class="p">,</span>
        <span class="n">perm_invert</span><span class="p">,</span> <span class="n">perms_canonical_labels</span><span class="p">,</span>
        <span class="n">perms_transitive_components</span><span class="p">,</span> <span class="n">canonical_perm</span><span class="p">,</span> <span class="n">canonical_perm_i</span><span class="p">,</span>
        <span class="n">argmin</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">surface_dynamics.misc.linalg</span> <span class="kn">import</span> <span class="n">cone_triangulate</span>

<span class="kn">from</span> <span class="nn">sage.misc.decorators</span> <span class="kn">import</span> <span class="n">rename_keyword</span>

<span class="c1">#</span>
<span class="c1"># Abelian and quadratic Separatrix Diagram</span>
<span class="c1">#</span>
<div class="viewcode-block" id="two_non_connected_perms_canonical_labels">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.two_non_connected_perms_canonical_labels">[docs]</a>
<span class="k">def</span> <span class="nf">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">bot</span><span class="p">,</span> <span class="n">top</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics.flat_surfaces.separatrix_diagram import two_non_connected_perms_canonical_labels</span>
<span class="sd">        sage: two_non_connected_perms_canonical_labels([3,2,1,0],[0,1,2,3])</span>
<span class="sd">        ([1, 0, 3, 2], [0, 1, 2, 3])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot</span><span class="p">)</span>

    <span class="n">cs_type_nb</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># (bot,top) -&gt; nb of them</span>
    <span class="n">c_inv</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">perms_transitive_components</span><span class="p">([</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
            <span class="n">c_inv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">cbot</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">ctop</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">cbot</span><span class="p">[</span><span class="n">c_inv</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">c_inv</span><span class="p">[</span><span class="n">bot</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">ctop</span><span class="p">[</span><span class="n">c_inv</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">c_inv</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="p">(</span><span class="n">cbot</span><span class="p">,</span><span class="n">ctop</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">perms_canonical_labels</span><span class="p">([</span><span class="n">cbot</span><span class="p">,</span><span class="n">ctop</span><span class="p">])</span>

        <span class="n">bt</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cbot</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ctop</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">bt</span> <span class="ow">in</span> <span class="n">cs_type_nb</span><span class="p">:</span>
            <span class="n">cs_type_nb</span><span class="p">[</span><span class="n">bt</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cs_type_nb</span><span class="p">[</span><span class="n">bt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">bot</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">top</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cs_type_nb</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cs_type_nb</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
            <span class="n">bot</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shift</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">top</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shift</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">shift</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">bot</span><span class="p">,</span><span class="n">top</span></div>



<span class="c1"># main class</span>
<div class="viewcode-block" id="SeparatrixDiagram">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram">[docs]</a>
<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">SeparatrixDiagram</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Separatrix diagram of oriented foliation.</span>

<span class="sd">    A separatrix diagram is a 2-tuple of permutations ``(bot,top)`` such that</span>
<span class="sd">    ``bot`` and ``top`` share the same number of cycles.</span>

<span class="sd">    bot (resp. top) has to be thought a bottom (resp. top) of a potential face</span>
<span class="sd">    as in the following::</span>

<span class="sd">            -- bot --&gt;</span>
<span class="sd">        -------------------</span>
<span class="sd">           &lt;-- top --</span>

<span class="sd">    The order for bot and top is chosen in such a way that it corresponds to</span>
<span class="sd">    the orientation of a face.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">        sage: s = SeparatrixDiagram(&#39;(0,2)(1,3,4)&#39;,&#39;(0,4)(2,1,3)&#39;)</span>
<span class="sd">        sage: print(s)</span>
<span class="sd">        (0,2)(1,3,4)-(0,4)(1,3,2)</span>
<span class="sd">        sage: print(s.stratum())</span>
<span class="sd">        H_3(4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1)(2,3,4)&#39;,&#39;(0,2,4)(1,3)&#39;)</span>
<span class="sd">            sage: s == loads(dumps(s))</span>
<span class="sd">            True</span>
<span class="sd">            sage: SeparatrixDiagram(s)</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            sage: s == SeparatrixDiagram(s)</span>
<span class="sd">            True</span>
<span class="sd">            sage: SeparatrixDiagram(str(s))</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            sage: s == SeparatrixDiagram(str(s))</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">top</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">SeparatrixDiagram</span><span class="p">):</span>
                    <span class="n">bot</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">bot</span><span class="p">()</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">bot</span><span class="p">,</span><span class="n">top</span> <span class="o">=</span> <span class="n">data</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                    <span class="n">bot</span><span class="p">,</span><span class="n">top</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the argument data is not valid&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bot</span> <span class="o">=</span> <span class="n">data</span>

            <span class="n">bot</span> <span class="o">=</span> <span class="n">perm_init</span><span class="p">(</span><span class="n">bot</span><span class="p">)</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">perm_init</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
            <span class="n">equalize_perms</span><span class="p">([</span><span class="n">bot</span><span class="p">,</span> <span class="n">top</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bot</span> <span class="o">=</span> <span class="n">data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bot</span> <span class="o">=</span> <span class="n">bot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_top</span> <span class="o">=</span> <span class="n">top</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot</span><span class="p">)</span>

        <span class="n">bot_seen</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">top_seen</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">bot_to_cycle</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">top_to_cycle</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">bot_cycles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">top_cycles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bot_seen</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">c</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bot_cycles</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">bot_seen</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">bot_to_cycle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="n">bot_seen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">bot_cycles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">top_seen</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">c</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_cycles</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">top_seen</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">top_to_cycle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="n">top_seen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">top_cycles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span> <span class="o">=</span> <span class="n">bot_cycles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span> <span class="o">=</span> <span class="n">top_cycles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cycle</span> <span class="o">=</span> <span class="n">bot_to_cycle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cycle</span> <span class="o">=</span> <span class="n">top_to_cycle</span>

        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the data of self is valid, i.e.</span>

<span class="sd">          * self._bot, self._top are valid permutations</span>
<span class="sd">          * the number of cycles of bot and top are the same</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = SeparatrixDiagram(&#39;(0,1)(2,3)&#39;,&#39;(0,2,3,1)&#39;) #indirect doctest</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: bot has 2 cylinders whereas top has 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">perm_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">)</span>
        <span class="n">perm_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">)</span>

        <span class="n">p_bot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_cycle_tuples</span><span class="p">()</span>
        <span class="n">p_top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_cycle_tuples</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_top</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_bot</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bot has </span><span class="si">%d</span><span class="s2"> cylinders whereas top has </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_bot</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">p_top</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_sage_input_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sib</span><span class="p">,</span> <span class="n">coerced</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sage input support.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,3,2)(1,4)&#39;,&#39;(0,1)(2,3,4)&#39;)</span>
<span class="sd">            sage: sage_input(s)</span>
<span class="sd">            SeparatrixDiagram(&#39;(0,3,2)(1,4)-(0,1)(2,3,4)&#39;)</span>

<span class="sd">        We can check that evaluating the code actually gives back the same</span>
<span class="sd">        object::</span>

<span class="sd">            sage: t = eval(str(sage_input(s)))</span>
<span class="sd">            sage: t == s</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sib</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s1">&#39;SeparatrixDiagram&#39;</span><span class="p">)(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="SeparatrixDiagram.to_directed_graph">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.to_directed_graph">[docs]</a>
    <span class="k">def</span> <span class="nf">to_directed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a graph that encodes this separatrix diagram.</span>

<span class="sd">        The vertices correspond to separatrix and the edges are of two types</span>

<span class="sd">        - &#39;b&#39; neighbor corresponds to the right neighbors on the bottom</span>
<span class="sd">          permutation</span>

<span class="sd">        - &#39;t&#39; edges correspond to the neighbor of the top permutation</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: S = SeparatrixDiagram(&#39;(0,1)(2,3,4)&#39;,&#39;(0,3,2)(1,4)&#39;)</span>
<span class="sd">            sage: G = S.to_directed_graph(); G</span>
<span class="sd">            Looped multi-digraph on 5 vertices</span>
<span class="sd">            sage: G.vertices(sort=True)</span>
<span class="sd">            [0, 1, 2, 3, 4]</span>
<span class="sd">            sage: G.edges(sort=True)</span>
<span class="sd">            [(0, 1, &#39;b&#39;), (0, 3, &#39;t&#39;), (1, 0, &#39;b&#39;), (1, 4, &#39;t&#39;), (2, 0, &#39;t&#39;), (2, 3, &#39;b&#39;), (3, 2, &#39;t&#39;), (3, 4, &#39;b&#39;), (4, 1, &#39;t&#39;), (4, 2, &#39;b&#39;)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()))</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">G</span></div>


    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of self</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: d = SeparatrixDiagram(&#39;(0,1)(2)&#39;,&#39;(0)(1,2)&#39;)</span>
<span class="sd">            sage: repr(d) #indirect doctest</span>
<span class="sd">            &#39;(0,1)(2)-(0)(1,2)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_cycle_string</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_cycle_string</span><span class="p">()</span>

    <span class="c1">#TODO</span>
    <span class="k">def</span> <span class="nf">_latex_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Latex representation</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: print(&quot;to be done&quot;)</span>
<span class="sd">            to be done</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_out</span><span class="p">()</span><span class="o">.</span><span class="n">cycle_type</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mf">360.</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span><span class="n">i</span><span class="p">,(</span><span class="n">v</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">v</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">))]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">begin</span><span class="si">{tikzpicture}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">vout</span><span class="p">,</span><span class="n">vin</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;    </span><span class="se">\\</span><span class="s2">draw [-triangle 45] (0,0) -- (</span><span class="si">%f</span><span class="s2">:0.8cm);</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">vout</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;    </span><span class="se">\\</span><span class="s2">draw (</span><span class="si">%f</span><span class="s2">:0.8cm) -- (</span><span class="si">%f</span><span class="s2">:1cm);</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">vout</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="n">vout</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;    </span><span class="se">\\</span><span class="s2">draw (</span><span class="si">%f</span><span class="s2">:1cm) </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">vout</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">vout</span><span class="o">+</span><span class="n">vin</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
                <span class="k">if</span> <span class="n">vout</span><span class="o">+</span><span class="n">vin</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">:</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">-</span> <span class="n">n</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">n</span>
                <span class="n">d1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">vout</span><span class="o">-</span><span class="n">v1</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vout</span><span class="o">-</span><span class="n">v1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vout</span><span class="o">-</span><span class="n">v1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)])</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">vout</span><span class="o">-</span><span class="n">v2</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vout</span><span class="o">-</span><span class="n">v2</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vout</span><span class="o">-</span><span class="n">v2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)])</span>
                <span class="k">if</span> <span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">:</span>
                    <span class="n">vint</span> <span class="o">=</span> <span class="n">v1</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">d1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vint</span> <span class="o">=</span> <span class="n">v2</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">d2</span>

                <span class="n">dint</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%f</span><span class="s1">cm&#39;</span> <span class="o">%</span><span class="p">(</span><span class="mf">1.5</span><span class="o">+</span><span class="n">d</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
                <span class="n">ct1</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%f</span><span class="s1">cm&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">cyclic_direction</span><span class="p">(</span><span class="n">vout</span><span class="p">,</span><span class="n">vint</span><span class="p">,</span><span class="n">vin</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ct2</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%f</span><span class="s1">cm&#39;</span> <span class="o">%</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
                    <span class="n">ct3</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%f</span><span class="s1">cm&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ct2</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%f</span><span class="s1">cm&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
                    <span class="n">ct3</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%f</span><span class="s1">cm&#39;</span> <span class="o">%</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;    ..controls +(</span><span class="si">%f</span><span class="s2">:</span><span class="si">%s</span><span class="s2">) and +(</span><span class="si">%f</span><span class="s2">:</span><span class="si">%s</span><span class="s2">) ..</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">vout</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="n">ct1</span><span class="p">,(</span><span class="n">vint</span><span class="o">+</span><span class="n">n</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="n">ct2</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;    (</span><span class="si">%f</span><span class="s2">:</span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">vint</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="n">dint</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;    ..controls +(</span><span class="si">%f</span><span class="s2">:</span><span class="si">%s</span><span class="s2">) and +(</span><span class="si">%f</span><span class="s2">:</span><span class="si">%s</span><span class="s2">) ..</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">((</span><span class="n">vint</span><span class="o">+</span><span class="n">n</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="n">ct3</span><span class="p">,</span><span class="n">vin</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="n">ct1</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;    (</span><span class="si">%f</span><span class="s2">:1cm);</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">vin</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;    </span><span class="se">\\</span><span class="s2">draw [-open triangle 45] (</span><span class="si">%f</span><span class="s2">:1cm) -- (</span><span class="si">%f</span><span class="s2">:0.6cm);</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">vin</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="n">vin</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;    </span><span class="se">\\</span><span class="s2">draw (</span><span class="si">%f</span><span class="s2">:0.6cm) -- (0,0);</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">vin</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">end</span><span class="si">{tikzpicture}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Comparisons and canonic labels</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equality test</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: d1 = SeparatrixDiagram(&#39;(0)&#39;,&#39;(0)&#39;)</span>
<span class="sd">            sage: d2 = SeparatrixDiagram(&#39;(0,1)(2)&#39;,&#39;(0,1)(2)&#39;)</span>
<span class="sd">            sage: d3 = SeparatrixDiagram(&#39;(0,1)(2)&#39;,&#39;(0,2)(1)&#39;)</span>
<span class="sd">            sage: d1 == d1 and d2 == d2 and d3 == d3</span>
<span class="sd">            True</span>
<span class="sd">            sage: d1 == d2 or d1 == d3 or d2 == d3 or d3 == d2</span>
<span class="sd">            False</span>

<span class="sd">            sage: d1 = SeparatrixDiagram(&#39;(0)&#39;,&#39;(0)&#39;)</span>
<span class="sd">            sage: d2 = SeparatrixDiagram(&#39;(0,1)(2)&#39;,&#39;(0,1)(2)&#39;)</span>
<span class="sd">            sage: d3 = SeparatrixDiagram(&#39;(0,1)(2)&#39;,&#39;(0,2)(1)&#39;)</span>
<span class="sd">            sage: d1 != d1 or d2 != d2 or d3 != d3</span>
<span class="sd">            False</span>
<span class="sd">            sage: d1 != d2 and d1 != d3 and d2 != d3 and d3 != d2</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_bot</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_top</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether self is lesser or equal than other</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = [&#39;(0,1,2)-(0,1,2)&#39;,</span>
<span class="sd">            ....:      &#39;(0,2,1)-(0,1,2)&#39;,</span>
<span class="sd">            ....:      &#39;(0,2,1)-(0,2,1)&#39;,</span>
<span class="sd">            ....:      &#39;(0)(1,2)-(0)(1,2)&#39;,</span>
<span class="sd">            ....:      &#39;(0)(1,2)-(0,1)(2)&#39;,</span>
<span class="sd">            ....:      &#39;(0)(1,2)-(0,2)(1)&#39;,</span>
<span class="sd">            ....:      &#39;(0,1)(2)-(0)(1,2)&#39;,</span>
<span class="sd">            ....:      &#39;(0,1)(2)-(0,1)(2)&#39;,</span>
<span class="sd">            ....:      &#39;(0,1)(2)-(0,2)(1)&#39;,</span>
<span class="sd">            ....:      &#39;(0,2)(1)-(0)(1,2)&#39;,</span>
<span class="sd">            ....:      &#39;(0,2)(1)-(0,1)(2)&#39;,</span>
<span class="sd">            ....:      &#39;(0,2)(1)-(0,2)(1)&#39;,</span>
<span class="sd">            ....:      &#39;(0)(1)(2)-(0)(1)(2)&#39;]</span>
<span class="sd">            sage: s0 = list(map(SeparatrixDiagram, s))</span>
<span class="sd">            sage: s1 = s0[:]</span>
<span class="sd">            sage: for _ in range(10):</span>
<span class="sd">            ....:     shuffle(s1)</span>
<span class="sd">            ....:     assert sorted(s1) == s0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only separatrix diagram can be compared to separatrix diagrams&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">nseps</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">nseps</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">ncyls</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">ncyls</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_bot_cycles</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_bot_cycles</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_top_cycles</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_top_cycles</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># equal</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="SeparatrixDiagram.is_isomorphic">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.is_isomorphic">[docs]</a>
    <span class="k">def</span> <span class="nf">is_isomorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">return_map</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether this separatrix diagram is isomorphic to ``other``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: bot = [1,2,0,3]</span>
<span class="sd">            sage: top = [1,0,3,2]</span>
<span class="sd">            sage: s = SeparatrixDiagram(bot,top); s</span>
<span class="sd">            (0,1,2)(3)-(0,1)(2,3)</span>
<span class="sd">            sage: m = [3,0,1,2]</span>
<span class="sd">            sage: bot2 = [0]*4</span>
<span class="sd">            sage: top2 = [0]*4</span>
<span class="sd">            sage: for i in range(4):</span>
<span class="sd">            ....:     bot2[m[i]] = m[bot[i]]</span>
<span class="sd">            ....:     top2[m[i]] = m[top[i]]</span>
<span class="sd">            sage: ss = SeparatrixDiagram(bot2,top2)</span>
<span class="sd">            sage: s.is_isomorphic(ss)</span>
<span class="sd">            True</span>
<span class="sd">            sage: m = [1,2,0,3]</span>
<span class="sd">            sage: for i in range(4):</span>
<span class="sd">            ....:   bot2[m[i]] = m[bot[i]]</span>
<span class="sd">            ....:   top2[m[i]] = m[top[i]]</span>
<span class="sd">            sage: ss = SeparatrixDiagram(bot2,top2)</span>
<span class="sd">            sage: s.is_isomorphic(ss)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;other must be a separatrix diagram&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_normal_perms</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_normal_perms</span><span class="p">()</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.relabel">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.relabel">[docs]</a>
    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Relabel self according to the permutation ``perm``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0)(2,3,4)&#39;,&#39;(0,3,2)(1)&#39;)</span>
<span class="sd">            sage: s</span>
<span class="sd">            (0)(1)(2,3,4)-(0,3,2)(1)(4)</span>
<span class="sd">            sage: s.relabel(perm=[1,0,2,3,4])</span>
<span class="sd">            (0)(1)(2,3,4)-(0)(1,3,2)(4)</span>
<span class="sd">            sage: s.relabel(perm=[1,2,0,3,4])</span>
<span class="sd">            (0,3,4)(1)(2)-(0,1,3)(2)(4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">perm</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">),</span><span class="n">n</span><span class="p">))</span>
        <span class="n">bot</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">top</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">bot</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">top</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">SeparatrixDiagram</span><span class="p">(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bot</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_bot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_top</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_bot_cycles</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_top_cycles</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cycle</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_bot_to_cycle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cycle</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_top_to_cycle</span>

        <span class="k">return</span> <span class="n">S</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.canonical_label">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.canonical_label">[docs]</a>
    <span class="k">def</span> <span class="nf">canonical_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Relabel self according to some canonical labels.</span>

<span class="sd">        The result is cached.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``inplace`` - boolean (default: ``True``) - if True modify self if not</span>
<span class="sd">          return a new separatrix diagram.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: bot = &#39;(0,1,3,6,7,5)(2,4)(8)(9)&#39;</span>
<span class="sd">            sage: top = &#39;(0)(1,2)(3,4,5)(6,7,8,9)&#39;</span>
<span class="sd">            sage: s = SeparatrixDiagram(bot,top)</span>
<span class="sd">            sage: s.canonical_label()</span>
<span class="sd">            (0)(1)(2,3,4,5,6,7)(8,9)-(0,1,2,3)(4,7,9)(5)(6,8)</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: bot = [3,2,4,0,1]</span>
<span class="sd">            sage: top = [1,0,3,4,2]</span>
<span class="sd">            sage: b = [None]*5; t = [None]*5</span>
<span class="sd">            sage: for p in Permutations([0,1,2,3,4]):</span>
<span class="sd">            ....:     for i in range(5):</span>
<span class="sd">            ....:         b[p[i]] = p[bot[i]]</span>
<span class="sd">            ....:         t[p[i]] = p[top[i]]</span>
<span class="sd">            ....:     s = SeparatrixDiagram(b,t)</span>
<span class="sd">            ....:     print(s.canonical_label())</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            ...</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">            (0,1)(2,3,4)-(0,2,4)(1,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">bot</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_normal_perms</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span> <span class="o">=</span> <span class="n">SeparatrixDiagram</span><span class="p">(</span><span class="n">bot</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span><span class="o">.</span><span class="n">_normal_form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bot</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_bot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_top</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_bot_cycles</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_top_cycles</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cycle</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_bot_to_cycle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cycle</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_top_to_cycle</span>
            <span class="k">return</span>

        <span class="k">return</span> <span class="n">sep</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.horizontal_symmetry">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.horizontal_symmetry">[docs]</a>
    <span class="k">def</span> <span class="nf">horizontal_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the horizontal symmetric of this separatrix diagram.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1,2,3)(4,5)&#39;,&#39;(1,2,3)(4,5,0)&#39;)</span>
<span class="sd">            sage: sh = s.horizontal_symmetry()</span>
<span class="sd">            sage: print(sh)</span>
<span class="sd">            (0,5,4)(1,3,2)-(0,3,2,1)(4,5)</span>

<span class="sd">            sage: c = s.cylinder_diagrams(up_to_symmetry=False)[0].horizontal_symmetry()</span>
<span class="sd">            sage: ch = sh.cylinder_diagrams(up_to_symmetry=False)[0]</span>
<span class="sd">            sage: c.is_isomorphic(ch)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SeparatrixDiagram</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span><span class="p">),</span>
                                 <span class="nb">tuple</span><span class="p">(</span><span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span><span class="p">))</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.vertical_symmetry">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.vertical_symmetry">[docs]</a>
    <span class="k">def</span> <span class="nf">vertical_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vertical symmetric of this separatrix diagram.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1,2,3)(4,5)&#39;,&#39;(1,2,3)(4,5,0)&#39;)</span>
<span class="sd">            sage: sv = s.vertical_symmetry()</span>
<span class="sd">            sage: print(sv)</span>
<span class="sd">            (0,3,2,1)(4,5)-(0,5,4)(1,3,2)</span>

<span class="sd">            sage: c = sv.cylinder_diagrams(up_to_symmetry=False)[0].vertical_symmetry()</span>
<span class="sd">            sage: cv = sv.cylinder_diagrams(up_to_symmetry=False)[0]</span>
<span class="sd">            sage: c.is_isomorphic(cv)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SeparatrixDiagram</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span><span class="p">),</span>
                                 <span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span><span class="p">))</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.inverse">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.inverse">[docs]</a>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the inverse of this separatrix diagram, that is the one we obtain</span>
<span class="sd">        after application of `-Id`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1,2)(3,4,5,6,7,8)-(0,1,3,5,7)(2,4,6,8)&#39;)</span>
<span class="sd">            sage: s.inverse()</span>
<span class="sd">            (0,1,3,5,7)(2,4,6,8)-(0,1,2)(3,4,5,6,7,8)</span>
<span class="sd">            sage: s.horizontal_symmetry().vertical_symmetry() == s.inverse()</span>
<span class="sd">            True</span>
<span class="sd">            sage: s.vertical_symmetry().horizontal_symmetry() == s.inverse()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SeparatrixDiagram</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="nf">_get_normal_perms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the normal form of the permutations bot top defining self.</span>

<span class="sd">        Note that the result is cached.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        1) compute the orbit of G = &lt;bot,top&gt;</span>

<span class="sd">        2) for each of the connected component compute a normal form</span>

<span class="sd">        3) sort the list of (normal_top, normal_bot) and concatenate them</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,3,2)(1,4)&#39;,&#39;(0,1)(2,3,4)&#39;)</span>
<span class="sd">            sage: s._get_normal_perms()</span>
<span class="sd">            ([1, 0, 3, 4, 2], [2, 3, 4, 1, 0])</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,5,2)(1,3,4)(6,7,8)&#39;,&#39;(0,3,7,8)(1,5)(2,4,6)&#39;)</span>
<span class="sd">            sage: s._get_normal_perms()</span>
<span class="sd">            ([1, 2, 0, 4, 5, 3, 7, 8, 6], [1, 3, 5, 6, 8, 7, 0, 2, 4])</span>

<span class="sd">            (0,5,2)(1,3,4)(6,7,8)-(0,3,7,8)(1,5)(2,4,6)</span>
<span class="sd">            sage: s.canonical_label() #indirect doctest</span>
<span class="sd">            (0,1,2)(3,4,5)(6,7,8)-(0,1,3,6)(2,5,7)(4,8)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_bot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_top</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_normal_bot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_top</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_bot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_top</span>

    <span class="k">def</span> <span class="nf">_get_sym_perms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the four symmetric version of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">)</span>
        <span class="n">bot</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_normal_perms</span><span class="p">()</span>

        <span class="c1"># compute the inverses</span>
        <span class="n">ibot</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">itop</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ibot</span><span class="p">[</span><span class="n">bot</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">itop</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">hbot</span><span class="p">,</span> <span class="n">htop</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">itop</span><span class="p">,</span> <span class="n">ibot</span><span class="p">)</span>
        <span class="n">vbot</span><span class="p">,</span> <span class="n">vtop</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">ibot</span><span class="p">,</span> <span class="n">itop</span><span class="p">)</span>
        <span class="n">sbot</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bot</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">),(</span><span class="n">hbot</span><span class="p">,</span><span class="n">htop</span><span class="p">),(</span><span class="n">vbot</span><span class="p">,</span><span class="n">vtop</span><span class="p">),(</span><span class="n">sbot</span><span class="p">,</span><span class="n">stop</span><span class="p">)</span>

<div class="viewcode-block" id="SeparatrixDiagram.symmetries">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.symmetries">[docs]</a>
    <span class="k">def</span> <span class="nf">symmetries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a triple of boolean ``(horiz_sym, vert_sym, inverse_sym)`` which</span>
<span class="sd">        correspond to the symmetry of ``self``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1,2)(3,4,5)-(0,1)(2,3,4,5)&#39;)</span>
<span class="sd">            sage: s.symmetries()</span>
<span class="sd">            (False, True, False)</span>
<span class="sd">            sage: s.horizontal_symmetry().is_isomorphic(s)</span>
<span class="sd">            False</span>
<span class="sd">            sage: s.vertical_symmetry().is_isomorphic(s)</span>
<span class="sd">            True</span>
<span class="sd">            sage: s.inverse().is_isomorphic(s)</span>
<span class="sd">            False</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1,3,5)(2,4)-(0,4,1,5)(2,3)&#39;)</span>
<span class="sd">            sage: s.symmetries()</span>
<span class="sd">            (True, False, False)</span>
<span class="sd">            sage: s.horizontal_symmetry().is_isomorphic(s)</span>
<span class="sd">            True</span>
<span class="sd">            sage: s.vertical_symmetry().is_isomorphic(s)</span>
<span class="sd">            False</span>
<span class="sd">            sage: s.inverse().is_isomorphic(s)</span>
<span class="sd">            False</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1,3,5)(2,4)-(0,3,2,1)(5,4)&#39;)</span>
<span class="sd">            sage: s.symmetries()</span>
<span class="sd">            (False, False, True)</span>
<span class="sd">            sage: s.horizontal_symmetry().is_isomorphic(s)</span>
<span class="sd">            False</span>
<span class="sd">            sage: s.vertical_symmetry().is_isomorphic(s)</span>
<span class="sd">            False</span>
<span class="sd">            sage: s.inverse().is_isomorphic(s)</span>
<span class="sd">            True</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0)(1,2,3,4,5)-(0,1,2,5,3)(4)&#39;)</span>
<span class="sd">            sage: s.symmetries()</span>
<span class="sd">            (False, False, False)</span>
<span class="sd">            sage: s.horizontal_symmetry().is_isomorphic(s)</span>
<span class="sd">            False</span>
<span class="sd">            sage: s.vertical_symmetry().is_isomorphic(s)</span>
<span class="sd">            False</span>
<span class="sd">            sage: s.inverse().is_isomorphic(s)</span>
<span class="sd">            False</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: sym = lambda s: (s.horizontal_symmetry().is_isomorphic(s),</span>
<span class="sd">            ....:                  s.vertical_symmetry().is_isomorphic(s),</span>
<span class="sd">            ....:                  s.inverse().is_isomorphic(s))</span>
<span class="sd">            sage: from surface_dynamics.flat_surfaces.separatrix_diagram import separatrix_diagram_iterator</span>
<span class="sd">            sage: for s in separatrix_diagram_iterator((2,2,2,2)):</span>
<span class="sd">            ....:     assert s.symmetries() == sym(s)</span>
<span class="sd">            sage: for s in separatrix_diagram_iterator((4,2)):</span>
<span class="sd">            ....:     assert s.symmetries() == sym(s)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">)</span>
        <span class="n">bot</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_normal_perms</span><span class="p">()</span>

        <span class="c1"># compute the inverses</span>
        <span class="n">ibot</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">itop</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ibot</span><span class="p">[</span><span class="n">bot</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">itop</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1"># horiz</span>
        <span class="n">bot1</span><span class="p">,</span> <span class="n">top1</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">itop</span><span class="p">,</span> <span class="n">ibot</span><span class="p">)</span>
        <span class="n">horiz_sym</span> <span class="o">=</span> <span class="n">bot</span> <span class="o">==</span> <span class="n">bot1</span> <span class="ow">and</span> <span class="n">top</span> <span class="o">==</span> <span class="n">top1</span>

        <span class="c1"># vert</span>
        <span class="n">bot1</span><span class="p">,</span> <span class="n">top1</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">ibot</span><span class="p">,</span> <span class="n">itop</span><span class="p">)</span>
        <span class="n">vert_sym</span> <span class="o">=</span> <span class="n">bot</span> <span class="o">==</span> <span class="n">bot1</span> <span class="ow">and</span> <span class="n">top</span> <span class="o">==</span> <span class="n">top1</span>

        <span class="c1"># inv</span>
        <span class="k">if</span> <span class="n">horiz_sym</span> <span class="ow">and</span> <span class="n">vert_sym</span><span class="p">:</span>  <span class="c1"># got the two</span>
            <span class="n">inverse_sym</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">horiz_sym</span><span class="o">^</span><span class="n">vert_sym</span><span class="p">:</span>    <span class="c1"># got exactly one</span>
            <span class="n">inverse_sym</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>                       <span class="c1"># none of them</span>
            <span class="n">bot1</span><span class="p">,</span> <span class="n">top1</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bot</span><span class="p">)</span>
            <span class="n">inverse_sym</span> <span class="o">=</span> <span class="n">bot</span> <span class="o">==</span> <span class="n">bot1</span> <span class="ow">and</span> <span class="n">top</span> <span class="o">==</span> <span class="n">top1</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">horiz_sym</span><span class="p">,</span> <span class="n">vert_sym</span><span class="p">,</span> <span class="n">inverse_sym</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.is_in_normal_form">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.is_in_normal_form">[docs]</a>
    <span class="k">def</span> <span class="nf">is_in_normal_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test normal form</span>

<span class="sd">        Return True if self is in normal form and False otherwise.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1,2)(3,4,5)(6,7,8)&#39;,&#39;(0,3,7,8)(1,5)(2,4,6)&#39;)</span>
<span class="sd">            sage: s.is_in_normal_form()</span>
<span class="sd">            False</span>
<span class="sd">            sage: s.canonical_label().is_in_normal_form()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_normal_perms</span><span class="p">()</span></div>


    <span class="c1">#</span>
    <span class="c1"># Attributes access</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="SeparatrixDiagram.degree">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.degree">[docs]</a>
    <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the degree (number of separatrices) of this separatrix diagram.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: S = SeparatrixDiagram(&#39;(0,1)(2,3)&#39;,&#39;(1,3,2)(0)&#39;)</span>
<span class="sd">            sage: S.degree()</span>
<span class="sd">            4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">)</span></div>


    <span class="n">nseps</span> <span class="o">=</span> <span class="n">degree</span>
    <span class="n">num_edges</span> <span class="o">=</span> <span class="n">degree</span>

<div class="viewcode-block" id="SeparatrixDiagram.ncyls">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.ncyls">[docs]</a>
    <span class="k">def</span> <span class="nf">ncyls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of cylinders of this separatrix diagram.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: S = SeparatrixDiagram(&#39;(0,1)(2,3)&#39;,&#39;(1,3,2)(0)&#39;)</span>
<span class="sd">            sage: S.ncyls()</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.profile">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.profile">[docs]</a>
    <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the angles around each vertex</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStratum(1,1,0)</span>
<span class="sd">            sage: s = a.separatrix_diagrams()[0]</span>
<span class="sd">            sage: s.profile()</span>
<span class="sd">            [2, 2, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">perm_cycle_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outgoing_edges_perm</span><span class="p">())</span>

        <span class="kn">from</span> <span class="nn">sage.combinat.partition</span> <span class="kn">import</span> <span class="n">Partition</span>
        <span class="k">return</span> <span class="n">Partition</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.euler_characteristic">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.euler_characteristic">[docs]</a>
    <span class="k">def</span> <span class="nf">euler_characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Euler characteristic</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: SeparatrixDiagram(&#39;(0)&#39;,&#39;(0)&#39;).euler_characteristic()</span>
<span class="sd">            0</span>

<span class="sd">            sage: CylinderDiagram([((0,),(0,))]).euler_characteristic()</span>
<span class="sd">            0</span>
<span class="sd">            sage: CylinderDiagram([((0,1),(0,2)), ((2,),(1,))]).euler_characteristic()</span>
<span class="sd">            -2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="p">))</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.genus">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.genus">[docs]</a>
    <span class="k">def</span> <span class="nf">genus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the genus</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: CylinderDiagram([((0,),(0,))]).genus()</span>
<span class="sd">            1</span>
<span class="sd">            sage: CylinderDiagram([((0,1),(0,1))]).genus()</span>
<span class="sd">            1</span>
<span class="sd">            sage: CylinderDiagram([((0,1,2),(0,1,2))]).genus()</span>
<span class="sd">            2</span>
<span class="sd">            sage: CylinderDiagram([((0,1,2,3),(0,1,2,3))]).genus()</span>
<span class="sd">            2</span>
<span class="sd">            sage: CylinderDiagram([((0,1,2,3,4),(0,1,2,3,4))]).genus()</span>
<span class="sd">            3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.stratum">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.stratum">[docs]</a>
    <span class="k">def</span> <span class="nf">stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Abelian stratum this separatrix diagram belongs to.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: SeparatrixDiagram(&#39;(0)(1)(2)&#39;,&#39;(0)(1)(2)&#39;).stratum()</span>
<span class="sd">            H_1(0^3)</span>
<span class="sd">            sage: SeparatrixDiagram(&#39;(0,1)(2)&#39;,&#39;(0,2)(1)&#39;).stratum()</span>
<span class="sd">            H_2(2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.abelian_strata</span> <span class="kn">import</span> <span class="n">AbelianStratum</span>

        <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">()])</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.bot">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.bot">[docs]</a>
    <span class="k">def</span> <span class="nf">bot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The bot permutation as a list from 0 to nseps-1</span>

<span class="sd">        Warning: the output list should not be modified</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0)(1,2)&#39;,&#39;(0,1)(2)&#39;)</span>
<span class="sd">            sage: s.bot()</span>
<span class="sd">            [0, 2, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.bot_perm">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.bot_perm">[docs]</a>
    <span class="k">def</span> <span class="nf">bot_perm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the bot as a permutation (element of a group)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0)(1,2)&#39;,&#39;(0,1)(2)&#39;)</span>
<span class="sd">            sage: s.bot_perm()</span>
<span class="sd">            (2,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Trac #28652: Rework the constructor of PermutationGroupElement</span>
            <span class="kn">from</span> <span class="nn">sage.groups.perm_gps.constructor</span> <span class="kn">import</span> <span class="n">PermutationGroupElement</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.groups.perm_gps.permgroup_element</span> <span class="kn">import</span> <span class="n">PermutationGroupElement</span>

        <span class="k">return</span> <span class="n">PermutationGroupElement</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">])</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.bot_orbit">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.bot_orbit">[docs]</a>
    <span class="k">def</span> <span class="nf">bot_orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the orbit of i under the bot permutation</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1)(2,5)(3,4,6)&#39;,&#39;(0,1,5)(2,3,6)(4)&#39;)</span>
<span class="sd">            sage: s.bot_orbit(0)</span>
<span class="sd">            (0, 1)</span>
<span class="sd">            sage: s.bot_orbit(4)</span>
<span class="sd">            (3, 4, 6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cycle</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.bot_cycle_tuples">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.bot_cycle_tuples">[docs]</a>
    <span class="k">def</span> <span class="nf">bot_cycle_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cycles of the bottom permutation as a list of tuples.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: S = SeparatrixDiagram(&#39;(0,2)(3,4)&#39;,&#39;(0)(1,2,3)&#39;)</span>
<span class="sd">            sage: S.bot_cycle_tuples()</span>
<span class="sd">            [(0, 2), (1,), (3, 4)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.bot_cycle_string">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.bot_cycle_string">[docs]</a>
    <span class="k">def</span> <span class="nf">bot_cycle_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cycles of the top permutation as a string.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: S = SeparatrixDiagram(&#39;(0,2)(3,4)&#39;,&#39;(0)(1,2,3)&#39;)</span>
<span class="sd">            sage: S.bot_cycle_string()</span>
<span class="sd">            &#39;(0,2)(1)(3,4)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">c</span><span class="p">))</span> <span class="o">+</span><span class="s1">&#39;)&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_cycle_tuples</span><span class="p">())</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.top">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.top">[docs]</a>
    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the top permutation of self as a list.</span>

<span class="sd">        Warning: the output should not be modified</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1,3)(2,4)&#39;,&#39;(0,4)(1,2,3)&#39;)</span>
<span class="sd">            sage: s.top()</span>
<span class="sd">            [4, 2, 3, 1, 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.top_perm">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.top_perm">[docs]</a>
    <span class="k">def</span> <span class="nf">top_perm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the top as a permutation</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0)(1,2)&#39;,&#39;(1)(0,2)&#39;)</span>
<span class="sd">            sage: s.top_perm()</span>
<span class="sd">            (1,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Trac #28652: Rework the constructor of PermutationGroupElement</span>
            <span class="kn">from</span> <span class="nn">sage.groups.perm_gps.constructor</span> <span class="kn">import</span> <span class="n">PermutationGroupElement</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.groups.perm_gps.permgroup_element</span> <span class="kn">import</span> <span class="n">PermutationGroupElement</span>
        <span class="k">return</span> <span class="n">PermutationGroupElement</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">])</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.top_orbit">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.top_orbit">[docs]</a>
    <span class="k">def</span> <span class="nf">top_orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the orbit of ``i`` under the top permutation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1)(2,5)(3,4,6)&#39;,&#39;(0,1,5)(2,3,6)(4)&#39;)</span>
<span class="sd">            sage: s.top_orbit(0)</span>
<span class="sd">            (0, 1, 5)</span>
<span class="sd">            sage: s.top_orbit(6)</span>
<span class="sd">            (2, 3, 6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cycle</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.top_cycle_tuples">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.top_cycle_tuples">[docs]</a>
    <span class="k">def</span> <span class="nf">top_cycle_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cycle of the top permutation as a list of tuples.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: S = SeparatrixDiagram(&#39;(0,2)(3,4)&#39;,&#39;(0)(1,2,3)&#39;)</span>
<span class="sd">            sage: S.top_cycle_tuples()</span>
<span class="sd">            [(0,), (1, 2, 3), (4,)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.top_cycle_string">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.top_cycle_string">[docs]</a>
    <span class="k">def</span> <span class="nf">top_cycle_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cycle of the top permutation as a string.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: S = SeparatrixDiagram(&#39;(0,2)(3,4)&#39;,&#39;(0)(1,2,3)&#39;)</span>
<span class="sd">            sage: S.top_cycle_string()</span>
<span class="sd">            &#39;(0)(1,2,3)(4)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">c</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_cycle_tuples</span><span class="p">())</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.automorphism_group">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.automorphism_group">[docs]</a>
    <span class="k">def</span> <span class="nf">automorphism_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="s1">&#39;graph&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the automorphism group of self.</span>

<span class="sd">        That is the centralizer of the permutations top and bottom.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``implementation`` - either graph or gap</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: S = SeparatrixDiagram(&#39;(0,3,1,4,2)&#39;,&#39;(0,1,2,3,4)&#39;)</span>
<span class="sd">            sage: G1 = S.automorphism_group(implementation=&#39;graph&#39;); G1</span>
<span class="sd">            Permutation Group with generators [(0,1,2,3,4)]</span>
<span class="sd">            sage: G2 = S.automorphism_group(implementation=&#39;gap&#39;); G2</span>
<span class="sd">            Subgroup ...</span>
<span class="sd">            sage: G1.is_isomorphic(G2)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">implementation</span> <span class="o">==</span> <span class="s1">&#39;graph&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_directed_graph</span><span class="p">()</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">implementation</span> <span class="o">==</span> <span class="s1">&#39;gap&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.groups.perm_gps.permgroup</span> <span class="kn">import</span> <span class="n">PermutationGroup</span>
            <span class="kn">from</span> <span class="nn">sage.groups.perm_gps.permgroup_named</span> <span class="kn">import</span> <span class="n">SymmetricGroup</span>

            <span class="k">return</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())</span><span class="o">.</span><span class="n">centralizer</span><span class="p">(</span><span class="n">PermutationGroup</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">top_perm</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">bot_perm</span><span class="p">()]))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;implementation should be either &#39;graph&#39; or &#39;gap&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.homological_dimension_of_cylinders">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.homological_dimension_of_cylinders">[docs]</a>
    <span class="k">def</span> <span class="nf">homological_dimension_of_cylinders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the dimension in the first homology group of the span of waist</span>
<span class="sd">        curves of horizontal cylinders.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        Homological dimension in the stratum H(2)::</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,2)-(0,1,2)&#39;)</span>
<span class="sd">            sage: c.stratum()</span>
<span class="sd">            H_2(2)</span>
<span class="sd">            sage: c.homological_dimension_of_cylinders()</span>
<span class="sd">            1</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(1,2) (2)-(0)&#39;)</span>
<span class="sd">            sage: c.stratum()</span>
<span class="sd">            H_2(2)</span>
<span class="sd">            sage: c.homological_dimension_of_cylinders()</span>
<span class="sd">            2</span>

<span class="sd">        Homological dimensions for cylinder diagrams in H(1,1)::</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,2,3)-(0,1,2,3)&#39;)</span>
<span class="sd">            sage: c.stratum()</span>
<span class="sd">            H_2(1^2)</span>
<span class="sd">            sage: c.homological_dimension_of_cylinders()</span>
<span class="sd">            1</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(0,2) (2,3)-(1,3)&#39;)</span>
<span class="sd">            sage: c.stratum()</span>
<span class="sd">            H_2(1^2)</span>
<span class="sd">            sage: c.homological_dimension_of_cylinders()</span>
<span class="sd">            2</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,2)-(1,2,3) (3)-(0)&#39;)</span>
<span class="sd">            sage: c.stratum()</span>
<span class="sd">            H_2(1^2)</span>
<span class="sd">            sage: c.homological_dimension_of_cylinders()</span>
<span class="sd">            2</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(2,3) (2)-(0) (3)-(1)&#39;)</span>
<span class="sd">            sage: c.stratum()</span>
<span class="sd">            H_2(1^2)</span>
<span class="sd">            sage: c.homological_dimension_of_cylinders()</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span> <span class="o">-</span> <span class="n">SeparatrixDiagram</span><span class="o">.</span><span class="n">to_directed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">connected_components_number</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.homologous_cylinders">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.homologous_cylinders">[docs]</a>
    <span class="k">def</span> <span class="nf">homologous_cylinders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of homologous cylinders.</span>

<span class="sd">        OUTPUT: a list of lists. Each sublist is an equivalence class of &gt; 1</span>
<span class="sd">        homologous cylinders.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import CylinderDiagram</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,7,1,2)-(3,6,4,5) (3,6,4,5)-(0,7,1,2)&#39;)</span>
<span class="sd">            sage: c.homologous_cylinders()</span>
<span class="sd">            [[0, 1]]</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(2,3) (2)-(0) (3)-(1)&#39;)</span>
<span class="sd">            sage: c.homologous_cylinders()</span>
<span class="sd">            []</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,2,1)-(9) (3,6,4,5)-(7,10,8) (7,9,8)-(3,6,4,5) (10)-(0,2,1)&#39;)</span>
<span class="sd">            sage: c.homologous_cylinders()</span>
<span class="sd">            [[0, 3], [1, 2]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.twist_space</span> <span class="kn">import</span> <span class="n">TwistSpace</span>
        <span class="k">return</span> <span class="n">TwistSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">homologous_cylinders</span><span class="p">()</span></div>


    <span class="c1">#</span>
    <span class="c1"># Vertices of the separatrix diagram</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="SeparatrixDiagram.outgoing_edges_perm">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.outgoing_edges_perm">[docs]</a>
    <span class="k">def</span> <span class="nf">outgoing_edges_perm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Permutation associated to turning around vertices in trigonometric</span>
<span class="sd">        order.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1)&#39;,&#39;(2,3)&#39;)</span>
<span class="sd">            sage: s.outgoing_edges_perm()</span>
<span class="sd">            [1, 0, 3, 2]</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,5,2)(1,3,4)(6,7,8)&#39;,&#39;(0,3,7,8)(1,5)(2,4,6)&#39;)</span>
<span class="sd">            sage: s.outgoing_edges_perm()</span>
<span class="sd">            [6, 2, 1, 5, 0, 8, 7, 4, 3]</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,5,2,1,4,3)-(0,4,2,1,5,3)&#39;)</span>
<span class="sd">            sage: c.outgoing_edges_perm()</span>
<span class="sd">            [5, 4, 1, 0, 2, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">perm_compose_i</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.incoming_edges_perm">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.incoming_edges_perm">[docs]</a>
    <span class="k">def</span> <span class="nf">incoming_edges_perm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Permutation associated to turning around vertices in trigonometric</span>
<span class="sd">        order.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1)&#39;,&#39;(2,3)&#39;)</span>
<span class="sd">            sage: s.incoming_edges_perm()</span>
<span class="sd">            [1, 0, 3, 2]</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,5,2)(1,3,4)(6,7,8)&#39;,&#39;(0,3,7,8)(1,5)(2,4,6)&#39;)</span>
<span class="sd">            sage: s.incoming_edges_perm()</span>
<span class="sd">            [7, 0, 8, 2, 5, 4, 3, 1, 6]</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,5,2,1,4,3)-(0,4,2,1,5,3)&#39;)</span>
<span class="sd">            sage: c.incoming_edges_perm()</span>
<span class="sd">            [4, 5, 1, 0, 3, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">perm_compose_i</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.vertices">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.vertices">[docs]</a>
    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of pairs ``(vout, vin)`` where each pair represent a vertex and</span>
<span class="sd">        ``vout``, ``vin`` are respectively the labels of outgoing/incoming separatrices</span>
<span class="sd">        at this vertex.</span>

<span class="sd">        EXAMPLES::</span>


<span class="sd">            sage: from surface_dynamics import CylinderDiagram</span>
<span class="sd">            sage: from surface_dynamics.misc.permutation import perm_cycles</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(0,2,6,7,4,5,3,8) (2,7,3,4,8,6,5)-(1)&#39;)</span>
<span class="sd">            sage: c.vertices()</span>
<span class="sd">            [([0, 1, 8, 7], [0, 4, 2, 1]), ([2, 4, 5], [3, 6, 5]), ([3, 6], [7, 8])]</span>
<span class="sd">            sage: perm_cycles(c.outgoing_edges_perm())</span>
<span class="sd">            [[0, 1, 8, 7], [2, 4, 5], [3, 6]]</span>
<span class="sd">            sage: perm_cycles(c.incoming_edges_perm())</span>
<span class="sd">            [[0, 4, 2, 1], [3, 6, 5], [7, 8]]</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,3,4,2)-(0,1,5,7,6) (5,6)-(4) (7)-(2,3)&#39;)</span>
<span class="sd">            sage: perm_cycles(c.outgoing_edges_perm())</span>
<span class="sd">            [[0, 3], [1, 6], [2, 4], [5, 7]]</span>
<span class="sd">            sage: perm_cycles(c.incoming_edges_perm())</span>
<span class="sd">            [[0, 5], [1, 2], [3, 4], [6, 7]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">perm_invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">)</span>
        <span class="n">bot</span> <span class="o">=</span> <span class="n">perm_invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">)</span>

        <span class="n">seen</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">seen</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">cout</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cin</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">seen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">seen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">cout</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">cin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bot</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="n">bot</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">cin</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cout</span><span class="p">,</span> <span class="n">cin</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span> <span class="o">+</span> <span class="n">cin</span><span class="p">[:</span><span class="n">j</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">res</span></div>


    <span class="c1">#</span>
    <span class="c1"># to cylinder diagram</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="SeparatrixDiagram.to_cylinder_diagram">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.to_cylinder_diagram">[docs]</a>
    <span class="k">def</span> <span class="nf">to_cylinder_diagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairing</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a cylinder diagram with the given pairing</span>

<span class="sd">        The pairing should be a list of 2-tuples of integer.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1,3)(2,4)&#39;,&#39;(0,2)(1,4,3)&#39;); s</span>
<span class="sd">            (0,1,3)(2,4)-(0,2)(1,4,3)</span>

<span class="sd">            sage: s.to_cylinder_diagram([(0,0),(1,1)])</span>
<span class="sd">            (0,1,3)-(0,2) (2,4)-(1,4,3)</span>
<span class="sd">            sage: s.to_cylinder_diagram([(1,1),(0,0)])</span>
<span class="sd">            (0,1,3)-(0,2) (2,4)-(1,4,3)</span>

<span class="sd">            sage: s.to_cylinder_diagram([(0,1),(1,0)])</span>
<span class="sd">            (0,1,3)-(1,4,3) (2,4)-(0,2)</span>
<span class="sd">            sage: s.to_cylinder_diagram([(1,0),(0,1)])</span>
<span class="sd">            (0,1,3)-(1,4,3) (2,4)-(0,2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">CylinderDiagram</span>

        <span class="n">bots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_cycle_tuples</span><span class="p">()</span>
        <span class="n">tops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_cycle_tuples</span><span class="p">()</span>

        <span class="n">other</span><span class="o">.</span><span class="n">_bot_to_cyl</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_top_to_cyl</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pairing</span><span class="p">)):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">bots</span><span class="p">[</span><span class="n">pairing</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tops</span><span class="p">[</span><span class="n">pairing</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">cyl</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">_bot_to_cyl</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cyl</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">_top_to_cyl</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cyl</span>

        <span class="k">return</span> <span class="n">other</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.cylinder_diagram_iterator">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.cylinder_diagram_iterator">[docs]</a>
    <span class="nd">@rename_keyword</span><span class="p">(</span><span class="n">deprecation</span><span class="o">=</span><span class="mi">666</span><span class="p">,</span> <span class="n">up_to_isomorphism</span><span class="o">=</span><span class="s1">&#39;up_to_symmetry&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cylinder_diagram_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct all cylinder diagrams from given separatrix diagram (i.e. a pair</span>
<span class="sd">        of permutations).</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``connected`` - boolean (default: True) - if true, returns only</span>
<span class="sd">          connected cylinder diagrams.</span>

<span class="sd">        - ``up_to_symmetry`` - boolean (default: True) take care of the horizontal</span>
<span class="sd">          and vertical symmetries.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1)(2,3)(4,5)&#39;,&#39;(1,2)(3,4)(5,0)&#39;)</span>
<span class="sd">            sage: for c in s.cylinder_diagram_iterator(): print(c)  # random</span>
<span class="sd">            (0,5)-(0,4) (1,4)-(1,3) (2,3)-(2,5)</span>
<span class="sd">            (0,3)-(0,5) (1,2)-(1,4) (4,5)-(2,3)</span>
<span class="sd">            (0,5)-(3,4) (1,4)-(0,2) (2,3)-(1,5)</span>
<span class="sd">            sage: sum(1 for _ in s.cylinder_diagram_iterator(up_to_symmetry=False))</span>
<span class="sd">            6</span>
<span class="sd">            sage: sum(1 for _ in s.cylinder_diagram_iterator(up_to_symmetry=True))</span>
<span class="sd">            3</span>

<span class="sd">        Here is an example with some symmetry::</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0)(1)(2,3)(4,5,6)-(0,1)(2,4)(3,5)(6)&#39;)</span>
<span class="sd">            sage: s.vertical_symmetry().canonical_label() == s</span>
<span class="sd">            True</span>
<span class="sd">            sage: C1 = [CylinderDiagram(&#39;(0,1)-(4) (2,4,3)-(5,6) (5)-(0,2) (6)-(1,3)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,3,1)-(0,6) (2,6)-(4,5) (4)-(1) (5)-(2,3)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,1)-(0,4) (2,3,4)-(5,6) (5)-(2) (6)-(1,3)&#39;)]</span>
<span class="sd">            sage: C2 = s.cylinder_diagrams()</span>
<span class="sd">            sage: assert len(C1) == len(C2)</span>
<span class="sd">            sage: for (c1, c2) in zip(C1, C2): assert c1.is_isomorphic(c2)</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import SeparatrixDiagram</span>
<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,3)(1,4,5)(2)&#39;,&#39;(0)(1,2)(3,4,5)&#39;)</span>
<span class="sd">            sage: C2 = s.cylinder_diagram_iterator(up_to_isomorphism=True)</span>
<span class="sd">            doctest:warning</span>
<span class="sd">            ...</span>
<span class="sd">            DeprecationWarning: use the option &#39;up_to_symmetry&#39; instead of &#39;up_to_isomorphism&#39;</span>
<span class="sd">            ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cbot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_cycle_tuples</span><span class="p">()</span>
        <span class="n">ctop0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_cycle_tuples</span><span class="p">()</span>

        <span class="n">connected</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">connected</span>

        <span class="k">if</span> <span class="n">up_to_symmetry</span><span class="p">:</span>
            <span class="c1"># NOTE: here we should only consider symmetries of the cylinder diagrams</span>
            <span class="c1"># only when this underlying separatrix diagrams has some. But the</span>
            <span class="c1"># canonical labels of cylinder diagrams and separatrix diagrams are</span>
            <span class="c1"># not compatible!!</span>

            <span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="n">hsym</span><span class="p">,</span> <span class="n">vsym</span><span class="p">,</span> <span class="n">isym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ctop</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">ctop0</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">CylinderDiagram</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cbot</span><span class="p">,</span><span class="n">ctop</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">cc</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">hsym</span><span class="p">:</span>
                    <span class="n">c1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">horizontal_symmetry</span><span class="p">()</span>
                    <span class="n">c1</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">cc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">vsym</span><span class="p">:</span>
                    <span class="n">c1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">vertical_symmetry</span><span class="p">()</span>
                    <span class="n">c1</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">cc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">isym</span><span class="p">:</span>
                    <span class="n">c1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
                    <span class="n">c1</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">cc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">connected</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">is_connected</span><span class="p">())</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">smallest_integer_lengths</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="nb">min</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ctop</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">ctop0</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">CylinderDiagram</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cbot</span><span class="p">,</span><span class="n">ctop</span><span class="p">),</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">connected</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">is_connected</span><span class="p">())</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">smallest_integer_lengths</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="n">c</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.cylinder_diagrams">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.cylinder_diagrams">[docs]</a>
    <span class="nd">@rename_keyword</span><span class="p">(</span><span class="n">deprecation</span><span class="o">=</span><span class="mi">666</span><span class="p">,</span> <span class="n">up_to_isomorphism</span><span class="o">=</span><span class="s1">&#39;up_to_symmetry&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cylinder_diagrams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of cylinder diagrams associated to this separatrix</span>
<span class="sd">        diagram.</span>

<span class="sd">        We warn that the cylinder diagram may be renumeroted in the output list</span>
<span class="sd">        (in order to prevent repetitions). If you care about numerotation the</span>
<span class="sd">        option ``up_to_symmetry`` should be set to False.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``connected`` - boolean (default: True)</span>

<span class="sd">        - ``up_to_symmetry`` - boolean (default: True)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0)(1)(2)&#39;,&#39;(0)(1)(2)&#39;)</span>
<span class="sd">            sage: for c in s.cylinder_diagrams(connected=True): print(c)</span>
<span class="sd">            (0)-(2) (1)-(0) (2)-(1)</span>
<span class="sd">            sage: for c in s.cylinder_diagrams(connected=False): print(c)</span>
<span class="sd">            (0)-(0) (1)-(1) (2)-(2)</span>
<span class="sd">            (0)-(1) (1)-(0) (2)-(2)</span>
<span class="sd">            (0)-(2) (1)-(0) (2)-(1)</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1)(2)&#39;,&#39;(0)(1,2)&#39;)</span>
<span class="sd">            sage: C1 = [CylinderDiagram(&#39;(0,1)-(0,2) (2)-(1)&#39;)]</span>
<span class="sd">            sage: C2 = s.cylinder_diagrams()</span>
<span class="sd">            sage: assert len(C1) == len(C2)</span>
<span class="sd">            sage: for (c1, c2) in zip(C1, C2): assert c1.is_isomorphic(c2)</span>

<span class="sd">        In the example below, there is no isomorphism problem for the cylinder</span>
<span class="sd">        diagram generation as the separatrix diagram admit no automorphism::</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,3)(1,4,5)(2)&#39;,&#39;(0)(1,2)(3,4,5)&#39;)</span>
<span class="sd">            sage: s.automorphism_group()</span>
<span class="sd">            Permutation Group with generators [()]</span>
<span class="sd">            sage: C1 = [CylinderDiagram(&#39;(0,3,1)-(5) (2,5)-(3,4) (4)-(0,2,1)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,1,2)-(0,1,5) (3,5)-(2,4) (4)-(3)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,2,3)-(2,5) (1,4)-(0,1,3) (5)-(4)&#39;)]</span>
<span class="sd">            sage: C2 = s.cylinder_diagrams()</span>
<span class="sd">            sage: C3 = s.cylinder_diagrams(up_to_symmetry=False)</span>
<span class="sd">            sage: assert len(C1) == len(C2) == len(C3)</span>
<span class="sd">            sage: for (c1, c2, c3) in zip(C1, C2, C3): assert c1.is_isomorphic(c2) and c1.is_isomorphic(c3)</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import SeparatrixDiagram</span>
<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,3)(1,4,5)(2)&#39;,&#39;(0)(1,2)(3,4,5)&#39;)</span>
<span class="sd">            sage: C2 = s.cylinder_diagrams(up_to_isomorphism=True)</span>
<span class="sd">            doctest:warning</span>
<span class="sd">            ...</span>
<span class="sd">            DeprecationWarning: use the option &#39;up_to_symmetry&#39; instead of &#39;up_to_isomorphism&#39;</span>
<span class="sd">            ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span>
            <span class="n">connected</span><span class="o">=</span><span class="n">connected</span><span class="p">,</span>
            <span class="n">up_to_symmetry</span><span class="o">=</span><span class="n">up_to_symmetry</span><span class="p">))</span></div>


<div class="viewcode-block" id="SeparatrixDiagram.saddle_connections_graph">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.SeparatrixDiagram.saddle_connections_graph">[docs]</a>
    <span class="k">def</span> <span class="nf">saddle_connections_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the fat graph (or ribbon graph) made by the saddle connections.</span>

<span class="sd">        The return graph is a</span>
<span class="sd">        :class:`~surface_dynamics.topology.fat_graph.FatGraph`. The saddle</span>
<span class="sd">        connection labelled `i` on this diagram gets labels `2i` and `2i+1` in</span>
<span class="sd">        the graph (there one label per half-edge in the fat graph). The even</span>
<span class="sd">        labels correspond to half-edges in the bottom of cylinders while the</span>
<span class="sd">        odd ones correspond to the top.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import AbelianStratum</span>
<span class="sd">            sage: H11 = AbelianStratum(1,1).unique_component()</span>
<span class="sd">            sage: for cd in H11.cylinder_diagrams():</span>
<span class="sd">            ....:     fg = cd.saddle_connections_graph()</span>
<span class="sd">            ....:     print(cd.ncyls(), [comp.genus() for comp in fg.connected_components()])</span>
<span class="sd">            1 [1]</span>
<span class="sd">            2 [0]</span>
<span class="sd">            2 [0]</span>
<span class="sd">            3 [0, 0]</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import AbelianStrata</span>
<span class="sd">            sage: for g in (2, 3):</span>
<span class="sd">            ....:     for H in AbelianStrata(genus=g):</span>
<span class="sd">            ....:         for C in H.components():</span>
<span class="sd">            ....:             for cd in C.cylinder_diagrams():</span>
<span class="sd">            ....:                 fg = cd.saddle_connections_graph()</span>
<span class="sd">            ....:                 assert fg.num_faces() == 2 * cd.ncyls()</span>
<span class="sd">            ....:                 assert fg.euler_characteristic() == cd.euler_characteristic() + 2 * cd.ncyls()</span>
<span class="sd">            ....:                 assert len(fg.connected_components()) == 1 + cd.ncyls() - cd.homological_dimension_of_cylinders()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">)</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">fp</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">fp</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="kn">from</span> <span class="nn">surface_dynamics.topology.fat_graph</span> <span class="kn">import</span> <span class="n">FatGraph</span>
        <span class="k">return</span> <span class="n">FatGraph</span><span class="p">(</span><span class="n">fp</span><span class="o">=</span><span class="n">fp</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="n">mutable</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="cyclic_direction">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.cyclic_direction">[docs]</a>
<span class="k">def</span> <span class="nf">cyclic_direction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns 1 or -1 depending on the cyclic ordering of (x,y,z)</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from surface_dynamics.flat_surfaces.separatrix_diagram import cyclic_direction</span>
<span class="sd">        sage: cyclic_direction(0,1,2)</span>
<span class="sd">        1</span>
<span class="sd">        sage: cyclic_direction(1,2,0)</span>
<span class="sd">        1</span>
<span class="sd">        sage: cyclic_direction(2,0,1)</span>
<span class="sd">        1</span>
<span class="sd">        sage: cyclic_direction(2,1,0)</span>
<span class="sd">        -1</span>
<span class="sd">        sage: cyclic_direction(1,0,2)</span>
<span class="sd">        -1</span>
<span class="sd">        sage: cyclic_direction(0,2,1)</span>
<span class="sd">        -1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>



<span class="c1"># iterators</span>

<div class="viewcode-block" id="separatrix_diagram_fast_iterator">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.separatrix_diagram_fast_iterator">[docs]</a>
<span class="k">def</span> <span class="nf">separatrix_diagram_fast_iterator</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span><span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterator over separatrix diagram with given ``profile``</span>

<span class="sd">    Return a list of 3-tuples ``[bot, top, s]`` where ``bot`` and ``top`` are</span>
<span class="sd">    list on 0, ..., nseps-1 that corresponds to a separatrix diagram with</span>
<span class="sd">    profile ``profile`` while ``s`` is the element conjugacy class corresponding</span>
<span class="sd">    to the profile which equals ``bot * top``.</span>

<span class="sd">    If ncyls is not None, it should be a list of integers from which the number</span>
<span class="sd">    of cylinders is considered.</span>

<span class="sd">    Warning: each isomorphism class of separatrix diagram is output more than</span>
<span class="sd">    once in general. If you want a unique representative in each isomorphism</span>
<span class="sd">    class you may consider the method separatrix_diagram_iterator instead.</span>

<span class="sd">    Uses bounds from [Nav08]_.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">        sage: from surface_dynamics.flat_surfaces.separatrix_diagram import separatrix_diagram_fast_iterator</span>
<span class="sd">        sage: for s in sorted(separatrix_diagram_fast_iterator([3])): print(s)</span>
<span class="sd">        ([0, 2, 1], [1, 0, 2], [(0, 1, 2)])</span>
<span class="sd">        ([1, 2, 0], [1, 2, 0], [(0, 2, 1)])</span>
<span class="sd">        ([2, 1, 0], [1, 0, 2], [(0, 2, 1)])</span>
<span class="sd">        sage: for s in sorted(separatrix_diagram_fast_iterator([2,2])): print(s)</span>
<span class="sd">        ([0, 1, 3, 2], [1, 0, 2, 3], [(0, 1), (2, 3)])</span>
<span class="sd">        ([0, 2, 3, 1], [1, 2, 0, 3], [(0, 1), (2, 3)])</span>
<span class="sd">        ([1, 2, 3, 0], [1, 2, 3, 0], [(0, 2), (1, 3)])</span>
<span class="sd">        ([1, 3, 2, 0], [1, 2, 0, 3], [(0, 2), (1, 3)])</span>
<span class="sd">        ([2, 3, 0, 1], [1, 0, 3, 2], [(0, 3), (1, 2)])</span>
<span class="sd">        ([3, 1, 0, 2], [1, 2, 0, 3], [(0, 3), (1, 2)])</span>
<span class="sd">        ([3, 2, 1, 0], [1, 0, 3, 2], [(0, 2), (1, 3)])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sage.combinat.partition</span> <span class="kn">import</span> <span class="n">Partition</span><span class="p">,</span><span class="n">Partitions</span>
    <span class="kn">from</span> <span class="nn">sage.groups.perm_gps.symgp_conjugacy_class</span> <span class="kn">import</span> <span class="n">conjugacy_class_iterator</span>

    <span class="n">part</span> <span class="o">=</span> <span class="n">Partition</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">))</span><span class="o">//</span><span class="mi">2</span>  <span class="c1"># the maximum number of cylinders is known</span>
                          <span class="c1"># to be g+s-1 from a theorem of Y. Naveh</span>

    <span class="n">tops</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">if</span> <span class="n">ncyls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ncyls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">ncyls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">ncyls</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ncyls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">ncyls</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ncyls</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> is not possible as number of cylinders&quot;</span><span class="o">%</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># build the list of admissible tops up to conjugacy class</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">tops</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ncyls</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="n">k</span><span class="p">):</span>
                <span class="n">tops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">canonical_perm</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="n">canonical_perm_i</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">conjugacy_class_iterator</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tops</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">top</span><span class="p">,</span><span class="n">top_i</span> <span class="ow">in</span> <span class="n">tops</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="n">bot</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">top_i</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">bot</span><span class="p">[</span><span class="n">cycle</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">top_i</span><span class="p">[</span><span class="n">cycle</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">bot</span><span class="p">[</span><span class="n">cycle</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">top_i</span><span class="p">[</span><span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                <span class="n">seen</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bot</span><span class="p">)</span>
                <span class="n">nb_cycles</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bot</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">seen</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">seen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">nb_cycles</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">nb_cycles</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">bot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">while</span> <span class="n">seen</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="n">seen</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">j</span> <span class="o">=</span> <span class="n">bot</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">nb_cycles</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">,</span><span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="separatrix_diagram_iterator">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.separatrix_diagram_iterator">[docs]</a>
<span class="k">def</span> <span class="nf">separatrix_diagram_iterator</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterator over separatrix diagram with given ``profile`` and number of</span>
<span class="sd">    cylinders.</span>

<span class="sd">    Warning: to prevent isomorphism class to be output twice the function</span>
<span class="sd">    implement a cache mechanism. If you intend to iterate through a huge</span>
<span class="sd">    class of separatrix_diagram and do not care about isomorphism problem use</span>
<span class="sd">    separatrix_diagram_fast_iterator instead.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">        sage: from surface_dynamics.flat_surfaces.separatrix_diagram import separatrix_diagram_iterator</span>

<span class="sd">        sage: for s in sorted(separatrix_diagram_iterator([1,1])): print(s)</span>
<span class="sd">        (0,1)-(0,1)</span>
<span class="sd">        (0)(1)-(0)(1)</span>

<span class="sd">        sage: for s in sorted(separatrix_diagram_iterator([3])): print(s)</span>
<span class="sd">        (0,1,2)-(0,1,2)</span>
<span class="sd">        (0)(1,2)-(0,1)(2)</span>

<span class="sd">        sage: for s in sorted(separatrix_diagram_iterator([2,2])): print(s)</span>
<span class="sd">        (0,1,2,3)-(0,1,2,3)</span>
<span class="sd">        (0)(1,2,3)-(0,1,2)(3)</span>
<span class="sd">        (0,1)(2,3)-(0,2)(1,3)</span>
<span class="sd">        (0)(1)(2,3)-(0,1)(2)(3)</span>

<span class="sd">        sage: sum(1 for s in separatrix_diagram_iterator([3,2,2]))</span>
<span class="sd">        64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">separatrix_diagram_fast_iterator</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span><span class="n">ncyls</span><span class="p">):</span>
        <span class="n">bot</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">bot</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>
        <span class="n">s_perm</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bot</span><span class="o">+</span><span class="n">top</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s_perm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">SeparatrixDiagram</span><span class="p">(</span><span class="n">bot</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_get_sym_perms</span><span class="p">()</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">SeparatrixDiagram</span><span class="p">(</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">syms</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bot</span><span class="o">+</span><span class="n">top</span><span class="p">)</span> <span class="k">for</span> <span class="n">bot</span><span class="p">,</span><span class="n">top</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">s</span></div>


<span class="c1">#</span>
<span class="c1"># Cylinder diagram</span>
<span class="c1">#  (or completely periodic decomposition)</span>
<span class="c1">#</span>

<div class="viewcode-block" id="string_to_cycle">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.string_to_cycle">[docs]</a>
<span class="k">def</span> <span class="nf">string_to_cycle</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TESTS::</span>

<span class="sd">        sage: from surface_dynamics.flat_surfaces.separatrix_diagram import string_to_cycle</span>
<span class="sd">        sage: string_to_cycle(&#39;(3,1,2)&#39;)</span>
<span class="sd">        (3, 1, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong syntax&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A cycle string should start with an opening parenthesis&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A cycle string should end with a closing parenthesis&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">))</span></div>



<div class="viewcode-block" id="orientation_cover">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.orientation_cover">[docs]</a>
<span class="k">def</span> <span class="nf">orientation_cover</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build the cylinder diagram of Abelian differentials that double covers it.</span>

<span class="sd">    A quadratic differrential separatrix diagram is given by three permutations</span>

<span class="sd">    - sigma: the permutation of 1/2-separatrices around vertices</span>
<span class="sd">    - alpha: the permutation of 1/2-separatrices that describe the separatrices</span>
<span class="sd">       (it is a fixed point free involution)</span>
<span class="sd">    - phi: the permutation of 1/2-separatrices that describe the cycles.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``alpha`` -- permutation</span>

<span class="sd">    - ``phi`` -- permutation</span>

<span class="sd">    - ``a`` -- number of half separatrices</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">        sage: from surface_dynamics.flat_surfaces.separatrix_diagram import orientation_cover</span>
<span class="sd">        sage: alpha = [3, 2, 1, 0, 5, 4, 7, 6]</span>
<span class="sd">        sage: phi = [3, 1, 0, 2, 5, 4, 7, 6]</span>
<span class="sd">        sage: orientation_cover(alpha,phi,3)</span>
<span class="sd">        (0,2)-(0,1) (1)-(2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; orientation cover&quot;</span><span class="p">)</span>
    <span class="n">cyls</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="n">a</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">todo</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">todo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  top from </span><span class="si">%d</span><span class="s2">,  bot from </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">todo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">alpha</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">:</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  add </span><span class="si">%d</span><span class="s2"> to bot,  add </span><span class="si">%d</span><span class="s2"> to top&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

                <span class="n">j</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">cyls</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CylinderDiagram</span><span class="p">(</span><span class="n">cyls</span><span class="p">)</span></div>


<span class="c1">#TODO: do something less stupid for symmetries</span>
<div class="viewcode-block" id="hyperelliptic_cylinder_diagram_iterator">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.hyperelliptic_cylinder_diagram_iterator">[docs]</a>
<span class="k">def</span> <span class="nf">hyperelliptic_cylinder_diagram_iterator</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an iterator over cylinder diagrams of Abelian differentials that</span>
<span class="sd">    double covers Q((a-2), -1^(a+2)).</span>

<span class="sd">    The generator is up to isomorphism.</span>

<span class="sd">    TODO:</span>

<span class="sd">    - An optimization could be obtained by considering the generation of</span>
<span class="sd">      k-subsets of {1,...,n} up to the cyclic symmetry of the tree.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``a`` - integer - angle of the conical singularity of the quadratic</span>
<span class="sd">      differential.</span>

<span class="sd">    - ``verbose`` - integer (default: 0) - output various information during the</span>
<span class="sd">      iteration (mainly for debug).</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">        sage: from surface_dynamics.flat_surfaces.separatrix_diagram import hyperelliptic_cylinder_diagram_iterator</span>
<span class="sd">        sage: it = hyperelliptic_cylinder_diagram_iterator(3)</span>
<span class="sd">        sage: c = next(it); c.is_isomorphic(CylinderDiagram(&#39;(0,1)-(0,2) (2)-(1)&#39;))</span>
<span class="sd">        True</span>
<span class="sd">        sage: c.stratum_component()</span>
<span class="sd">        H_2(2)^hyp</span>

<span class="sd">        sage: hyp = AbelianStratum(2,2).hyperelliptic_component()</span>
<span class="sd">        sage: all(c.stratum_component() == hyp for c in hyperelliptic_cylinder_diagram_iterator(6))</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">surface_dynamics.misc.plane_tree</span> <span class="kn">import</span> <span class="n">admissible_plane_tree_iterator</span>
    <span class="kn">from</span> <span class="nn">sage.combinat.gray_codes</span> <span class="kn">import</span> <span class="n">combinations</span>

    <span class="n">cyl_diags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span>

    <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># open loops indicator</span>
                         <span class="c1"># if B[k] is not False, it is where loop k starts</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="n">admissible_plane_tree_iterator</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="c1"># Build the initial tree</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="n">a</span>               <span class="c1"># the number of poles</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>                  <span class="c1"># leaf counter</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>                   <span class="c1"># 1/2-separatrix counter</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">a</span>                  <span class="c1"># pole counter</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># edge permutation</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>    <span class="c1"># face permutation</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;n = </span><span class="si">%d</span><span class="s2">,  l = </span><span class="si">%d</span><span class="s2">,  p = </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;t =&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; k = </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># close current loops</span>
                <span class="k">if</span> <span class="n">B</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; close loop from </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">kk</span><span class="p">],</span> <span class="n">s</span><span class="p">))</span>
                    <span class="n">alpha</span><span class="p">[</span><span class="n">B</span><span class="p">[</span><span class="n">kk</span><span class="p">]]</span> <span class="o">=</span> <span class="n">s</span>
                    <span class="n">alpha</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>
                    <span class="n">phi</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">a</span>
                    <span class="n">phi</span><span class="p">[</span><span class="n">B</span><span class="p">[</span><span class="n">kk</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">a</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; alpha =&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; phi   =&quot;</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ll</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># store the leaf</span>
                <span class="c1"># t[k] is a pole</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; pole at </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
                <span class="n">alpha</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span>
                <span class="n">alpha</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
                <span class="n">phi</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span>
                <span class="n">phi</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">a</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sp</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ll</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">B</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; alpha =&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; phi   =&quot;</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># not at the end -&gt; open a loop</span>
                <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># store the leaf</span>
                    <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; open loop at </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
                <span class="n">B</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">s</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; alpha =&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; phi   =&quot;</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; tree is over&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; alpha =&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; phi =&quot;</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">p</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; paired poles (</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">pp</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">alpha</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">alpha</span><span class="p">[</span><span class="n">pp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">pp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; alpha =&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; phi   =&quot;</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="n">l</span><span class="p">,</span> <span class="s2">&quot;This may not happen&quot;</span>

        <span class="c1"># yield the canonical sepx. diag</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; =&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">7</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; sigma =&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; alpha =&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; phi   =&quot;</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; =&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">7</span><span class="p">))</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">orientation_cover</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cyl_diags</span><span class="p">:</span>
            <span class="n">c_sym</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">horizontal_symmetry</span><span class="p">()</span>
            <span class="n">cc</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">c_sym</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

            <span class="n">cc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">vertical_symmetry</span><span class="p">()</span>
            <span class="n">cc</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">c_sym</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="n">cyl_diags</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c_sym</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">c</span>

        <span class="c1"># Make the poles vary among the leaves</span>
        <span class="c1">#TODO: optimization when tree has nontrivial cyclic symmetry</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; start revolving door(</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; leaves are at separatrices&quot;</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; revolve i=</span><span class="si">%d</span><span class="s2"> j=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">a_i</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">a_j</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">s_i</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">s_a_j</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">a_j</span><span class="p">]</span>
                <span class="n">ss_i</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>  <span class="c1"># sigma^-1(i)</span>
                <span class="n">ss_j</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">alpha</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>  <span class="c1"># sigma^-1(j)</span>
                <span class="n">a_s_i</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span>
                <span class="n">a_s_a_j</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">s_a_j</span><span class="p">]</span>

                <span class="k">assert</span> <span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">a_j</span><span class="p">,</span> <span class="s2">&quot;sigma[</span><span class="si">%d</span><span class="s2">] = </span><span class="si">%d</span><span class="s2"> != alpha[</span><span class="si">%d</span><span class="s2">]&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">a_j</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">a_i</span><span class="p">,</span> <span class="s2">&quot;phi[</span><span class="si">%d</span><span class="s2">] != alpha[i]&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,)</span>
                <span class="k">assert</span> <span class="n">phi</span><span class="p">[</span><span class="n">a_s_i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;phi[</span><span class="si">%d</span><span class="s2">] != </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">a_s_i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="s2">&quot;phi[</span><span class="si">%d</span><span class="s2">] + </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">phi</span><span class="p">[</span><span class="n">a_s_a_j</span><span class="p">]</span> <span class="o">==</span> <span class="n">a_j</span><span class="p">,</span> <span class="s2">&quot;phi[</span><span class="si">%d</span><span class="s2">] != alpha[</span><span class="si">%d</span><span class="s2">]&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">a_s_a_j</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>

                <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>     <span class="o">=</span> <span class="n">a_j</span>
                <span class="n">alpha</span><span class="p">[</span><span class="n">a_j</span><span class="p">]</span>   <span class="o">=</span> <span class="n">i</span>
                <span class="n">alpha</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>     <span class="o">=</span> <span class="n">a_i</span>
                <span class="n">alpha</span><span class="p">[</span><span class="n">a_i</span><span class="p">]</span>   <span class="o">=</span> <span class="n">j</span>

                <span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>     <span class="o">=</span> <span class="n">a_j</span>    <span class="c1"># old_sigma[j]</span>
                <span class="n">sigma</span><span class="p">[</span><span class="n">a_j</span><span class="p">]</span>   <span class="o">=</span> <span class="n">s_i</span>    <span class="c1"># old_sigma[i]</span>
                <span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>     <span class="o">=</span> <span class="n">s_a_j</span>  <span class="c1"># old_sigma[a_j]</span>

                <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>       <span class="o">=</span> <span class="n">i</span>      <span class="c1"># old_phi[a_s_i]</span>
                <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>       <span class="o">=</span> <span class="n">a_i</span>    <span class="c1"># old_phi[i]</span>

                <span class="k">if</span> <span class="n">s_i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span> <span class="c1"># and a_s_i == a_j</span>
                    <span class="n">phi</span><span class="p">[</span><span class="n">a_s_i</span><span class="p">]</span>   <span class="o">=</span> <span class="n">a_j</span>    <span class="c1"># old_phi[a_s_a_j]</span>
                    <span class="n">phi</span><span class="p">[</span><span class="n">a_i</span><span class="p">]</span>     <span class="o">=</span> <span class="n">ss_j</span>   <span class="c1"># old_phi[a_j]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">phi</span><span class="p">[</span><span class="n">a_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_j</span>

                <span class="k">if</span> <span class="n">s_a_j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">phi</span><span class="p">[</span><span class="n">a_j</span><span class="p">]</span>     <span class="o">=</span> <span class="n">ss_i</span>   <span class="c1"># old_phi[a_i]</span>
                    <span class="n">phi</span><span class="p">[</span><span class="n">a_s_a_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>      <span class="c1"># old_phi[j]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">phi</span><span class="p">[</span><span class="n">a_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; =&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">7</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; sigma =&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; alpha =&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; phi   =&quot;</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; =&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">7</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">ii</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">alpha</span><span class="p">[</span><span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                    <span class="k">assert</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;f_a_s(</span><span class="si">%d</span><span class="s2">) == </span><span class="si">%d</span><span class="s2"> != </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">ii</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;sigma[</span><span class="si">%d</span><span class="s2">] = </span><span class="si">%d</span><span class="s2"> != </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">orientation_cover</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cyl_diags</span><span class="p">:</span>
                    <span class="n">c_sym</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
                    <span class="n">cc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">horizontal_symmetry</span><span class="p">()</span>
                    <span class="n">cc</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">c_sym</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

                    <span class="n">cc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">vertical_symmetry</span><span class="p">()</span>
                    <span class="n">cc</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">c_sym</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
                    <span class="n">cyl_diags</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c_sym</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">c</span>

            <span class="c1"># reinitialize sigma</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="CylinderDiagram">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram">[docs]</a>
<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">CylinderDiagram</span><span class="p">(</span><span class="n">SeparatrixDiagram</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Separatrix diagram with pairing.</span>

<span class="sd">    Each cylinder is stored as a couple (bot,top) for which the orientation is</span>
<span class="sd">    as follows::</span>

<span class="sd">        +--------------------+</span>
<span class="sd">        |     &lt;-- top --     |</span>
<span class="sd">        |                    |</span>
<span class="sd">        |                    |</span>
<span class="sd">        |      -- bot --&gt;    |</span>
<span class="sd">        +--------------------+</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``data`` - list of 2-tuples - matching of bottom-top pairs</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>


<span class="sd">    We first build the simplest cylinder diagram which corresponds to a torus::</span>

<span class="sd">        sage: CylinderDiagram([((0,),(0,))])</span>
<span class="sd">        (0)-(0)</span>

<span class="sd">    The same initialized from a string::</span>

<span class="sd">        sage: CylinderDiagram(&#39;(0)-(0)&#39;)</span>
<span class="sd">        (0)-(0)</span>

<span class="sd">    The following initialize a cylinder diagram with two cylinder which gives a</span>
<span class="sd">    surface of genus 2 with one singularity of degree 2::</span>

<span class="sd">        sage: CylinderDiagram([((0,1),(0,2)),((2,),(1,))])</span>
<span class="sd">        (0,1)-(0,2) (2)-(1)</span>

<span class="sd">    ALGORITHM:</span>

<span class="sd">    A cylinder is represented by a couple (i,j) where i is the min in bot and j</span>
<span class="sd">    is the min in top. The data _top_to_cyl and _bot_to_cyl corresponds to the</span>
<span class="sd">    association of a separatrix to the corresponding 2-tuple. The twist</span>
<span class="sd">    coordinate correspond to the shift between those two indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram([((0,),(0,))])</span>
<span class="sd">            sage: CylinderDiagram(str(c)) == c</span>
<span class="sd">            True</span>
<span class="sd">            sage: loads(dumps(c)) == c</span>
<span class="sd">            True</span>

<span class="sd">            sage: CylinderDiagram(&#39;(0,1)-(2,1) (2)-(3)&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: each separatrix must appear once on bot and once on top</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">top</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">string_to_cycle</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="n">string_to_cycle</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">bot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
            <span class="n">top</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

        <span class="n">SeparatrixDiagram</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bot</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">top</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span> <span class="ow">or</span>\
           <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;each separatrix must appear once on bot and once on top&#39;</span><span class="p">)</span>

        <span class="n">b2c</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span> <span class="c1"># bot separatrix -&gt; cylinder (bot_min_index, top_min_index)</span>
        <span class="n">t2c</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span> <span class="c1"># top separatrix -&gt; cylinder (bot_min_index, top_min_index)</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">cyl</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span> <span class="n">b2c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cyl</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span> <span class="n">t2c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cyl</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span> <span class="o">=</span> <span class="n">b2c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cyl</span> <span class="o">=</span> <span class="n">t2c</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hash value: This is bad since we can modify it inplace!!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cyl</span> <span class="o">+</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">_bot_cycles</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_cycles</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">SeparatrixDiagram</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>
        <span class="n">b2c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span>
        <span class="n">t2c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cyl</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()):</span>
            <span class="n">bo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_orbit</span><span class="p">(</span><span class="n">b2c</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bo</span> <span class="ow">or</span> <span class="n">b2c</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bo</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid data: j=</span><span class="si">{}</span><span class="s2"> bo=</span><span class="si">{}</span><span class="s2"> b2c[j]=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">bo</span><span class="p">,</span> <span class="n">b2c</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_orbit</span><span class="p">(</span><span class="n">t2c</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to</span> <span class="ow">or</span> <span class="n">t2c</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">min</span><span class="p">(</span><span class="n">to</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid data: j=</span><span class="si">{}</span><span class="s2"> to=</span><span class="si">{}</span><span class="s2"> t2c[j]=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">t2c</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

<div class="viewcode-block" id="CylinderDiagram.weighted_adjacency_matrix">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.weighted_adjacency_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">weighted_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the weighted adjacency matrix of this cylinder diagram.</span>

<span class="sd">        There is a vertex per cylinder and the weight from cyl1 to cyl2</span>
<span class="sd">        is the number of saddle connections which are on top of cyl1 and</span>
<span class="sd">        in the bottom of cyl2.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import AbelianStratum</span>
<span class="sd">            sage: for cd in AbelianStratum(1,1).cylinder_diagrams():</span>
<span class="sd">            ....:     print(cd.weighted_adjacency_matrix())</span>
<span class="sd">            [4]</span>
<span class="sd">            [0 1]</span>
<span class="sd">            [1 2]</span>
<span class="sd">            [1 1]</span>
<span class="sd">            [1 1]</span>
<span class="sd">            [0 0 1]</span>
<span class="sd">            [0 0 1]</span>
<span class="sd">            [1 1 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.rings.all</span> <span class="kn">import</span> <span class="n">ZZ</span>
        <span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">matrix</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">())</span>
        <span class="n">cylinder_indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cylinder_indices</span><span class="p">:</span>
                <span class="n">cylinder_indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cylinder_indices</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()):</span>
            <span class="n">bot</span> <span class="o">=</span> <span class="n">cylinder_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">cylinder_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cyl</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">A</span><span class="p">[</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">canonicalize</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sage.graphs.digraph</span> <span class="kn">import</span> <span class="n">DiGraph</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;weighted_adjacency_matrix&#39;</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">weighted_adjacency_matrix</span><span class="p">()</span>

        <span class="n">A</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="CylinderDiagram.lengths_minimal_solution">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.lengths_minimal_solution">[docs]</a>
    <span class="k">def</span> <span class="nf">lengths_minimal_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an integral solution for the lengths equation with minimal sum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.numerical.mip</span> <span class="kn">import</span> <span class="n">MixedIntegerLinearProgram</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">MixedIntegerLinearProgram</span><span class="p">(</span><span class="n">maximization</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">new_variable</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()):</span>
            <span class="n">M</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bot</span><span class="p">,</span><span class="n">top</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
            <span class="n">M</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">)</span> <span class="o">==</span> <span class="n">M</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">top</span><span class="p">))</span>
        <span class="n">M</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())]</span></div>



<div class="viewcode-block" id="CylinderDiagram.tikz_string">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.tikz_string">[docs]</a>
    <span class="k">def</span> <span class="nf">tikz_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cyl_height</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">cyl_sep</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span> <span class="n">cyl_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT:</span>

<span class="sd">        - ``cyl_height`` - (optional) height of cylinders</span>

<span class="sd">        - ``cyl_sep`` - (optional) vertical space between cylinders</span>

<span class="sd">        - ``cyl_pos`` - (optional) position of left corners of cylinders. If provided, ``cyl_sep``</span>
<span class="sd">          is ignored.</span>

<span class="sd">        - ``sep_labels`` - labels of the separatrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cyl_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cyl_pos</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">cyl_height</span><span class="o">+</span><span class="n">cyl_sep</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())]</span>
        <span class="k">if</span> <span class="n">sep_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sep_labels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())</span>

        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lengths_minimal_solution</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">w</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">top</span><span class="p">)</span>

            <span class="n">xl</span><span class="p">,</span> <span class="n">yl</span> <span class="o">=</span> <span class="n">cyl_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># fill the cylinder</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">fill[gray!20] (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) rectangle (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">);&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">xl</span><span class="p">,</span><span class="n">yl</span><span class="p">,</span><span class="n">xl</span><span class="o">+</span><span class="n">w</span><span class="p">,</span><span class="n">yl</span><span class="o">+</span><span class="n">cyl_height</span><span class="p">))</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">draw (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) rectangle (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">);&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">xl</span><span class="p">,</span><span class="n">yl</span><span class="p">,</span><span class="n">xl</span><span class="o">+</span><span class="n">w</span><span class="p">,</span><span class="n">yl</span><span class="o">+</span><span class="n">cyl_height</span><span class="p">))</span>

            <span class="c1"># singularities</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">xl</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">fill (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) circle (2pt);&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yl</span><span class="p">))</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">node[below=-2] at (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) {{</span><span class="si">{}</span><span class="s1">}};&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">sep_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">x</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">fill (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) circle (2pt);&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yl</span><span class="p">))</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">xl</span><span class="o">+</span><span class="n">w</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">fill (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) circle (2pt);&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yl</span><span class="o">+</span><span class="n">cyl_height</span><span class="p">))</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">node[above=-2] at (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) {{</span><span class="si">{}</span><span class="s1">}};&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">yl</span><span class="o">+</span><span class="n">cyl_height</span><span class="p">,</span> <span class="n">sep_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">x</span> <span class="o">-=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">fill (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) circle (2pt);&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yl</span><span class="o">+</span><span class="n">cyl_height</span><span class="p">))</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram([((0,1),(1,2)),((2,),(0,))])</span>
<span class="sd">            sage: repr(c) #indirect doctest</span>
<span class="sd">            &#39;(0,1)-(1,2) (2)-(0)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">b</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;)-(&#39;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">t</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import AbelianStratum, CylinderDiagram</span>

<span class="sd">            sage: c1 = CylinderDiagram(&#39;(0,5)-(0,4) (1,4)-(1,3) (2,3)-(2,5)&#39;)</span>
<span class="sd">            sage: c2 = CylinderDiagram(&#39;(0,5)-(1,3) (1,4)-(0,4) (2,3)-(2,5)&#39;)</span>
<span class="sd">            sage: c3 = CylinderDiagram(&#39;(0,5)-(2,5) (1,4)-(1,3) (2,3)-(0,4)&#39;)</span>
<span class="sd">            sage: c1 == c2 or c2 == c3 or c1 == c3</span>
<span class="sd">            False</span>
<span class="sd">            sage: c1 != c2 and c2 != c3 and c1 != c3</span>
<span class="sd">            True</span>

<span class="sd">            sage: from operator import not_</span>
<span class="sd">            sage: C = AbelianStratum(4).cylinder_diagrams()</span>
<span class="sd">            sage: for c1 in C:</span>
<span class="sd">            ....:     assert c1 == c1</span>
<span class="sd">            ....:     assert not_(c1 != c1)</span>
<span class="sd">            ....:     for c2 in C:</span>
<span class="sd">            ....:         assert (c1 == c2) == (c2 == c1) == not_(c2 != c1) == not_(c1 != c2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="n">SeparatrixDiagram</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_bot_to_cyl</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Comparison</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import AbelianStratum</span>
<span class="sd">            sage: from operator import not_</span>
<span class="sd">            sage: C = AbelianStratum(4).cylinder_diagrams()</span>
<span class="sd">            sage: for c1 in C:</span>
<span class="sd">            ....:     for c2 in C:</span>
<span class="sd">            ....:         assert (c1 &lt; c2) == (c2 &gt; c1) == not_(c1 &gt;= c2) == not_(c2 &lt;= c1)</span>
<span class="sd">            ....:         assert (c1 &lt;= c2) == (c2 &gt;= c1) == not_(c1 &gt; c2) == not_(c2 &lt; c1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>

        <span class="k">if</span> <span class="n">SeparatrixDiagram</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">SeparatrixDiagram</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_bot_to_cyl</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_bot_to_cyl</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cyl</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_top_to_cyl</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cyl</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_top_to_cyl</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># equality</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1">#</span>
    <span class="c1"># access to attribute</span>
    <span class="c1">#</span>


<div class="viewcode-block" id="CylinderDiagram.to_directed_graph">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.to_directed_graph">[docs]</a>
    <span class="k">def</span> <span class="nf">to_directed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a labeled directed graph that encodes the cylinder diagram.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,5)-(2,5) (2)-(0,1,3) (3,4)-(4)&#39;); c</span>
<span class="sd">            (0,1,5)-(2,5) (2)-(0,1,3) (3,4)-(4)</span>
<span class="sd">            sage: G = c.to_directed_graph(); G</span>
<span class="sd">            Looped multi-digraph on 6 vertices</span>
<span class="sd">            sage: G.edges(sort=True)</span>
<span class="sd">            [(0, 1, &#39;b&#39;), (0, 1, &#39;t&#39;), (0, 2, &#39;c&#39;), (0, 5, &#39;c&#39;), (1, 2, &#39;c&#39;), (1, 3, &#39;t&#39;), (1, 5, &#39;b&#39;), (1, 5, &#39;c&#39;), (2, 0, &#39;c&#39;), (2, 1, &#39;c&#39;), (2, 2, &#39;b&#39;), (2, 3, &#39;c&#39;), (2, 5, &#39;t&#39;), (3, 0, &#39;t&#39;), (3, 4, &#39;b&#39;), (3, 4, &#39;c&#39;), (4, 3, &#39;b&#39;), (4, 4, &#39;c&#39;), (4, 4, &#39;t&#39;), (5, 0, &#39;b&#39;), (5, 2, &#39;c&#39;), (5, 2, &#39;t&#39;), (5, 5, &#39;c&#39;)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">SeparatrixDiagram</span><span class="o">.</span><span class="n">to_directed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cb</span><span class="p">,</span><span class="n">ct</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cb</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ct</span><span class="p">:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="CylinderDiagram.is_isomorphic">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.is_isomorphic">[docs]</a>
    <span class="k">def</span> <span class="nf">is_isomorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">return_map</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether this cylinder diagram is isomorphic to ``other``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c1 = CylinderDiagram(&#39;(0,2,1)-(3,4,5) (3)-(1) (4)-(2) (5)-(0)&#39;)</span>
<span class="sd">            sage: c2 = CylinderDiagram(&#39;(0,2,1)-(3,5,4) (3)-(1) (4)-(2) (5)-(0)&#39;)</span>
<span class="sd">            sage: c1.is_isomorphic(c2)</span>
<span class="sd">            False</span>

<span class="sd">            sage: c3 = CylinderDiagram(&#39;(1,3,5)-(2,4,0) (2)-(5) (4)-(3) (0)-(1)&#39;)</span>
<span class="sd">            sage: c1.is_isomorphic(c3)</span>
<span class="sd">            True</span>
<span class="sd">            sage: ans, m = c1.is_isomorphic(c3, return_map=True)</span>
<span class="sd">            sage: assert ans is True and c1.relabel(m) == c3</span>

<span class="sd">            sage: c4 = CylinderDiagram(&#39;(4,2,3)-(1,5,0) (1)-(3) (0)-(2) (5)-(4)&#39;)</span>
<span class="sd">            sage: c2.is_isomorphic(c4)</span>
<span class="sd">            True</span>
<span class="sd">            sage: ans, m = c2.is_isomorphic(c4, return_map=True)</span>
<span class="sd">            sage: assert ans is True and c2.relabel(m) == c4</span>

<span class="sd">            sage: c1 = CylinderDiagram(&#39;(0,5)-(3,4) (1,4)-(2,5) (2)-(0) (3)-(1)&#39;)</span>
<span class="sd">            sage: c2 = CylinderDiagram(&#39;(0,5)-(3,4) (1,4)-(2,5) (2)-(1) (3)-(0)&#39;)</span>
<span class="sd">            sage: c1.is_isomorphic(c2)</span>
<span class="sd">            False</span>

<span class="sd">            sage: c1 = CylinderDiagram(&#39;(0,1)-(4,5) (2,4)-(0,3) (3,5)-(1,2)&#39;)</span>
<span class="sd">            sage: c2 = CylinderDiagram(&#39;(0,1)-(2,3) (2,4)-(1,4) (3,5)-(0,5)&#39;)</span>
<span class="sd">            sage: c3 = CylinderDiagram(&#39;(0,5)-(2,5) (1,4)-(0,4) (2,3)-(1,3)&#39;)</span>
<span class="sd">            sage: c1.is_isomorphic(c2)</span>
<span class="sd">            False</span>
<span class="sd">            sage: c1.is_isomorphic(c3)</span>
<span class="sd">            False</span>
<span class="sd">            sage: c2.is_isomorphic(c3)</span>
<span class="sd">            False</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import CylinderDiagram</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,3)-(3,7) (1,6,4)-(0,2,4,6,8) (2,8,7,5)-(1,5)&#39;)</span>
<span class="sd">            sage: c1 = c.relabel([4,7,0,3,2,1,6,8,5])</span>
<span class="sd">            sage: c2 = c.relabel([6,3,1,8,2,0,4,5,7])</span>
<span class="sd">            sage: assert c.is_isomorphic(c1) and c.is_isomorphic(c2) and c1.is_isomorphic(c2)</span>
<span class="sd">            sage: _, m1 = c1.is_isomorphic(c, return_map=True)</span>
<span class="sd">            sage: assert c1.relabel(m1) == c</span>
<span class="sd">            sage: _, m2 = c2.is_isomorphic(c, return_map=True)</span>
<span class="sd">            sage: assert c2.relabel(m2) == c</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">if</span> <span class="n">return_map</span><span class="p">:</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">sm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">return_map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">o</span><span class="p">,</span> <span class="n">om</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">return_map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">o</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ominv</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">om</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">ominv</span><span class="p">[</span><span class="n">sm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">()</span></div>


<div class="viewcode-block" id="CylinderDiagram.relabel">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.relabel">[docs]</a>
    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import CylinderDiagram</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,3)-(3,7) (1,6,4)-(0,2,4,6,8) (2,8,7,5)-(1,5)&#39;)</span>
<span class="sd">            sage: c.relabel([3,1,2,6,4,5,0,7,8])</span>
<span class="sd">            (0,4,1)-(0,8,3,2,4) (2,8,7,5)-(1,5) (3,6)-(6,7)</span>
<span class="sd">            sage: c</span>
<span class="sd">            (0,3)-(3,7) (1,6,4)-(0,2,4,6,8) (2,8,7,5)-(1,5)</span>
<span class="sd">            sage: c.relabel([3,1,2,6,4,5,0,7,8], inplace=True)</span>
<span class="sd">            (0,4,1)-(0,8,3,2,4) (2,8,7,5)-(1,5) (3,6)-(6,7)</span>
<span class="sd">            sage: c</span>
<span class="sd">            (0,4,1)-(0,8,3,2,4) (2,8,7,5)-(1,5) (3,6)-(6,7)</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,3)-(3,7) (1,6,4)-(0,2,4,6,8) (2,8,7,5)-(1,5)&#39;)</span>
<span class="sd">            sage: c1 = c.relabel([3,1,2,6,4,5,0,7,8], inplace=False)</span>
<span class="sd">            sage: c2 = c.relabel([3,1,2,6,4,5,0,7,8], inplace=True)</span>
<span class="sd">            sage: assert c is c2 and c1 == c2</span>
<span class="sd">            sage: c1._check()</span>
<span class="sd">            sage: c2._check()</span>

<span class="sd">            sage: c1 = c.relabel([1,5,0,6,8,3,2,7,4], inplace=False)</span>
<span class="sd">            sage: c2 = c.relabel([1,5,0,6,8,3,2,7,4], inplace=True)</span>
<span class="sd">            sage: assert c is c2 and c1 == c2</span>
<span class="sd">            sage: c1._check()</span>
<span class="sd">            sage: c2._check()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>

            <span class="c1"># find new (bot min, top min) in each cylinder</span>
            <span class="n">new_mins</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
                <span class="n">bb</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">]</span>

                <span class="n">new_mins</span><span class="p">[(</span><span class="nb">min</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">bb</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">tt</span><span class="p">))</span>

            <span class="n">b2c</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
            <span class="n">t2c</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">b2c</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_mins</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">t2c</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_mins</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cyl</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span> <span class="o">=</span> <span class="n">b2c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cyl</span> <span class="o">=</span> <span class="n">t2c</span>

            <span class="n">SeparatrixDiagram</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CylinderDiagram</span><span class="p">([(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">))</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()])</span></div>


<div class="viewcode-block" id="CylinderDiagram.canonical_label">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.canonical_label">[docs]</a>
    <span class="k">def</span> <span class="nf">canonical_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_map</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a cylinder diagram with canonical labels.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            The canonical label might change depending on your Sage version and the</span>
<span class="sd">            optional packages available.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import CylinderDiagram</span>
<span class="sd">            sage: c1 = CylinderDiagram(&#39;(0,5,4)-(0,3,2,1) (1,3,2)-(4,5)&#39;)</span>
<span class="sd">            sage: c1.canonical_label()   # random</span>
<span class="sd">            (0,4,5)-(1,3,2,5) (1,3,2)-(0,4)</span>
<span class="sd">            sage: c2 = c1.relabel([2,4,5,1,3,0])</span>
<span class="sd">            sage: c3 = c1.relabel([5,3,0,1,4,2])</span>
<span class="sd">            sage: c1.canonical_label() == c2.canonical_label() == c3.canonical_label()</span>
<span class="sd">            True</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: import itertools</span>
<span class="sd">            sage: from surface_dynamics import CylinderDiagram</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0)-(1) (1,2)-(0,3) (3)-(2)&#39;)</span>
<span class="sd">            sage: can = c.canonical_label()</span>
<span class="sd">            sage: for p in itertools.permutations([0,1,2,3]):</span>
<span class="sd">            ....:    cc = c.relabel(p)</span>
<span class="sd">            ....:    ccan, m = cc.canonical_label(return_map=True)</span>
<span class="sd">            ....:    assert cc.relabel(m) == can == ccan</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,4)-(0,3) (1,3)-(1,5) (2,5)-(2,4)&#39;)</span>
<span class="sd">            sage: can = c.canonical_label()</span>
<span class="sd">            sage: for p in itertools.permutations([0,1,2,3,4,5]):</span>
<span class="sd">            ....:    cc = c.relabel(p)</span>
<span class="sd">            ....:    ccan, m = cc.canonical_label(return_map=True)</span>
<span class="sd">            ....:    assert cc.relabel(m) == can == ccan</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(0,2) (3,5,4)-(1,4,6) (2,6)-(3,5)&#39;)</span>
<span class="sd">            sage: c is c.canonical_label()</span>
<span class="sd">            False</span>
<span class="sd">            sage: c.canonical_label() is c.canonical_label()</span>
<span class="sd">            True</span>
<span class="sd">            sage: c.canonical_label().canonical_label() is c.canonical_label()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_normal_form&#39;</span><span class="p">):</span>
            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_directed_graph</span><span class="p">()</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">certificate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># m = [m[i] for i in range(self.nseps())]</span>
            <span class="c1"># GG the new digraph</span>
            <span class="c1"># m from the digraph to its canonic labels</span>
            <span class="n">cyls</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
                <span class="n">cyls</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">)))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span> <span class="o">=</span> <span class="n">CylinderDiagram</span><span class="p">(</span><span class="n">cyls</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normal_labels</span> <span class="o">=</span> <span class="n">m</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span><span class="o">.</span><span class="n">_normal_form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span><span class="o">.</span><span class="n">_normal_labels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span><span class="o">.</span><span class="vm">__dict__</span>

        <span class="k">if</span> <span class="n">return_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_labels</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_form</span></div>


<div class="viewcode-block" id="CylinderDiagram.separatrix_diagram">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.separatrix_diagram">[docs]</a>
    <span class="k">def</span> <span class="nf">separatrix_diagram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the underlying separatrix diagram</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = SeparatrixDiagram(&#39;(0,1)(2,3,4)&#39;,&#39;(0,3)(1,4,2)&#39;); s</span>
<span class="sd">            (0,1)(2,3,4)-(0,3)(1,4,2)</span>
<span class="sd">            sage: c = s.to_cylinder_diagram([(0,1),(1,0)]); c</span>
<span class="sd">            (0,1)-(1,4,2) (2,3,4)-(0,3)</span>
<span class="sd">            sage: c.separatrix_diagram() == s</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SeparatrixDiagram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="CylinderDiagram.lengths_cone">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.lengths_cone">[docs]</a>
    <span class="k">def</span> <span class="nf">lengths_cone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the rational polyhedron corresponding to the set of length with</span>
<span class="sd">        the given fixed heights.</span>

<span class="sd">        -&gt; one can obtain ehrhart series for each of them! It tells us that we</span>
<span class="sd">        have a nice asymptotics... and the asymptotics is simply given by the</span>
<span class="sd">        volume of this polytope (up to the ignored twists parameters)!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.geometry.polyhedron.constructor</span> <span class="kn">import</span> <span class="n">Polyhedron</span>
        <span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="n">eqns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ieqs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># lengths are non-negative</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span><span class="p">()]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
            <span class="n">ieqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">[:])</span>
            <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="c1"># for each cylinder, length top = length bot</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span><span class="p">()]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">:</span>
                <span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
                <span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
            <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Polyhedron</span><span class="p">(</span><span class="n">ieqs</span><span class="o">=</span><span class="n">ieqs</span><span class="p">,</span> <span class="n">eqns</span><span class="o">=</span><span class="n">eqns</span><span class="p">)</span></div>


<div class="viewcode-block" id="CylinderDiagram.widths_generating_series">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.widths_generating_series">[docs]</a>
    <span class="k">def</span> <span class="nf">widths_generating_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generating series of the number of lengths solutions given the widths.</span>

<span class="sd">        WARNING: when a triangulation is involved, the generating series ignore</span>
<span class="sd">        some lower dimensional polytopes!!</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``var`` - (optional) an optional name for the variable</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import CylinderDiagram</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(0,2) (2)-(1)&#39;)</span>
<span class="sd">            sage: c.widths_generating_series()  # optional: latte_int</span>
<span class="sd">            (1)/((1 - w0)*(1 - w0*w1))</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0)-(2) (1,2,3)-(4,5) (4)-(3) (5)-(0,1)&#39;)</span>
<span class="sd">            sage: c.widths_generating_series()  # optional: latte_int</span>
<span class="sd">            (1)/((1 - w1*w3)*(1 - w1*w2)*(1 - w0*w1*w3))</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,3)-(0,2,5) (2,4)-(1,3) (5)-(4)&#39;)</span>
<span class="sd">            sage: c.widths_generating_series()  # optional: latte_int</span>
<span class="sd">            (1)/((1 - w0)*(1 - w0*w1)*(1 - w0*w1*w2)^2) + (1)/((1 - w0)*(1 - w0*w1)^2*(1 - w0*w1*w2))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">matrix</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.misc.multiplicative_multivariate_generating_series</span> <span class="kn">import</span> <span class="n">MultiplicativeMultivariateGeneratingSeriesRing</span>
        <span class="kn">from</span> <span class="nn">sage.geometry.polyhedron.constructor</span> <span class="kn">import</span> <span class="n">Polyhedron</span>

        <span class="kn">from</span> <span class="nn">sage.misc.misc_c</span> <span class="kn">import</span> <span class="n">prod</span>

        <span class="kn">import</span> <span class="nn">re</span>
        <span class="n">re_var</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;w(</span><span class="se">\\</span><span class="s1">d+)&#39;</span><span class="p">)</span>

        <span class="n">sub1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="n">sub2</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">top</span><span class="p">,</span><span class="n">bot</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
                <span class="n">sub1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">:</span>
                <span class="n">sub2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">M</span> <span class="o">=</span> <span class="n">MultiplicativeMultivariateGeneratingSeriesRing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">(),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">free_module</span><span class="p">()</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">rays</span> <span class="ow">in</span> <span class="n">cone_triangulate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lengths_cone</span><span class="p">()):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rays</span><span class="p">)</span> <span class="o">==</span> <span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">simplex_count</span><span class="p">(</span><span class="n">rays</span><span class="p">)</span>

            <span class="n">den1</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">den2</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rays</span><span class="p">:</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                    <span class="n">l1</span><span class="p">[</span><span class="n">sub1</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">c</span>
                    <span class="n">l2</span><span class="p">[</span><span class="n">sub2</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">c</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">V</span><span class="p">(</span><span class="n">l1</span><span class="p">);</span> <span class="n">v1</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">V</span><span class="p">(</span><span class="n">l2</span><span class="p">);</span> <span class="n">v2</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">den1</span><span class="p">:</span>
                    <span class="n">den1</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">den1</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">den2</span><span class="p">:</span>
                    <span class="n">den2</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">den2</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">f1</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">term</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">den1</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">term</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">den2</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

            <span class="k">assert</span> <span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span><span class="p">,</span> <span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">degrees</span><span class="p">())</span>
            <span class="k">assert</span> <span class="n">degrees</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="n">dim</span><span class="p">]),</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>


            <span class="n">ans</span> <span class="o">+=</span> <span class="n">f1</span>

        <span class="k">return</span> <span class="n">ans</span></div>


<div class="viewcode-block" id="CylinderDiagram.volume_contribution">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.volume_contribution">[docs]</a>
    <span class="k">def</span> <span class="nf">volume_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the volume contribution of this cylinder diagram as a</span>
<span class="sd">        generalized multiple zeta values.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c0, c1 = AbelianStratum(2).cylinder_diagrams()</span>
<span class="sd">            sage: v0 = c0.volume_contribution()  # optional: latte_int</span>
<span class="sd">            sage: v0                             # optional: latte_int</span>
<span class="sd">            (1/3)/((w)^4)</span>
<span class="sd">            sage: v0.integral_sum_as_mzv()       # optional: latte_int</span>
<span class="sd">            1/3*ζ(4)</span>
<span class="sd">            sage: v1 = c1.volume_contribution()  # optional: latte_int</span>
<span class="sd">            sage: v1                             # optional: latte_int</span>
<span class="sd">            (2/3)/((w1)*(w0 + w1)^3) + (1/3)/((w1)^2*(w0 + w1)^2)</span>
<span class="sd">            sage: v1.integral_sum_as_mzv()       # optional: latte_int</span>
<span class="sd">            2/3*ζ(1,3) + 1/3*ζ(2,2)</span>

<span class="sd">            sage: for c in AbelianStratum(1,1).cylinder_diagrams():  # optional: latte_int</span>
<span class="sd">            ....:     print(c, c.volume_contribution().integral_sum_as_mzv())</span>
<span class="sd">            (0,3,1,2)-(0,3,1,2) 1/6*ζ(5)</span>
<span class="sd">            (0)-(1) (1,2,3)-(0,2,3) 1/3*ζ(2,3) + 1/3*ζ(3,2)</span>
<span class="sd">            (0,3)-(1,3) (1,2)-(0,2) ζ(1,4) + 1/3*ζ(2,3)</span>
<span class="sd">            (0,1)-(2,3) (2)-(1) (3)-(0) 1/3*ζ(1,3) + 1/3*ζ(2,2) - 1/3*ζ(2,3) - 1/3*ζ(3,2) + 1/3*ζ(4) - 1/3*ζ(5)</span>

<span class="sd">            sage: sum(c.volume_contribution() for c in AbelianStratum(2,1,1).cylinder_diagrams(1)).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            7/180*ζ(8)</span>

<span class="sd">        Detailed contribution of 2 cylinder diagrams::</span>

<span class="sd">            sage: cyls = AbelianStratum(2,1,1).cylinder_diagrams(2)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [2,7,8,21,22]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            13/630*ζ(5,3) + 13/252*ζ(6,2)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [0,11,19,20]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            1/21*ζ(4,4) + 4/63*ζ(5,3)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [3,10]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            2/35*ζ(3,5) + 3/70*ζ(4,4)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [13,23,24]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            2/21*ζ(2,6) + 4/105*ζ(3,5)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [9]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            1/21*ζ(1,7) + 1/126*ζ(2,6)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [5]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            2/105*ζ(3,5) + 1/70*ζ(4,4)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [6,26]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            1/7*ζ(1,7) + 1/14*ζ(2,6) + 1/21*ζ(3,5) + 1/28*ζ(4,4) + 2/105*ζ(5,3)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [1,14]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            2/7*ζ(1,7) + 1/7*ζ(2,6) + 2/21*ζ(3,5) + 3/70*ζ(4,4)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [17,27]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            2/7*ζ(1,7) + 1/7*ζ(2,6) + 4/105*ζ(3,5)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [4,25]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            1/7*ζ(1,7) + 1/42*ζ(2,6)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [12,28]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            4/21*ζ(1,7) + 2/21*ζ(2,6) + 8/315*ζ(3,5)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [15,16]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            4/21*ζ(1,7) + 2/21*ζ(2,6) + 8/315*ζ(3,5)</span>
<span class="sd">            sage: sum(cyls[k].volume_contribution() for k in [18]).integral_sum_as_mzv()  # optional: latte_int</span>
<span class="sd">            1/36*ζ(7) - 1/36*ζ(8)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.misc.additive_multivariate_generating_series</span> <span class="kn">import</span> <span class="n">AdditiveMultivariateGeneratingSeriesRing</span>

        <span class="kn">from</span> <span class="nn">sage.misc.misc_c</span> <span class="kn">import</span> <span class="n">prod</span>
        <span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>


        <span class="c1"># automorphism group</span>
        <span class="n">aut_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">()</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>

        <span class="c1"># equivalent sep diag in the component</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span><span class="p">()))</span>

        <span class="c1"># numbering zeros</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm_cycles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outgoing_edges_perm</span><span class="p">(),</span> <span class="n">singletons</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mult</span><span class="p">:</span>
                <span class="n">mult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">numbering</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">factorial</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mult</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths_generating_series</span><span class="p">()</span>
        <span class="n">deg</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">delta</span><span class="p">()</span><span class="o">.</span><span class="n">residue</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">deg</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">deg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">(),</span> <span class="n">F</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">residue_ring</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">term</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span><span class="p">,</span><span class="n">den</span> <span class="ow">in</span> <span class="n">res</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numbering</span> <span class="o">*</span> <span class="n">sym</span> <span class="o">/</span> <span class="n">ZZ</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())</span><span class="o">.</span><span class="n">factorial</span><span class="p">()</span> <span class="o">/</span> <span class="n">aut_size</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="n">res</span></div>


<div class="viewcode-block" id="CylinderDiagram.cylinders">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.cylinders">[docs]</a>
    <span class="k">def</span> <span class="nf">cylinders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cylinders as a list of pairs ``(bot, top)``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,2,4)-(1,3,5) (1,5)-(0) (3)-(2,4)&#39;)</span>
<span class="sd">            sage: c</span>
<span class="sd">            (0,2,4)-(1,3,5) (1,5)-(0) (3)-(2,4)</span>
<span class="sd">            sage: c.cylinders()</span>
<span class="sd">            [((0, 2, 4), (1, 3, 5)), ((1, 5), (0,)), ((3,), (2, 4))]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">b</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">top_orbit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_cycle_tuples</span><span class="p">()]</span></div>


<div class="viewcode-block" id="CylinderDiagram.bot_to_cyl">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.bot_to_cyl">[docs]</a>
    <span class="k">def</span> <span class="nf">bot_to_cyl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cylinder above the ``j``-th separatrix.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,2,4)-(1,3,5) (1,5)-(0) (3)-(2,4)&#39;)</span>
<span class="sd">            sage: c</span>
<span class="sd">            (0,2,4)-(1,3,5) (1,5)-(0) (3)-(2,4)</span>
<span class="sd">            sage: c.bot_to_cyl(0)</span>
<span class="sd">            ((0, 2, 4), (1, 3, 5))</span>
<span class="sd">            sage: c.bot_to_cyl(1)</span>
<span class="sd">            ((1, 5), (0,))</span>
<span class="sd">            sage: c.bot_to_cyl(3)</span>
<span class="sd">            ((3,), (2, 4))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jb</span><span class="p">,</span><span class="n">jt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_orbit</span><span class="p">(</span><span class="n">jb</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_orbit</span><span class="p">(</span><span class="n">jt</span><span class="p">)</span></div>


<div class="viewcode-block" id="CylinderDiagram.top_to_cyl">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.top_to_cyl">[docs]</a>
    <span class="k">def</span> <span class="nf">top_to_cyl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cylinder below the ``j``-th separatrix.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,2,4)-(1,3,5) (1,5)-(0) (3)-(2,4)&#39;)</span>
<span class="sd">            sage: c.top_to_cyl(0)</span>
<span class="sd">            ((1, 5), (0,))</span>
<span class="sd">            sage: c.top_to_cyl(2)</span>
<span class="sd">            ((3,), (2, 4))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jb</span><span class="p">,</span><span class="n">jt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cyl</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_orbit</span><span class="p">(</span><span class="n">jb</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_orbit</span><span class="p">(</span><span class="n">jt</span><span class="p">)</span></div>


    <span class="c1">#</span>
    <span class="c1"># properties</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="CylinderDiagram.is_connected">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.is_connected">[docs]</a>
    <span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test the connectedness of this cylinder diagram.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: CylinderDiagram(&#39;(0)-(1) (1)-(0)&#39;).is_connected()</span>
<span class="sd">            True</span>
<span class="sd">            sage: CylinderDiagram(&#39;(0,1)-(0) (2)-(1,2)&#39;).is_connected()</span>
<span class="sd">            True</span>

<span class="sd">            sage: CylinderDiagram(&#39;(0)-(0) (1)-(1)&#39;).is_connected()</span>
<span class="sd">            False</span>
<span class="sd">            sage: CylinderDiagram(&#39;(0,1)-(3) (2)-(2) (3)-(0,1)&#39;).is_connected()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.graphs.graph</span> <span class="kn">import</span> <span class="n">Graph</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">num_verts</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span> <span class="ow">and</span> <span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span></div>


    <span class="c1">#</span>
    <span class="c1"># symmetries</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="CylinderDiagram.inverse">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.inverse">[docs]</a>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the inverse cylinder diagram.</span>

<span class="sd">        The inverse of a cylinder diagram is the cylinder diagram in which all</span>
<span class="sd">        cylinders have been reversed. It corresponds to the multiplication by</span>
<span class="sd">        `-1` on the underlying Abelian differential.</span>

<span class="sd">        Combinatorially the operation is b0-t0 ... bk-tk becomes t0-b0 ... tk-bk</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(0,2) (3,5,4)-(1,4,6) (2,6)-(3,5)&#39;)</span>
<span class="sd">            sage: c</span>
<span class="sd">            (0,1)-(0,2) (2,6)-(3,5) (3,5,4)-(1,4,6)</span>
<span class="sd">            sage: c.inverse()</span>
<span class="sd">            (0,2)-(0,1) (1,4,6)-(3,5,4) (3,5)-(2,6)</span>

<span class="sd">        The operation can also be defined at the level of the separatrix</span>
<span class="sd">        diagrams and the two operation commutes::</span>

<span class="sd">            sage: c.separatrix_diagram().inverse() == c.inverse().separatrix_diagram()</span>
<span class="sd">            True</span>

<span class="sd">        The inversion can also be seen as the composition of the horizontal and</span>
<span class="sd">        vertical symmetries::</span>

<span class="sd">            sage: c.horizontal_symmetry().vertical_symmetry() == c.inverse()</span>
<span class="sd">            True</span>
<span class="sd">            sage: c.vertical_symmetry().horizontal_symmetry() == c.inverse()</span>
<span class="sd">            True</span>

<span class="sd">        The inversion is an involution on cylinder diagrams::</span>

<span class="sd">            sage: all(cc.inverse().inverse() == cc for cc in AbelianStratum(4).cylinder_diagrams()) # long time</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CylinderDiagram</span><span class="p">([(</span><span class="n">t</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()])</span></div>


<div class="viewcode-block" id="CylinderDiagram.vertical_symmetry">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.vertical_symmetry">[docs]</a>
    <span class="k">def</span> <span class="nf">vertical_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cylinder diagram obtained by reflecting the cylinder</span>
<span class="sd">        configuration along the vertical axis.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,3,4)-(0,3,5) (1,2,5)-(1,2,4)&#39;)</span>
<span class="sd">            sage: c.vertical_symmetry()</span>
<span class="sd">            (0,4,3)-(0,5,3) (1,5,2)-(1,4,2)</span>

<span class="sd">            sage: c.separatrix_diagram().vertical_symmetry() == c.vertical_symmetry().separatrix_diagram()</span>
<span class="sd">            True</span>

<span class="sd">            sage: A = AbelianStratum(2,2)</span>
<span class="sd">            sage: all(c.vertical_symmetry().stratum() == A for c in A.cylinder_diagrams())</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CylinderDiagram</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()))</span></div>


<div class="viewcode-block" id="CylinderDiagram.horizontal_symmetry">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.horizontal_symmetry">[docs]</a>
    <span class="k">def</span> <span class="nf">horizontal_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cylinder diagram obtained by reflecting the cylinder</span>
<span class="sd">        configuration along the horizontal axis.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,3,4)-(0,3,5) (1,2,5)-(1,2,4)&#39;)</span>
<span class="sd">            sage: c.horizontal_symmetry()</span>
<span class="sd">            (0,5,3)-(0,4,3) (1,4,2)-(1,5,2)</span>

<span class="sd">            sage: c.separatrix_diagram().horizontal_symmetry() == c.horizontal_symmetry().separatrix_diagram()</span>
<span class="sd">            True</span>

<span class="sd">            sage: A = AbelianStratum(2,2)</span>
<span class="sd">            sage: all(c.horizontal_symmetry().stratum() == A for c in A.cylinder_diagrams())</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CylinderDiagram</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()))</span></div>


<div class="viewcode-block" id="CylinderDiagram.symmetries">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.symmetries">[docs]</a>
    <span class="k">def</span> <span class="nf">symmetries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a triple ``(horiz_sym, vert_sym, inv_sym)``</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(2,3,5) (2,3,4)-(1) (5)-(0,4)&#39;)</span>
<span class="sd">            sage: c.symmetries()</span>
<span class="sd">            (False, True, False)</span>

<span class="sd">            sage: c.horizontal_symmetry().is_isomorphic(c)</span>
<span class="sd">            False</span>
<span class="sd">            sage: c.vertical_symmetry().is_isomorphic(c)</span>
<span class="sd">            True</span>
<span class="sd">            sage: c.inverse().is_isomorphic(c)</span>
<span class="sd">            False</span>

<span class="sd">            sage: CylinderDiagram(&#39;(0,2,1,4,3)-(0,4,2,1,3)&#39;).symmetries()</span>
<span class="sd">            (True, True, True)</span>
<span class="sd">            sage: CylinderDiagram(&#39;(0,3)-(0,4,5) (1,4,2)-(1,3) (5)-(2)&#39;).symmetries()</span>
<span class="sd">            (False, False, True)</span>
<span class="sd">            sage: CylinderDiagram(&#39;(0,2,3,1)-(0,2,1,4) (4)-(3)&#39;).symmetries()</span>
<span class="sd">            (True, False, False)</span>
<span class="sd">            sage: CylinderDiagram(&#39;(0,1,2)-(0,3,1,4) (3,4)-(2)&#39;).symmetries()</span>
<span class="sd">            (False, True, False)</span>
<span class="sd">            sage: CylinderDiagram(&#39;(0,1)-(0,3,4) (2,3)-(1) (4)-(2)&#39;).symmetries()</span>
<span class="sd">            (False, False, False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">)</span>

        <span class="c1"># we first consider the separatrix diagram as it is much faster</span>
        <span class="n">bot</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bot</span><span class="p">)</span>

        <span class="c1"># compute the inverses</span>
        <span class="n">ibot</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">itop</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ibot</span><span class="p">[</span><span class="n">bot</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">itop</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1"># horiz</span>
        <span class="n">bot1</span><span class="p">,</span> <span class="n">top1</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">itop</span><span class="p">,</span> <span class="n">ibot</span><span class="p">)</span>
        <span class="n">sep_horiz_sym</span> <span class="o">=</span> <span class="n">bot</span> <span class="o">==</span> <span class="n">bot1</span> <span class="ow">and</span> <span class="n">top</span> <span class="o">==</span> <span class="n">top1</span>

        <span class="c1"># vert</span>
        <span class="n">bot1</span><span class="p">,</span> <span class="n">top1</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">ibot</span><span class="p">,</span> <span class="n">itop</span><span class="p">)</span>
        <span class="n">sep_vert_sym</span> <span class="o">=</span> <span class="n">bot</span> <span class="o">==</span> <span class="n">bot1</span> <span class="ow">and</span> <span class="n">top</span> <span class="o">==</span> <span class="n">top1</span>

        <span class="c1"># inv</span>
        <span class="k">if</span> <span class="n">sep_horiz_sym</span> <span class="ow">and</span> <span class="n">sep_vert_sym</span><span class="p">:</span>  <span class="c1"># got the two</span>
            <span class="n">sep_inverse_sym</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">sep_horiz_sym</span><span class="o">^</span><span class="n">sep_vert_sym</span><span class="p">:</span>    <span class="c1"># got exactly one</span>
            <span class="n">sep_inverse_sym</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>                       <span class="c1"># none of them</span>
            <span class="n">bot1</span><span class="p">,</span> <span class="n">top1</span> <span class="o">=</span> <span class="n">two_non_connected_perms_canonical_labels</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bot</span><span class="p">)</span>
            <span class="n">sep_inverse_sym</span> <span class="o">=</span> <span class="n">bot</span> <span class="o">==</span> <span class="n">bot1</span> <span class="ow">and</span> <span class="n">top</span> <span class="o">==</span> <span class="n">top1</span>

        <span class="c1"># next we check the cylinder diagram if needed</span>
        <span class="k">if</span> <span class="n">sep_horiz_sym</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizontal_symmetry</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">horiz_sym</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">horiz_sym</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">sep_vert_sym</span><span class="p">:</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertical_symmetry</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">vert_sym</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vert_sym</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">horiz_sym</span> <span class="ow">and</span> <span class="n">vert_sym</span><span class="p">:</span>  <span class="c1"># got the two</span>
            <span class="n">inverse_sym</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">horiz_sym</span><span class="o">^</span><span class="n">vert_sym</span><span class="p">:</span>    <span class="c1"># got exactly one</span>
            <span class="n">inverse_sym</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>                       <span class="c1"># none of them</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_label</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">inverse_sym</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">horiz_sym</span><span class="p">,</span> <span class="n">vert_sym</span><span class="p">,</span> <span class="n">inverse_sym</span><span class="p">)</span></div>



<div class="viewcode-block" id="CylinderDiagram.automorphism_group">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.automorphism_group">[docs]</a>
    <span class="k">def</span> <span class="nf">automorphism_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the automorphism group</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``order`` - boolean (default: False) - whether or not return the order</span>
<span class="sd">          of the group</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cyl = CylinderDiagram(&#39;(0,1)-(0,2) (2,3)-(1,3)&#39;)</span>
<span class="sd">            sage: cyl.automorphism_group()</span>
<span class="sd">            Permutation Group with generators [(0,3)(1,2)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_directed_graph</span><span class="p">()</span><span class="o">.</span><span class="n">automorphism_group</span><span class="p">(</span><span class="n">edge_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="CylinderDiagram.is_hyperelliptic">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.is_hyperelliptic">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hyperelliptic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test of hyperellipticity</span>

<span class="sd">        Each stratum of Abelian differentials as up to three connected</span>
<span class="sd">        components. For the strata H(2g-2) and H(g-1,g-1) there is a special</span>
<span class="sd">        component called *hyperelliptic* in which all translation surfaces</span>
<span class="sd">        `(X,\omega)` in that component are such that `X` is hyperelliptic.</span>

<span class="sd">        This function returns True if and only if the cylinder diagrams</span>
<span class="sd">        correspond to a decomposition of a surface associated to the</span>
<span class="sd">        hyperelliptic components in H(2g-2) or H(g-1,g-1).</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        In genus 2, strata H(2) and H(1,1), all surfaces are hyperelliptic::</span>

<span class="sd">            sage: for c in AbelianStratum(2).cylinder_diagrams():</span>
<span class="sd">            ....:     print(&quot;%d %s&quot; % (c.ncyls(), c.is_hyperelliptic()))</span>
<span class="sd">            1 True</span>
<span class="sd">            2 True</span>

<span class="sd">            sage: for c in AbelianStratum(1,1).cylinder_diagrams():</span>
<span class="sd">            ....:     print(&quot;%d %s&quot; % (c.ncyls(), c.is_hyperelliptic()))</span>
<span class="sd">            1 True</span>
<span class="sd">            2 True</span>
<span class="sd">            2 True</span>
<span class="sd">            3 True</span>

<span class="sd">        In higher genera, some of them are, some of them are not::</span>

<span class="sd">            sage: C = AbelianStratum(4).cylinder_diagrams()</span>
<span class="sd">            sage: len(C)</span>
<span class="sd">            15</span>
<span class="sd">            sage: sum(c.is_hyperelliptic() for c in C)</span>
<span class="sd">            5</span>

<span class="sd">            sage: C = AbelianStratum(2,2).cylinder_diagrams()</span>
<span class="sd">            sage: len(C)</span>
<span class="sd">            41</span>
<span class="sd">            sage: sum(c.is_hyperelliptic() for c in C)</span>
<span class="sd">            11</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">z</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">z</span> <span class="o">==</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">z</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">z</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;is_hyperelliptic method not implemented for cylinder diagrams with fake zeros&quot;</span><span class="p">)</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># minimal stratum H(2g-2)</span>
            <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot</span><span class="p">()</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
            <span class="c1"># build list of seps in cyclic order around zero, starting by outgoing sep 0</span>
            <span class="n">lout</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lin</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
                <span class="n">lin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">lout</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">lout</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">lin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lin  &#39;</span><span class="p">,</span> <span class="n">lin</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lout&#39;</span><span class="p">,</span> <span class="n">lout</span><span class="p">)</span>
            <span class="c1"># build involution on separatrices</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">ns</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
                <span class="n">p</span><span class="p">[</span><span class="n">lout</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="n">lin</span><span class="p">[(</span><span class="n">a</span><span class="o">+</span><span class="n">ns</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="n">ns</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;involution on seps&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="c1"># wsep = counter of sepatrices with a wpt</span>
            <span class="n">wsep</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># check that p(k) is on the top of the cyl that has k on its bottom</span>
                    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="k">return</span> <span class="kc">False</span>
                    <span class="c1"># check that if k is on bot and top of cyl, then p(k) = k</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="k">return</span> <span class="kc">False</span>
                        <span class="n">wsep</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;wsep&quot;</span><span class="p">,</span> <span class="n">wsep</span><span class="p">)</span>
            <span class="c1"># check number of w pts</span>
            <span class="k">if</span> <span class="n">wsep</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span> <span class="o">!=</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># check that cylinders are stable under involution</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="n">CylinderDiagram</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()]):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># should be stratum H(g-1,g-1)</span>
            <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot</span><span class="p">()</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
            <span class="c1"># build list of seps in cyclic order around first zero, starting by outgoing sep 0</span>
            <span class="n">lout</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lin</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">lin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">lout</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">lout</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">lin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lin  &#39;</span><span class="p">,</span> <span class="n">lin</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lout&#39;</span><span class="p">,</span> <span class="n">lout</span><span class="p">)</span>
            <span class="c1"># build list of seps in cyclic order around the other zero</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">lout</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">llout</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="n">llin</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">llin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">llout</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">llout</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">llin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;llin  &#39;</span><span class="p">,</span> <span class="n">llin</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;llout&#39;</span><span class="p">,</span> <span class="n">llout</span><span class="p">)</span>
            <span class="c1"># now, try each way the involution could send lout to llout</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">test</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># build involution on separatrices</span>
                <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">ns</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">p</span><span class="p">[</span><span class="n">lout</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="n">llin</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="n">ns</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
                    <span class="n">p</span><span class="p">[</span><span class="n">llout</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="n">lin</span><span class="p">[(</span><span class="n">a</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="n">ns</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;involution on seps&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="n">wsep</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="c1"># check that p(k) is on the top of the cyl that has k on its bottom</span>
                        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">test</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                        <span class="c1"># check that if k is on bot and top of cyl, then p(k) = k</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                                <span class="n">test</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="k">break</span>
                            <span class="n">wsep</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span> <span class="k">break</span>
                <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># try next j</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;wsep&quot;</span><span class="p">,</span> <span class="n">wsep</span><span class="p">)</span>
                <span class="c1"># check number of w pts</span>
                <span class="k">if</span> <span class="n">wsep</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">continue</span> <span class="c1"># try next j</span>
                <span class="c1"># check that cylinders are stable under involution</span>
                <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="n">CylinderDiagram</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()]):</span>
                    <span class="k">continue</span> <span class="c1"># try next j</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


    <span class="c1">#</span>
    <span class="c1"># construction</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="CylinderDiagram.dual_graph">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.dual_graph">[docs]</a>
    <span class="k">def</span> <span class="nf">dual_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dual graph of the stable curve at infinity in the horizontal</span>
<span class="sd">        direction.</span>

<span class="sd">        This graph is defines as follows. Cut each horizontal cylinder along a</span>
<span class="sd">        circumference, then the vertices are the equivalence class of half</span>
<span class="sd">        cylinder modulo the relation &quot;linked by a saddle connection&quot; and the</span>
<span class="sd">        edges are the circumferences.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        We consider the three diagrams of the stratum H(1,1)::</span>

<span class="sd">            sage: c1 = CylinderDiagram(&#39;(0,1,2,3)-(0,1,2,3)&#39;)</span>
<span class="sd">            sage: c1.stratum()</span>
<span class="sd">            H_2(1^2)</span>
<span class="sd">            sage: c1.dual_graph()</span>
<span class="sd">            Looped multi-graph on 1 vertex</span>
<span class="sd">            sage: c2 = CylinderDiagram(&#39;(0,1)-(1,2) (2,3)-(0,3)&#39;)</span>
<span class="sd">            sage: c2.stratum()</span>
<span class="sd">            H_2(1^2)</span>
<span class="sd">            sage: c2.dual_graph()</span>
<span class="sd">            Looped multi-graph on 1 vertex</span>
<span class="sd">            sage: c3 = CylinderDiagram(&#39;(0,1)-(2,3) (2)-(0) (3)-(1)&#39;)</span>
<span class="sd">            sage: c3.stratum()</span>
<span class="sd">            H_2(1^2)</span>
<span class="sd">            sage: c3.dual_graph()</span>
<span class="sd">            Looped multi-graph on 2 vertices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.graphs.graph</span> <span class="kn">import</span> <span class="n">Graph</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_cycle_tuples</span><span class="p">()</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_cycle_tuples</span><span class="p">()</span>

        <span class="c1"># first compute the equivalence class of half cylinders (i.e. gives vertices)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
        <span class="n">V</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">b&#39;</span> <span class="o">%</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cb</span><span class="p">)</span>
        <span class="n">V</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">t&#39;</span> <span class="o">%</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ct</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()):</span>
            <span class="n">V</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">b&#39;</span> <span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span>
                <span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">t&#39;</span> <span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_top_to_cyl</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># the dual graph</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="n">V</span><span class="o">.</span><span class="n">connected_components</span><span class="p">())</span>
        <span class="n">hc2cc</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># half-cyl to conn comp</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">hc2cc</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">hc2cc</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">b&#39;</span> <span class="o">%</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">hc2cc</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">t&#39;</span> <span class="o">%</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="CylinderDiagram.matrix_relation">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.matrix_relation">[docs]</a>
    <span class="k">def</span> <span class="nf">matrix_relation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the matrix of relation on the lengths of the separatrices.</span>

<span class="sd">        The output matrix has size `ncyls \times nseps`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        For a one cylinder diagram, there is no relations::</span>

<span class="sd">            sage: cyl = CylinderDiagram(&#39;(0,1,2,3)-(0,1,2,3)&#39;)</span>
<span class="sd">            sage: cyl.matrix_relation()</span>
<span class="sd">            [0 0 0 0]</span>

<span class="sd">        Here is an example in the stratum H(2)::</span>

<span class="sd">            sage: cyl = CylinderDiagram(&#39;(0,1)-(0,2) (2)-(1)&#39;)</span>
<span class="sd">            sage: cyl.stratum()</span>
<span class="sd">            H_2(2)</span>
<span class="sd">            sage: cyl.matrix_relation()</span>
<span class="sd">            [ 0  1 -1]</span>
<span class="sd">            [ 0 -1  1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">matrix</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">(),</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">top</span><span class="p">,</span><span class="n">bot</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">m</span></div>


    <span class="c1">#</span>
    <span class="c1"># Abelian differentials / coordinates</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="CylinderDiagram.stratum_component">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.stratum_component">[docs]</a>
    <span class="k">def</span> <span class="nf">stratum_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the connected component of stratum of ``self``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: CylinderDiagram(&#39;(0,1)-(0,2) (2)-(1)&#39;).stratum_component()</span>
<span class="sd">            H_2(2)^hyp</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,3,2,1)-(1,4,3,2) (4,7,6,5)-(0,7,6,5)&#39;)</span>
<span class="sd">            sage: c.stratum_component()</span>
<span class="sd">            H_4(3^2)^hyp</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,4)-(1,6,7) (2,5,3)-(0,2,4) (6)-(5) (7)-(3)&#39;)</span>
<span class="sd">            sage: c.stratum_component()</span>
<span class="sd">            H_4(3^2)^nonhyp</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,6)-(1,7) (1,5,4,3,2)-(2,6,5,4,3) (7,9,8)-(0,9,8)&#39;)</span>
<span class="sd">            sage: c.stratum_component()</span>
<span class="sd">            H_5(4^2)^hyp</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,2,6,1)-(0,8,1,9,2,5,7,4) (3,7,4,8,9,5)-(3,6)&#39;)</span>
<span class="sd">            sage: c.stratum_component()</span>
<span class="sd">            H_5(4^2)^even</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(3,7,4,8,9,5)-(0,8,1,9,2,5,7,4) (0,2,6,1)-(3,6)&#39;)</span>
<span class="sd">            sage: c.stratum_component()</span>
<span class="sd">            H_5(4^2)^odd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stratum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">_cc</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">stratum</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">.abelian_strata</span> <span class="kn">import</span> <span class="n">HypASC</span>
        <span class="k">if</span> <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">HypASC</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hyperelliptic</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">HypASC</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cc</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">stratum</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_parity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.abelian_strata</span> <span class="kn">import</span> <span class="n">EvenASC</span>
            <span class="k">return</span> <span class="n">EvenASC</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.abelian_strata</span> <span class="kn">import</span> <span class="n">OddASC</span>
            <span class="k">return</span> <span class="n">OddASC</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span></div>


<div class="viewcode-block" id="CylinderDiagram.smallest_integer_lengths">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.smallest_integer_lengths">[docs]</a>
    <span class="k">def</span> <span class="nf">smallest_integer_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if there is a integer solution that satisfy the cylinder</span>
<span class="sd">        conditions.</span>

<span class="sd">        If there is a solution, the function returns a list a pair</span>
<span class="sd">        ``(total_length, list_of_lengths)`` that consists of the sum of the</span>
<span class="sd">        length of the separatrices together with the list of lengths. Otherwise,</span>
<span class="sd">        returns False.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(0,2) (2,3)-(1,3)&#39;)</span>
<span class="sd">            sage: c.smallest_integer_lengths()</span>
<span class="sd">            (4, [1, 1, 1, 1])</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,2)-(3) (3)-(0) (4)-(1,2,4)&#39;)</span>
<span class="sd">            sage: c.smallest_integer_lengths()</span>
<span class="sd">            False</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1)-(0,5) (2)-(3) (3,6)-(8) (4,8)-(6,7) (5)-(2,4) (7)-(1)&#39;)</span>
<span class="sd">            sage: c.smallest_integer_lengths()</span>
<span class="sd">            (13, [1, 2, 1, 1, 1, 2, 1, 2, 2])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">(),</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())</span>

        <span class="kn">from</span> <span class="nn">sage.numerical.mip</span> <span class="kn">import</span> <span class="n">MixedIntegerLinearProgram</span><span class="p">,</span> <span class="n">MIPSolverException</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="n">bot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_cycle_tuples</span><span class="p">()</span>
        <span class="n">top</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">top_orbit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bot_to_cyl</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">]</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">MixedIntegerLinearProgram</span><span class="p">(</span><span class="n">maximization</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">scl</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">new_variable</span><span class="p">(</span><span class="n">nonnegative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">scl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">scl</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">scl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">==</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">scl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
                    <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">Integer</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">scl</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">total</span><span class="p">,</span> <span class="n">lengths</span>
        <span class="k">except</span> <span class="n">MIPSolverException</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


    <span class="c1">#</span>
    <span class="c1"># homology</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="CylinderDiagram.to_ribbon_graph">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.to_ribbon_graph">[docs]</a>
    <span class="k">def</span> <span class="nf">to_ribbon_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ribbon graph</span>

<span class="sd">        A *ribbon graph* is a graph embedded in an oriented surface such that</span>
<span class="sd">        its complement is a union of topological discs. To a cylinder diagram we</span>
<span class="sd">        associate the graph which consists of separatrices together with a</span>
<span class="sd">        choice of one vertical edge in each cylinder.</span>

<span class="sd">        The edges of the ribbon graph are labeled by ``(i,nseps+i)`` for</span>
<span class="sd">        separatrices and by ``(2(nseps+j),2(nseps+j)+1)`` for vertical in</span>
<span class="sd">        cylinders.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: C = CylinderDiagram([((0,1),(0,2)),((2,),(1,))])</span>
<span class="sd">            sage: C.stratum()</span>
<span class="sd">            H_2(2)</span>
<span class="sd">            sage: R = C.to_ribbon_graph(); R</span>
<span class="sd">            Ribbon graph with 1 vertex, 5 edges and 2 faces</span>
<span class="sd">            sage: l,m = R.cycle_basis(intersection=True)</span>
<span class="sd">            sage: m.rank() == 2 * C.genus()</span>
<span class="sd">            True</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: f = lambda c: c.to_ribbon_graph().cycle_basis(intersection=True)[1]</span>

<span class="sd">            sage: a = AbelianStratum(2)</span>
<span class="sd">            sage: all(f(c).rank() == 4 for c in a.cylinder_diagrams())</span>
<span class="sd">            True</span>
<span class="sd">            sage: a = AbelianStratum(1,1)</span>
<span class="sd">            sage: all(f(c).rank() == 4 for c in a.cylinder_diagrams())</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.homology</span> <span class="kn">import</span> <span class="n">RibbonGraphWithAngles</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">))</span>
        <span class="n">half</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">Integer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">b</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="n">face</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">j</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">t</span><span class="p">[:</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">face</span><span class="p">))</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">angles</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">t1</span><span class="p">]</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">half</span>

        <span class="k">return</span> <span class="n">RibbonGraphWithAngles</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="n">faces</span><span class="p">,</span><span class="n">angles</span><span class="o">=</span><span class="n">angles</span><span class="p">)</span></div>


<div class="viewcode-block" id="CylinderDiagram.to_ribbon_graph_with_holonomies">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.to_ribbon_graph_with_holonomies">[docs]</a>
    <span class="k">def</span> <span class="nf">to_ribbon_graph_with_holonomies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">twists</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.homology</span> <span class="kn">import</span> <span class="n">RibbonGraphWithHolonomies</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">b</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="n">face</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">j</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">t</span><span class="p">[:</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">face</span><span class="p">))</span>

        <span class="n">holonomies</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">holonomies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">holonomies</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">holonomies</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">)]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">twists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">holonomies</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">twists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">-</span><span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">RibbonGraphWithHolonomies</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="n">faces</span><span class="p">,</span><span class="n">holonomies</span><span class="o">=</span><span class="n">holonomies</span><span class="p">)</span></div>




<div class="viewcode-block" id="CylinderDiagram.spin_parity">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.spin_parity">[docs]</a>
    <span class="k">def</span> <span class="nf">spin_parity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spin parity of any surface that is built from this cylinder</span>
<span class="sd">        diagram.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,2,3,4)-(0,1,2,3,4)&#39;)</span>
<span class="sd">            sage: c.spin_parity()</span>
<span class="sd">            0</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,2,3,4)-(0,1,4,2,3)&#39;)</span>
<span class="sd">            sage: c.spin_parity()</span>
<span class="sd">            1</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,2,6,1)-(0,8,1,9,2,5,7,4) (3,7,4,8,9,5)-(3,6)&#39;)</span>
<span class="sd">            sage: c.spin_parity()</span>
<span class="sd">            0</span>
<span class="sd">            sage: c = CylinderDiagram(&#39;(3,7,4,8,9,5)-(0,8,1,9,2,5,7,4) (0,2,6,1)-(3,6)&#39;)</span>
<span class="sd">            sage: c.spin_parity()</span>
<span class="sd">            1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">z</span><span class="o">%</span><span class="mi">2</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_ribbon_graph</span><span class="p">()</span><span class="o">.</span><span class="n">spin_parity</span><span class="p">()</span></div>


<span class="c1">#    def circumferences_of_cylinders(self,ring=None):</span>
<span class="c1">#        r&quot;&quot;&quot;</span>
<span class="c1">#        Return the set of circumferences of cylinders as cycles in the chain</span>
<span class="c1">#        space.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        from sage.modules.free_module import FreeModule</span>
<span class="c1">#        from copy import copy</span>
<span class="c1">#</span>
<span class="c1">#        if ring is None:</span>
<span class="c1">#            from sage.rings.integer_ring import ZZ</span>
<span class="c1">#            ring = ZZ</span>
<span class="c1">#</span>
<span class="c1">#        g = self.to_ribbon_graph()</span>
<span class="c1">#        C = g.chain_complex(ring)</span>
<span class="c1">#        C1 = C.chain_space(1)</span>
<span class="c1">#        Z1 = C.cycle_space(1)</span>
<span class="c1">#        n = g.num_edges()</span>
<span class="c1">#</span>
<span class="c1">#        V = FreeModule(ring, n)</span>
<span class="c1">#</span>
<span class="c1">#        l = []</span>
<span class="c1">#        for (b,t) in self.cylinders():</span>
<span class="c1">#            v = copy(V.zero())</span>
<span class="c1">#            for i in b:</span>
<span class="c1">#                v[g.dart_to_edge(i,orientation=True)] = 1</span>
<span class="c1">#            l.append(Z1(V(v)))</span>
<span class="c1">#        return l</span>

    <span class="c1">#</span>
    <span class="c1"># build one or many origamis</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="CylinderDiagram.an_origami">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.an_origami">[docs]</a>
    <span class="k">def</span> <span class="nf">an_origami</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return one origami with this diagram cylinder if any.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cyl = CylinderDiagram(&#39;(0,1)-(0,2) (2,3)-(1,3)&#39;)</span>
<span class="sd">            sage: cyl.an_origami()</span>
<span class="sd">            (1,2)(3,4)</span>
<span class="sd">            (1,3,4,2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smallest_integer_lengths</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">m</span><span class="p">,</span><span class="n">lengths</span> <span class="o">=</span> <span class="n">res</span>

        <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">)</span> <span class="k">for</span> <span class="n">bot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_cycle_tuples</span><span class="p">()]</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="p">[</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">())]</span>

        <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">areas</span><span class="p">:</span>
            <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span>

        <span class="c1"># initialization of bottom squares: sep_i -&gt; bottom position</span>
        <span class="n">sep_bottom_pos</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">bot</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">:</span>
                <span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span>
                <span class="n">w</span> <span class="o">+=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c1"># initialization of sigma_h which remains constant</span>
        <span class="n">lx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">lx</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

        <span class="c1"># initialization of y except the top</span>
        <span class="n">ly</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()):</span>
            <span class="n">ly</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># build the top interval without twist</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">_</span><span class="p">,</span><span class="n">top_seps</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="n">top</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">top_seps</span><span class="p">):</span>
                <span class="n">top</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">lengths</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
            <span class="n">ly</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">top</span>

        <span class="c1"># yield the origami without twist</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.origamis.origami</span> <span class="kn">import</span> <span class="n">Origami_dense_pyx</span>
        <span class="k">return</span> <span class="n">Origami_dense_pyx</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lx</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ly</span><span class="p">))</span></div>


<div class="viewcode-block" id="CylinderDiagram.origami_iterator">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.origami_iterator">[docs]</a>
    <span class="k">def</span> <span class="nf">origami_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iteration over all origamis with n squares.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``n`` - positive integer - the number of squares</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cyl = CylinderDiagram(&#39;(0,1,2)-(3,1,2) (3)-(0)&#39;)</span>
<span class="sd">            sage: for o in cyl.origami_iterator(4):</span>
<span class="sd">            ....:     print(o)</span>
<span class="sd">            ....:     print(o.stratum())</span>
<span class="sd">            ....:     print(o.nb_squares())</span>
<span class="sd">            (1,2,3)(4)</span>
<span class="sd">            (1,4)(2,3)</span>
<span class="sd">            H_2(1^2)</span>
<span class="sd">            4</span>
<span class="sd">            (1,2,3)(4)</span>
<span class="sd">            (1,2,4)(3)</span>
<span class="sd">            H_2(1^2)</span>
<span class="sd">            4</span>
<span class="sd">            (1,2,3)(4)</span>
<span class="sd">            (1,3,4)(2)</span>
<span class="sd">            H_2(1^2)</span>
<span class="sd">            4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths_and_heights_iterator</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylcoord_to_origami_iterator</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span></div>


<div class="viewcode-block" id="CylinderDiagram.origamis">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.origamis">[docs]</a>
    <span class="k">def</span> <span class="nf">origamis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of origamis having ``n`` squares.</span>

<span class="sd">        If ``n`` is None then return the origamis with less number of squares.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cyl = CylinderDiagram(&#39;(0,1,2)-(0,1,3) (3)-(2)&#39;)</span>
<span class="sd">            sage: o5 = cyl.origamis(5)</span>
<span class="sd">            sage: o5[0]</span>
<span class="sd">            (1,2,3,4)(5)</span>
<span class="sd">            (1,5,4,2,3)</span>
<span class="sd">            sage: o5[1].nb_squares()</span>
<span class="sd">            5</span>
<span class="sd">            sage: o5[2].stratum_component()</span>
<span class="sd">            H_2(1^2)^hyp</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: c1 = CylinderDiagram(&quot;(0,1)-(0,3,4,5) (2,3,5)-(1) (4)-(2)&quot;)</span>
<span class="sd">            sage: c2 = CylinderDiagram(&quot;(0,1)-(0,5) (2)-(4) (3,4)-(1) (5)-(2,3)&quot;)</span>
<span class="sd">            sage: c3 = CylinderDiagram(&quot;(0,3)-(5) (1)-(0) (2,5)-(3,4) (4)-(1,2)&quot;)</span>
<span class="sd">            sage: len(c1.origamis(8))</span>
<span class="sd">            12</span>
<span class="sd">            sage: len(c2.origamis(8))</span>
<span class="sd">            12</span>
<span class="sd">            sage: len(c3.origamis(8))</span>
<span class="sd">            12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smallest_integer_lengths</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origami_iterator</span><span class="p">(</span><span class="n">n</span><span class="p">))</span></div>


<div class="viewcode-block" id="CylinderDiagram.widths_and_heights_iterator">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.widths_and_heights_iterator">[docs]</a>
    <span class="k">def</span> <span class="nf">widths_and_heights_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">height_one</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the possible integer widths and heights of the cylinders</span>
<span class="sd">        for which the corresponding translation surface has area ``n``.</span>

<span class="sd">        At each iteration, the output is a pair of ``(lengths, heights)``. You</span>
<span class="sd">        can then use :meth:`cylcoord_to_origami` to build the corresponding</span>
<span class="sd">        origami.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``height_one`` -- (boolean default ``False``) whether to return only</span>
<span class="sd">          coordinates with cylinder height one.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cyl = CylinderDiagram([((0,1),(0,2)),((2,),(1,))])</span>
<span class="sd">            sage: cyl</span>
<span class="sd">            (0,1)-(0,2) (2)-(1)</span>

<span class="sd">            sage: it = cyl.widths_and_heights_iterator(10)</span>
<span class="sd">            sage: l,h = next(it)</span>
<span class="sd">            sage: print(l)</span>
<span class="sd">            (2, 1, 1)</span>
<span class="sd">            sage: print(h)</span>
<span class="sd">            [3, 1]</span>
<span class="sd">            sage: cyl.cylcoord_to_origami(l,h)</span>
<span class="sd">            (1,2,3)(4,5,6)(7,8,9)(10)</span>
<span class="sd">            (1,4,7)(2,5,8)(3,6,9,10)</span>

<span class="sd">            sage: it = cyl.widths_and_heights_iterator(10, height_one=True)</span>
<span class="sd">            sage: l,h = next(it)</span>
<span class="sd">            sage: print(l)</span>
<span class="sd">            (8, 1, 1)</span>
<span class="sd">            sage: print(h)</span>
<span class="sd">            [1, 1]</span>
<span class="sd">            sage: cyl.cylcoord_to_origami(l,h)</span>
<span class="sd">            (1,2,3,4,5,6,7,8,9)(10)</span>
<span class="sd">            (1)(2)(3)(4)(5)(6)(7)(8)(9,10)</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: c1 = CylinderDiagram(&quot;(0,1)-(0,3,4,5) (2,3,5)-(1) (4)-(2)&quot;)</span>
<span class="sd">            sage: c2 = CylinderDiagram(&quot;(0,1)-(0,5) (2)-(4) (3,4)-(1) (5)-(2,3)&quot;)</span>
<span class="sd">            sage: c3 = CylinderDiagram(&quot;(0,3)-(5) (1)-(0) (2,5)-(3,4) (4)-(1,2)&quot;)</span>
<span class="sd">            sage: list(c1.widths_and_heights_iterator(8))</span>
<span class="sd">            [((1, 3, 1, 1, 1, 1), [1, 1, 1])]</span>
<span class="sd">            sage: list(c2.widths_and_heights_iterator(8))</span>
<span class="sd">            [((1, 2, 1, 1, 1, 2), [1, 1, 1, 1])]</span>
<span class="sd">            sage: list(c3.widths_and_heights_iterator(8))</span>
<span class="sd">            [((1, 1, 1, 1, 2, 2), [1, 1, 1, 1])]</span>

<span class="sd">            sage: for n in range(8, 12):</span>
<span class="sd">            ....:     for c in c1,c2,c3:</span>
<span class="sd">            ....:         L1 = [wh for wh in c.widths_and_heights_iterator(n) if all(h == 1 for h in wh[1])]</span>
<span class="sd">            ....:         L2 = list(c.widths_and_heights_iterator(n, height_one=True))</span>
<span class="sd">            ....:         assert L1 == L2, (L1, L2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.combinat.integer_lists</span> <span class="kn">import</span> <span class="n">IntegerListsLex</span>
        <span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>
        <span class="kn">from</span> <span class="nn">sage.modules.free_module</span> <span class="kn">import</span> <span class="n">FreeModule</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>

        <span class="n">V</span> <span class="o">=</span> <span class="n">FreeModule</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())</span>

        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_relation</span><span class="p">()</span>

        <span class="n">min_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">nonzero_positions_in_row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">pos_m</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
            <span class="n">pos_p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">min_lengths</span><span class="p">[</span><span class="n">pos_m</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_lengths</span><span class="p">[</span><span class="n">pos_m</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_p</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">min_lengths</span><span class="p">[</span><span class="n">pos_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_lengths</span><span class="p">[</span><span class="n">pos_m</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_m</span><span class="p">))</span>

        <span class="n">min_widths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bot</span><span class="p">,</span><span class="n">top</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
            <span class="n">min_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span>
                <span class="nb">sum</span><span class="p">(</span><span class="n">min_lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">top</span><span class="p">),</span>
                <span class="nb">sum</span><span class="p">(</span><span class="n">min_lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span>
              <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">())),</span>
              <span class="n">IntegerListsLex</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">(),</span> <span class="n">min_part</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">height_one</span><span class="p">:</span>
                <span class="n">area_div</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">area_div</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="n">min_widths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">arith</span><span class="o">.</span><span class="n">divisors</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()))</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">area_div</span><span class="p">):</span>
                <span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="n">Integer</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">())]</span>

                <span class="c1"># from here the resolution becomes linear and convex ...</span>
                <span class="c1">#TODO: program a linear and convex solution</span>
                <span class="n">seps_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()]</span>
                <span class="n">nseps_b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">seps_b</span><span class="p">))</span>
                <span class="n">lengths</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">IntegerListsLex</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">length</span><span class="o">=</span><span class="n">nseps_b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">min_part</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()))</span>
                <span class="k">for</span> <span class="n">l_by_cyl</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">lengths</span><span class="p">):</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">zero</span><span class="p">())</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nseps_b</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                            <span class="n">l</span><span class="p">[</span><span class="n">seps_b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">l_by_cyl</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">*</span><span class="n">l</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">l</span><span class="p">,</span><span class="n">h</span></div>


<div class="viewcode-block" id="CylinderDiagram.cylcoord_to_origami_iterator">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.cylcoord_to_origami_iterator">[docs]</a>
    <span class="k">def</span> <span class="nf">cylcoord_to_origami_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">heights</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert coordinates of the cylinders into an origami.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``lengths`` - lengths of the separatrices</span>

<span class="sd">        - ``heights`` - heights of the cylinders</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - iterator over all possible origamis with those lengths and heights...</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cyl = CylinderDiagram(&#39;(0,1,2)-(3,1,2) (3)-(0)&#39;)</span>
<span class="sd">            sage: for o in cyl.cylcoord_to_origami_iterator((1,1,1,1),(1,1)):</span>
<span class="sd">            ....:     print(o)</span>
<span class="sd">            (1,2,3)(4)</span>
<span class="sd">            (1,4)(2,3)</span>
<span class="sd">            (1,2,3)(4)</span>
<span class="sd">            (1,2,4)(3)</span>
<span class="sd">            (1,2,3)(4)</span>
<span class="sd">            (1,3,4)(2)</span>

<span class="sd">        The number of origamis generated is just the product of the widths::</span>

<span class="sd">            sage: sum(1 for _ in cyl.cylcoord_to_origami_iterator((2,1,1,2),(3,2)))</span>
<span class="sd">            8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.origamis.origami_dense</span> <span class="kn">import</span> <span class="n">Origami_dense_pyx</span>
        <span class="kn">from</span> <span class="nn">sage.combinat.gray_codes</span> <span class="kn">import</span> <span class="n">product</span>

        <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">)</span> <span class="k">for</span> <span class="n">bot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bot_cycle_tuples</span><span class="p">()]</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="p">[</span><span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">())]</span>

        <span class="c1"># initialization of partial volumes: the set of squares in cylinder i is range(v[i],v[i+1])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">areas</span><span class="p">:</span>
            <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span>

        <span class="c1"># initialization of bottom squares: sep_i -&gt; bottom position</span>
        <span class="n">sep_bottom_pos</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">bot</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">:</span>
                <span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span>
                <span class="n">w</span> <span class="o">+=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c1"># initialization of sigma_h which remains constant</span>
        <span class="n">lx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">lx</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

        <span class="c1"># initialization of y except the top</span>
        <span class="n">ly</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()):</span>
            <span class="n">ly</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">ly</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># build the top interval without twist</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">_</span><span class="p">,</span><span class="n">top_seps</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="n">top</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">top_seps</span><span class="p">):</span>
                <span class="n">top</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">lengths</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
            <span class="n">ly</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">top</span>

        <span class="c1"># yield the one without twist</span>
        <span class="k">yield</span> <span class="n">Origami_dense_pyx</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lx</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ly</span><span class="p">))</span>

        <span class="c1"># yield the others using a Gray code</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">o</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ly</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">ly</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ly</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">ly</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">yield</span> <span class="n">Origami_dense_pyx</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lx</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ly</span><span class="p">))</span></div>


<div class="viewcode-block" id="CylinderDiagram.cylcoord_to_origami">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.cylcoord_to_origami">[docs]</a>
    <span class="k">def</span> <span class="nf">cylcoord_to_origami</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">twists</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert coordinates of the cylinders into an origami.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``lengths`` - lengths of the separatrices</span>

<span class="sd">        - ``heights`` - heights of the cylinders</span>

<span class="sd">        - ``twists`` - twists for cylinders</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = CylinderDiagram([((0,1),(1,2)),((2,),(0,))])</span>
<span class="sd">            sage: c.stratum()</span>
<span class="sd">            H_2(2)</span>
<span class="sd">            sage: c.cylcoord_to_origami([1,1,1],[1,1]).stratum()</span>
<span class="sd">            H_2(2)</span>
<span class="sd">            sage: o1 = c.cylcoord_to_origami([2,1,2],[1,1],[1,0])</span>
<span class="sd">            sage: o1 = o1.relabel()</span>
<span class="sd">            sage: o2 = c.cylcoord_to_origami([2,1,2],[1,1],[0,1])</span>
<span class="sd">            sage: o2 = o2.relabel()</span>
<span class="sd">            sage: o3 = c.cylcoord_to_origami([2,1,2],[1,1],[1,1])</span>
<span class="sd">            sage: o3 = o3.relabel()</span>
<span class="sd">            sage: all(o.stratum() == AbelianStratum(2) for o in [o1,o2,o3])</span>
<span class="sd">            True</span>
<span class="sd">            sage: o1 == o2 or o1 == o3 or o3 == o1</span>
<span class="sd">            False</span>

<span class="sd">        If the lengths are not compatible with the cylinder diagram a ValueError</span>
<span class="sd">        is raised::</span>

<span class="sd">            sage: c.cylcoord_to_origami([1,2,3],[1,1])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: lengths are not compatible with cylinder equations</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: c = CylinderDiagram([((0,),(1,)), ((1,2,3),(0,2,3))])</span>
<span class="sd">            sage: c</span>
<span class="sd">            (0)-(1) (1,2,3)-(0,2,3)</span>
<span class="sd">            sage: lengths = [1,1,1,1]</span>
<span class="sd">            sage: heights = [1,1]</span>
<span class="sd">            sage: c.cylcoord_to_origami(lengths,heights,[0,0])</span>
<span class="sd">            (1)(2,3,4)</span>
<span class="sd">            (1,2)(3,4)</span>
<span class="sd">            sage: c.cylcoord_to_origami(lengths,heights,[0,1])</span>
<span class="sd">            (1)(2,3,4)</span>
<span class="sd">            (1,2,3)(4)</span>
<span class="sd">            sage: c.cylcoord_to_origami(lengths,heights,[0,2])</span>
<span class="sd">            (1)(2,3,4)</span>
<span class="sd">            (1,2,4)(3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.origamis.origami_dense</span> <span class="kn">import</span> <span class="n">Origami_dense_pyx</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the &#39;lengths&#39; vector has wrong length&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lengths</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the &#39;heights&#39; vector has wrong length&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heights</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heights</span><span class="p">]</span>

        <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">)</span> <span class="k">for</span> <span class="n">bot</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()]</span>

        <span class="k">if</span> <span class="n">widths</span> <span class="o">!=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">top</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">top</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lengths are not compatible with cylinder equations&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">twists</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">twists</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">twists</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the &#39;twists&#39; vector has wrong length&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">twists</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="n">twists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">%</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">))]</span>

        <span class="n">areas</span> <span class="o">=</span> <span class="p">[</span><span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">())]</span>

        <span class="c1"># initialization of partial volumes: the set of squares in cylinder i is range(v[i],v[i+1])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">areas</span><span class="p">:</span>
            <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span>

        <span class="c1"># initialization of bottom squares: sep_i -&gt; bottom position</span>
        <span class="n">sep_bottom_pos</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">bot</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">:</span>
                <span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span>
                <span class="n">w</span> <span class="o">+=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c1"># build the permutation r</span>
        <span class="n">lx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">lx</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

        <span class="c1"># build permutation u with the given twists</span>
        <span class="n">ly</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">_</span><span class="p">,</span><span class="n">top_seps</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="c1"># everything excepted the top</span>
            <span class="n">ly</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>

            <span class="c1"># the top</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">top_seps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">top</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">lengths</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">top_seps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">top</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">sep_bottom_pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">lengths</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
            <span class="n">ly</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">top</span><span class="p">[</span><span class="n">twists</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">+</span> <span class="n">top</span><span class="p">[:</span><span class="n">twists</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="c1"># yield the one without twist</span>
        <span class="k">return</span> <span class="n">Origami_dense_pyx</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lx</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ly</span><span class="p">))</span></div>


<div class="viewcode-block" id="CylinderDiagram.cylinder_graph">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.CylinderDiagram.cylinder_graph">[docs]</a>
    <span class="k">def</span> <span class="nf">cylinder_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cylinder graph.</span>

<span class="sd">        The cylinder graph is the graph whose vertex set are the cylinders</span>
<span class="sd">        and for each saddle connection there is a directed edge from the</span>
<span class="sd">        adjacent cylinders. The multiplicities are encoded in the labels.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import CylinderDiagram</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,5)-(2,5) (2)-(0,1,3) (3,4)-(4)&#39;)</span>
<span class="sd">            sage: c.cylinder_graph()</span>
<span class="sd">            Looped digraph on 3 vertices</span>
<span class="sd">            sage: c.cylinder_graph().edges(sort=True)</span>
<span class="sd">            [(0, 0, 1), (0, 1, 1), (1, 0, 2), (1, 2, 1), (2, 2, 1)]</span>

<span class="sd">            sage: c = CylinderDiagram(&#39;(0,1,3,5)-(2,5,3) (2,4)-(0,4,1)&#39;)</span>
<span class="sd">            sage: c.cylinder_graph().edges(sort=True)</span>
<span class="sd">            [(0, 0, 2), (0, 1, 1), (1, 0, 2), (1, 1, 1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bot_to_cyl</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">top_to_cyl</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">bot</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">saddle</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">:</span>
                <span class="n">bot_to_cyl</span><span class="p">[</span><span class="n">saddle</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">saddle</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
                <span class="n">top_to_cyl</span><span class="p">[</span><span class="n">saddle</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_to_cyl</span><span class="p">,</span> <span class="n">bot_to_cyl</span><span class="p">):</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">(),</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">return</span> <span class="n">G</span></div>
</div>


    <span class="c1">#TODO</span>
<span class="c1">#    def chain_complex_dual(self, ring=None):</span>
<span class="c1">#        r&quot;&quot;&quot;</span>
<span class="c1">#        Return a chain complex for the cylinder diagram</span>
<span class="c1">#</span>
<span class="c1">#        The vertices are in bijection with the cylinder of self</span>
<span class="c1">#        The edges are in bijection with separatrices and cylinders</span>
<span class="c1">#</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        from homology import TranslationSurfaceChainComplex</span>
<span class="c1">#        from sage.rings.integer import Integer</span>
<span class="c1">#</span>
<span class="c1">#        if ring is None:</span>
<span class="c1">#            from sage.rings.integer_ring import IntegerRing</span>
<span class="c1">#            ring = IntegerRing()</span>
<span class="c1">#</span>
<span class="c1">#        vertices = []   # list of list of vertex = integers from 0 to ncyls</span>
<span class="c1">#                        # (in or out, edge)</span>
<span class="c1">#        edges = {}      # label -&gt; (start vertex,end)</span>
<span class="c1">#        angles = {}     # (in or out,label) -&gt; angle to next edge</span>
<span class="c1">#</span>
<span class="c1">#        cyls = self.cylinders()</span>
<span class="c1">#        t2c = [None]*self.nseps()</span>
<span class="c1">#        b2c = [None]*self.nseps()</span>
<span class="c1">#</span>
<span class="c1">#        for k,(cb,ct) in enumerate(cyls):</span>
<span class="c1">#            for i in cb: b2c[i] = k</span>
<span class="c1">#            for i in ct: t2c[i] = k</span>
<span class="c1">#</span>
<span class="c1">#        for k,(cb,ct) in enumerate(cyls):</span>
<span class="c1">#            vertex = []</span>
<span class="c1">#            e = &#39;c%d&#39; %k</span>
<span class="c1">#            edges[e] = (k,k)</span>
<span class="c1">#            angles[(1,e)] = Integer(1)/Integer(2)</span>
<span class="c1">#            angles[(-1,e)] = Integer(1)/Integer(2)</span>
<span class="c1">#            # the incoming edges from bottom</span>
<span class="c1">#            for i in cb:</span>
<span class="c1">#                e = &#39;s%d&#39; %i</span>
<span class="c1">#                edges[e] = (t2c[i],k)</span>
<span class="c1">#                vertex.append((-1,e))</span>
<span class="c1">#                angles[(-1,e)] = Integer(0)</span>
<span class="c1">#            angles[(-1,e)] = Integer(1)/Integer(2)</span>
<span class="c1">#</span>
<span class="c1">#            # the central edge (outgoing)</span>
<span class="c1">#            vertex.append((1, &#39;c%d&#39; %k))</span>
<span class="c1">#</span>
<span class="c1">#            # the outgoing edges from top</span>
<span class="c1">#            for i in ct:</span>
<span class="c1">#                e = &#39;s%d&#39; %i</span>
<span class="c1">#                vertex.append((1,e))</span>
<span class="c1">#                angles[(1,e)] = Integer(0)</span>
<span class="c1">#            angles[(1,e)] = Integer(1)/Integer(2)</span>
<span class="c1">#</span>
<span class="c1">#            # the central edge (incoming)</span>
<span class="c1">#            vertex.append((-1, &#39;c%d&#39; %k))</span>
<span class="c1">#</span>
<span class="c1">#            vertices.append(vertex)</span>
<span class="c1">#</span>
<span class="c1">#        return TranslationSurfaceChainComplex(ring,vertices,edges,angles)</span>


<div class="viewcode-block" id="move_forward">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.move_forward">[docs]</a>
<span class="k">def</span> <span class="nf">move_forward</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">g01</span><span class="p">,</span> <span class="n">g23</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to build pillowcase covers</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics.flat_surfaces.separatrix_diagram import move_forward</span>
<span class="sd">        sage: g23 = [1,2,0]</span>
<span class="sd">        sage: g01 = [2,0,1]</span>
<span class="sd">        sage: i,v = 0,0</span>
<span class="sd">        sage: for _ in range(6):</span>
<span class="sd">        ....:     i,v = move_forward(i, v, g01, g23)</span>
<span class="sd">        ....:     print(&quot;%d %d&quot; % (i,v))</span>
<span class="sd">        0 1</span>
<span class="sd">        1 0</span>
<span class="sd">        1 1</span>
<span class="sd">        2 0</span>
<span class="sd">        2 1</span>
<span class="sd">        0 0</span>

<span class="sd">        sage: i,v = 0,2</span>
<span class="sd">        sage: for _ in range(6):</span>
<span class="sd">        ....:     i,v = move_forward(i, v, g01, g23)</span>
<span class="sd">        ....:     print(&quot;%d %d&quot; % (i,v))</span>
<span class="sd">        0 3</span>
<span class="sd">        2 2</span>
<span class="sd">        2 3</span>
<span class="sd">        1 2</span>
<span class="sd">        1 3</span>
<span class="sd">        0 2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g23</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g01</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="k">return</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span></div>


<div class="viewcode-block" id="move_backward">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.move_backward">[docs]</a>
<span class="k">def</span> <span class="nf">move_backward</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">g01</span><span class="p">,</span> <span class="n">g23</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to build pillowcase covers</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics.flat_surfaces.separatrix_diagram import move_backward</span>
<span class="sd">        sage: g23 = [1,2,0]</span>
<span class="sd">        sage: g01 = [2,0,1]</span>
<span class="sd">        sage: i,v = 0,0</span>
<span class="sd">        sage: for _ in range(6):</span>
<span class="sd">        ....:     i,v = move_backward(i, v, g01, g23)</span>
<span class="sd">        ....:     print(&quot;%d %d&quot; % (i,v))</span>
<span class="sd">        2 1</span>
<span class="sd">        2 0</span>
<span class="sd">        1 1</span>
<span class="sd">        1 0</span>
<span class="sd">        0 1</span>
<span class="sd">        0 0</span>

<span class="sd">        sage: i,v = 0,2</span>
<span class="sd">        sage: for _ in range(6):</span>
<span class="sd">        ....:     i,v = move_backward(i, v, g01, g23)</span>
<span class="sd">        ....:     print(&quot;%d %d&quot; % (i,v))</span>
<span class="sd">        1 3</span>
<span class="sd">        1 2</span>
<span class="sd">        2 3</span>
<span class="sd">        2 2</span>
<span class="sd">        0 3</span>
<span class="sd">        0 2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g01</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g23</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="k">return</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span></div>


<div class="viewcode-block" id="simplex_count">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.simplex_count">[docs]</a>
<span class="k">def</span> <span class="nf">simplex_count</span><span class="p">(</span><span class="n">rays</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics.flat_surfaces.separatrix_diagram import simplex_count</span>

<span class="sd">        sage: rays = [(0,1,1), (1,0,1), (1,1,0)]</span>
<span class="sd">        sage: simplex_count(rays)</span>
<span class="sd">        1</span>

<span class="sd">        sage: rays = [(0,1,1), (1,0,1), (1,1,0)]</span>
<span class="sd">        sage: simplex_count(rays)</span>
<span class="sd">        1</span>

<span class="sd">        sage: rays = [(0,1,1,1),(1,0,1,1),(1,1,0,1),(1,1,1,0)]</span>
<span class="sd">        sage: simplex_count(rays)</span>
<span class="sd">        1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sage.geometry.polyhedron.constructor</span> <span class="kn">import</span> <span class="n">Polyhedron</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Polyhedron</span><span class="p">([[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">rays</span><span class="p">))</span><span class="o">.</span><span class="n">integral_points_count</span><span class="p">()</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rays</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticCylinderDiagram">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.QuadraticCylinderDiagram">[docs]</a>
<span class="k">class</span> <span class="nc">QuadraticCylinderDiagram</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cylinder diagram for quadratic differentials</span>

<span class="sd">    Cylinder diagrams are encoded as a Ribbon graph together with a pairing of</span>
<span class="sd">    faces (in particular the number of faces must be even).</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">    If you start with strings, the cylinders are preserved but the names of</span>
<span class="sd">    saddle connections are changed::</span>

<span class="sd">        sage: QuadraticCylinderDiagram(&#39;(4,4,5)-(6,6,1) (2,3,2,0)-(1,0,5,3)&#39;)</span>
<span class="sd">        (0,0,1)-(2,2,3) (4,5,4,6)-(3,6,1,5)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT: there are two input formats</span>

<span class="sd">        - with a unique argument</span>

<span class="sd">        - with two arguments</span>

<span class="sd">        - ``g`` -- a ribbon graph</span>

<span class="sd">        - ``pairing`` -- the pairing of faces of g (= permutation)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.homology</span> <span class="kn">import</span> <span class="n">RibbonGraph</span>

        <span class="k">if</span> <span class="n">arg2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">string_to_cycle</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="n">string_to_cycle</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">arg1</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">arg1</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;input must be a list of pairs&#39;</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
                <span class="n">N</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">N</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;each symbol must appear exactly twice&#39;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;symbol out of range&#39;</span><span class="p">)</span>

            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># constructing p (= face matching)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>

                <span class="c1"># constructing edges and faces</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">bt</span><span class="p">:</span>
                    <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">))))</span>

                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)):</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">seen</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">seen</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;number </span><span class="si">%d</span><span class="s1"> appears more than twice&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
                            <span class="n">kk</span> <span class="o">=</span> <span class="n">seen</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                            <span class="n">edges</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">j</span>
                            <span class="n">edges</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">kk</span>
                            <span class="n">seen</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">seen</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">j</span>

                    <span class="n">k</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

            <span class="n">g</span> <span class="o">=</span> <span class="n">RibbonGraph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="n">faces</span><span class="p">,</span> <span class="n">connected</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">arg1</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">arg2</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">RibbonGraph</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">perm_init</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_g</span> <span class="o">=</span> <span class="n">g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p</span> <span class="o">=</span> <span class="n">p</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face_to_cylinder_index</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">num_faces</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">fc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">fc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">num_faces</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">f</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the number of faces of the fatgraph must be even&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the pairing has wrong length&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the pairing is not an involution&#39;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.graphs.graph</span> <span class="kn">import</span> <span class="n">Graph</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">_total_darts</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">_active_darts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">):</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">_face_cycles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">k2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">_face_cycles</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">is_connected</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the graph is not connected&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="QuadraticCylinderDiagram.num_darts">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.QuadraticCylinderDiagram.num_darts">[docs]</a>
    <span class="k">def</span> <span class="nf">num_darts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of darts</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">num_darts</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuadraticCylinderDiagram.num_edges">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.QuadraticCylinderDiagram.num_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span></div>


    <span class="n">nseps</span> <span class="o">=</span> <span class="n">num_edges</span>

<div class="viewcode-block" id="QuadraticCylinderDiagram.edges">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.QuadraticCylinderDiagram.edges">[docs]</a>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The set of edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuadraticCylinderDiagram.num_cylinders">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.QuadraticCylinderDiagram.num_cylinders">[docs]</a>
    <span class="k">def</span> <span class="nf">num_cylinders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of cylinders.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span></div>


    <span class="n">ncyls</span> <span class="o">=</span> <span class="n">num_cylinders</span>

<div class="viewcode-block" id="QuadraticCylinderDiagram.stratum">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.QuadraticCylinderDiagram.stratum">[docs]</a>
    <span class="k">def</span> <span class="nf">stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the stratum of quadratic differentials associated to this cylinder diagram</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: QuadraticCylinderDiagram(&#39;(0,0)-(1,1)&#39;).stratum()</span>
<span class="sd">            Q_0(-1^4)</span>

<span class="sd">            sage: QuadraticCylinderDiagram(&#39;(0,0)-(1,1,2,2,3,3)&#39;).stratum()</span>
<span class="sd">            Q_0(1, -1^5)</span>

<span class="sd">            sage: QuadraticCylinderDiagram(&#39;(0,2,3,2)-(1,0,1,3)&#39;).stratum()</span>
<span class="sd">            Q_2(2^2)</span>

<span class="sd">            sage: QuadraticCylinderDiagram(&#39;(0,1)-(2,3) (0)-(4,4) (1)-(5,5) (2)-(6,6) (3)-(7,7)&#39;).stratum()</span>
<span class="sd">            Q_0(2^2, -1^8)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.quadratic_strata</span> <span class="kn">import</span> <span class="n">QuadraticStratum</span>
        <span class="k">return</span> <span class="n">QuadraticStratum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">_vertex_cycles</span><span class="p">])</span></div>


<div class="viewcode-block" id="QuadraticCylinderDiagram.cylinders">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.QuadraticCylinderDiagram.cylinders">[docs]</a>
    <span class="k">def</span> <span class="nf">cylinders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dart</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cylinders of self</span>

<span class="sd">        Return a list of pairs ``(bot, top)`` where, by convention the bottom</span>
<span class="sd">        corresponds to the face with smaller index in the list of faces.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>
<span class="sd">            sage: from surface_dynamics.flat_surfaces.separatrix_diagram import QuadraticCylinderDiagram</span>
<span class="sd">            sage: rg = RibbonGraph(edges=&#39;(0,1)(2,3)(4,5)(6,7)&#39;, faces=&#39;(0,1)(2,4,5)(3)(6,7)&#39;, connected=False)</span>
<span class="sd">            sage: q = QuadraticCylinderDiagram(rg, &#39;(0,1)(2,3)&#39;)</span>
<span class="sd">            sage: q.cylinders()</span>
<span class="sd">            [((0, 0), (1, 2, 2)), ((1,), (3, 3))]</span>
<span class="sd">            sage: q.cylinders(True)</span>
<span class="sd">            [((0, 1), (2, 4, 5)), ((3,), (6, 7))]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bot</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_face_cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_face_cycles</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dart</span><span class="p">:</span>
                <span class="n">bot</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bot</span><span class="p">)</span>
                <span class="n">top</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bot</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_dart_to_edge_index</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">)</span>
                <span class="n">top</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_dart_to_edge_index</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">top</span><span class="p">)</span>
            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ans</span></div>


    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>
<span class="sd">            sage: from surface_dynamics.flat_surfaces.separatrix_diagram import QuadraticCylinderDiagram</span>
<span class="sd">            sage: rg = RibbonGraph(edges=&#39;(0,1)(2,3)(4,5)(6,7)&#39;, faces=&#39;(0,1)(2,4,5)(3)(6,7)&#39;, connected=False)</span>
<span class="sd">            sage: q = QuadraticCylinderDiagram(rg, &#39;(0,1)(2,3)&#39;)</span>
<span class="sd">            sage: q</span>
<span class="sd">            (0,0)-(1,2,2) (1)-(3,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bot</span><span class="p">,</span><span class="n">top</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">():</span>
            <span class="n">bot</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">)</span>
            <span class="n">top</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">top</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;(</span><span class="si">{}</span><span class="s1">)-(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<div class="viewcode-block" id="QuadraticCylinderDiagram.lengths_cone">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.QuadraticCylinderDiagram.lengths_cone">[docs]</a>
    <span class="k">def</span> <span class="nf">lengths_cone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the polytope of admissible lengths.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: rg = RibbonGraph(edges=&#39;(0,1)(2,3)(4,5)(6,7)&#39;, faces=&#39;(0,1)(2,4,5)(3)(6,7)&#39;, connected=False)</span>
<span class="sd">            sage: q = QuadraticCylinderDiagram(rg, &#39;(0,1)(2,3)&#39;)</span>
<span class="sd">            sage: q.stratum()</span>
<span class="sd">            Q_0(1, -1^5)</span>
<span class="sd">            sage: q.lengths_cone().rays_list()</span>
<span class="sd">            [[1, 0, 1, 0], [1, 2, 0, 1]]</span>

<span class="sd">            sage: rg = RibbonGraph(edges=&#39;(0,1)(2,3)(4,5)(6,7)&#39;, faces=&#39;(0,2,3)(1)(4,6,7)(5)&#39;, connected=False)</span>
<span class="sd">            sage: q = QuadraticCylinderDiagram(rg, &#39;(0,2)(1,3)&#39;)</span>

<span class="sd">            sage: rg = RibbonGraph(edges=&#39;(1,2)(3,4)(5,6)(7,8)(9,10)(11,12)&#39;, faces=&#39;(1,2)(3,4,6)(5)(8)(7,9,10)(11,12)&#39;, connected=False)</span>
<span class="sd">            sage: q = QuadraticCylinderDiagram(rg, &#39;(0,1)(2,4)(3,5)&#39;)</span>
<span class="sd">            sage: q.stratum()</span>
<span class="sd">            Q_0(1^2, -1^6)</span>
<span class="sd">            sage: L = q.lengths_cone()</span>
<span class="sd">            sage: L</span>
<span class="sd">            A 3-dimensional polyhedron in QQ^6 defined as the convex hull of 1 vertex and 3 rays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>

        <span class="n">ieqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eqns</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># lengths are non-negative</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span><span class="p">()]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
            <span class="n">ieqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">[:])</span>
            <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="c1"># for each cylinder, length top = length bot</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span><span class="p">()]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">:</span>
                <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
                <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
            <span class="n">eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.geometry.polyhedron.constructor</span> <span class="kn">import</span> <span class="n">Polyhedron</span>
        <span class="k">return</span> <span class="n">Polyhedron</span><span class="p">(</span><span class="n">eqns</span><span class="o">=</span><span class="n">eqns</span><span class="p">,</span> <span class="n">ieqs</span><span class="o">=</span><span class="n">ieqs</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticCylinderDiagram.widths_generating_series">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.QuadraticCylinderDiagram.widths_generating_series">[docs]</a>
    <span class="k">def</span> <span class="nf">widths_generating_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generating series of the number of saddle connection lengths of this quadratic</span>
<span class="sd">        differential cylinder diagram.</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">            When a triangulation is involved, the generating series ignore</span>
<span class="sd">            some lower dimensional polytopes that are counted twice!</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,1,2,3,3)-(0,4,4,2,1)&#39;)</span>
<span class="sd">            sage: q.widths_generating_series()  # optional -- latte_int</span>
<span class="sd">            (1)/((1 - w)^3*(1 - w^2))</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,0,1,1,2,2)-(3,3,4,4)&#39;)</span>
<span class="sd">            sage: q.widths_generating_series()  # optional -- latte_int</span>
<span class="sd">            (3)/((1 - w^2)^4)</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,0,1)-(2,2,3) (1,4)-(3,4)&#39;)</span>
<span class="sd">            sage: q.widths_generating_series()  # optional -- latte_int</span>
<span class="sd">            (1)/((1 - w1)*(1 - w0*w1)*(1 - w0^2))</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,0,1,2,3)-(1,4,4,5,6) (2,5,7,7,8)-(3,6,8,9,9)&#39;)</span>
<span class="sd">            sage: F = q.widths_generating_series()  # optional -- latte_int</span>
<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,0,1,2,3)-(1,4,4,5,6) (2,5,7,8,8)-(3,6,7,9,9)&#39;)</span>
<span class="sd">            sage: F = q.widths_generating_series()  # optional -- latte_int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">matrix</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.misc.multiplicative_multivariate_generating_series</span> <span class="kn">import</span> <span class="n">MultiplicativeMultivariateGeneratingSeriesRing</span>
        <span class="kn">from</span> <span class="nn">sage.geometry.polyhedron.constructor</span> <span class="kn">import</span> <span class="n">Polyhedron</span>

        <span class="n">sub1</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())]</span>
        <span class="n">sub2</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">())]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">top</span><span class="p">,</span><span class="n">bot</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
                <span class="n">sub1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">:</span>
                <span class="n">sub2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseps</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">MultiplicativeMultivariateGeneratingSeriesRing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">(),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">free_module</span><span class="p">()</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rays</span> <span class="ow">in</span> <span class="n">cone_triangulate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lengths_cone</span><span class="p">()):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rays</span><span class="p">)</span> <span class="o">==</span> <span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">simplex_count</span><span class="p">(</span><span class="n">rays</span><span class="p">)</span>

            <span class="n">den1</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">den2</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rays</span><span class="p">:</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sub1</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">l1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sub2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">l2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">V</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
                <span class="n">v1</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">V</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
                <span class="n">v2</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">den1</span><span class="p">:</span>
                    <span class="n">den1</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">den1</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">den2</span><span class="p">:</span>
                    <span class="n">den2</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">den2</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">f1</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">term</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">den1</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">term</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">den2</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

            <span class="k">assert</span> <span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span><span class="p">,</span> <span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>

            <span class="n">ans</span> <span class="o">+=</span> <span class="n">f1</span>

        <span class="k">return</span> <span class="n">ans</span></div>


    <span class="k">def</span> <span class="nf">_lengths_to_dart_x_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lengths</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics.flat_surfaces.separatrix_diagram import QuadraticCylinderDiagram</span>
<span class="sd">            sage: from surface_dynamics import *</span>
<span class="sd">            sage: r = RibbonGraph(vertices=&#39;(0,3,1,2)(4,7,5,6)&#39;,</span>
<span class="sd">            ....:                 edges=&#39;(0,1)(2,3)(4,5)(6,7)&#39;,</span>
<span class="sd">            ....:                 faces=&#39;(0,3,1,2)(4,7,5,6)&#39;, connected=False)</span>
<span class="sd">            sage: q = QuadraticCylinderDiagram(r, [1,0])</span>
<span class="sd">            sage: q._lengths_to_dart_x_coords(lengths=[2,2,2,2])</span>
<span class="sd">            [0, 4, 6, 2, 0, 4, 6, 2]</span>
<span class="sd">            sage: q._lengths_to_dart_x_coords(lengths=[1,2,3,4])</span>
<span class="sd">            [0, 3, 4, 1, 0, 7, 10, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span>
        <span class="n">dart_x_coords</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">num_darts</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">faces</span><span class="p">():</span>
            <span class="n">dart_x_coords</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">_dart_to_edge_index</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)):</span>
                <span class="n">dart_x_coords</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">w</span>
                <span class="n">w</span> <span class="o">+=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">_dart_to_edge_index</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
        <span class="k">return</span> <span class="n">dart_x_coords</span>

    <span class="k">def</span> <span class="nf">_cylcoord_dart_to_corner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dart_x_coords</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">twists</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics.flat_surfaces.separatrix_diagram import QuadraticCylinderDiagram</span>
<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        The pillow::</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,0)-(1,1)&#39;)</span>
<span class="sd">            sage: x = q._lengths_to_dart_x_coords([1, 1])</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [1], [0])</span>
<span class="sd">            [0, 1, 3, 2]</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [1], [1])</span>
<span class="sd">            [0, 1, 2, 3]</span>
<span class="sd">            sage: x = q._lengths_to_dart_x_coords([2, 2])</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [1], [0])</span>
<span class="sd">            [0, 0, 3, 3]</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [1], [1])</span>
<span class="sd">            [0, 0, 2, 2]</span>

<span class="sd">        An example in `Q(2^2)` (everything is authorized)::</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,1,0,1)-(2,3,2,3)&#39;)</span>
<span class="sd">            sage: x = q._lengths_to_dart_x_coords([2,2,2,2])</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [1], [0])</span>
<span class="sd">            [0, 0, 0, 0, 3, 3, 3, 3]</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [1], [1])</span>
<span class="sd">            [0, 0, 0, 0, 2, 2, 2, 2]</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [2], [0])</span>
<span class="sd">            [0, 0, 0, 0, 0, 0, 0, 0]</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [2], [1])</span>
<span class="sd">            [0, 0, 0, 0, 1, 1, 1, 1]</span>

<span class="sd">        Another example in `Q(2^2)`::</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,2,0,3)-(1,2,1,3)&#39;)</span>
<span class="sd">            sage: x = q._lengths_to_dart_x_coords([1,2,2,1])</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [2], [0])</span>
<span class="sd">            [0, 1, 1, 0, 0, 1, 1, 0]</span>

<span class="sd">        An example in `Q(3, -1^3)`::</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,1,1)-(0,2,2,3,3)&#39;)</span>
<span class="sd">            sage: x = q._lengths_to_dart_x_coords([2, 1, 1, 1])</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [2], [0])</span>
<span class="sd">            [0, 0, 1, 0, 0, 1, 0, 1]</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [1], [0])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: invalid lengths/heights/twists</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [1], [1])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: invalid lengths/heights/twists</span>

<span class="sd">        An example in `Q(4, 2, -1^2)`::</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,1,0,2)-(1,3,4,3) (2,4)-(5,5)&#39;)</span>
<span class="sd">            sage: x = q._lengths_to_dart_x_coords([1, 2, 2, 1, 2, 2])</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [2, 1], [1, 0])</span>
<span class="sd">            [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 3, 3]</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [2, 1], [1, 1])</span>
<span class="sd">            [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 2, 2]</span>
<span class="sd">            sage: q._cylcoord_dart_to_corner(x, [2, 1], [0, 0])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: invalid lengths/heights/twists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span>
        <span class="c1"># pillowcase vertices</span>
        <span class="n">dart_to_corner</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">num_darts</span><span class="p">()</span>  <span class="c1"># which vertex of the pillowcase the attached</span>
        <span class="n">dart_to_corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># dart from which we should complete vertices and faces</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># dart from which we should cross cylinders</span>
        <span class="k">while</span> <span class="n">todo</span> <span class="ow">or</span> <span class="n">cross</span><span class="p">:</span>

            <span class="c1"># 1. completing vertices and faces</span>
            <span class="k">while</span> <span class="n">todo</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;** new loop **&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  i = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  dart_to_corner = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dart_to_corner</span><span class="p">))</span>

                <span class="n">v</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">vertex_orbit</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                        <span class="n">todo</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;i = </span><span class="si">{}</span><span class="s1"> j = </span><span class="si">{}</span><span class="s1"> dart_to_corner[</span><span class="si">{}</span><span class="s1">] = </span><span class="si">{}</span><span class="s1"> dart_to_corner[</span><span class="si">{}</span><span class="s1">] = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid lengths/heights/twists&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done completing vertex&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  dart_to_corner = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dart_to_corner</span><span class="p">))</span>

                <span class="n">f</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">face_orbit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">dart_x_coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dart_x_coords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                            <span class="n">todo</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;i = </span><span class="si">{}</span><span class="s1"> j = </span><span class="si">{}</span><span class="s1"> dart_to_corner[</span><span class="si">{}</span><span class="s1">] = </span><span class="si">{}</span><span class="s1"> dart_to_corner[</span><span class="si">{}</span><span class="s1">] = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid lengths/heights/twists&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># 0 &lt;-&gt; 1 and 2 &lt;-&gt; 3</span>
                        <span class="n">vv</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">vv</span>
                            <span class="n">todo</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vv</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;j = </span><span class="si">{}</span><span class="s1"> dart_to_corner[</span><span class="si">{}</span><span class="s1">] = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid lengths/heights/twists&#39;</span><span class="p">)</span>

                <span class="n">cross</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done completing face&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  dart_to_corner = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dart_to_corner</span><span class="p">))</span>

            <span class="c1"># 2. crossing cylinders</span>
            <span class="k">while</span> <span class="n">cross</span><span class="p">:</span>
                <span class="c1"># i: dart index</span>
                <span class="c1"># j: face index</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">cross</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">_dart_to_face_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_face_to_cylinder_index</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">_face_cycles</span><span class="p">[</span><span class="n">jj</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">vv</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">if</span> <span class="n">heights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># 0 &lt;-&gt; 3 and 1 &lt;-&gt; 2</span>
                    <span class="n">vv</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">vv</span>
                <span class="k">if</span> <span class="n">twists</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># 0 &lt;-&gt; 1 and 2 &lt;-&gt; 3</span>
                    <span class="n">vv</span> <span class="o">=</span> <span class="n">vv</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">vv</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;crossing cylinder from i=</span><span class="si">{}</span><span class="s1"> to ii=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ii</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  dart </span><span class="si">{}</span><span class="s1"> is above pillow vertex </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  dart </span><span class="si">{}</span><span class="s1"> is above pillow vertex </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">vv</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">vv</span>
                    <span class="n">todo</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vv</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ii = </span><span class="si">{}</span><span class="s1"> dart_to_corner[</span><span class="si">{}</span><span class="s1">] = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid lengths/heights/twists&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done crossing cylinder </span><span class="si">{}</span><span class="s1"> from dart </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  dart_to_corner = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dart_to_corner</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dart_to_corner: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dart_to_corner</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dart_to_corner</span>

    <span class="c1"># figure out whether this awfull method is really useful...</span>
    <span class="c1"># square tiled quadratic surface would be much more simple to handle</span>
<div class="viewcode-block" id="QuadraticCylinderDiagram.cylcoord_to_pillowcase_cover">
<a class="viewcode-back" href="../../../surface_topology.html#surface_dynamics.flat_surfaces.separatrix_diagram.QuadraticCylinderDiagram.cylcoord_to_pillowcase_cover">[docs]</a>
    <span class="k">def</span> <span class="nf">cylcoord_to_pillowcase_cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">twists</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert coordinates of the cylinders into a pillowcase cover.</span>

<span class="sd">        The pillow is considered as made of two 1 x 1 squares in order to avoid denominators</span>
<span class="sd">        in the input ``lengths``, ``heights`` and ``twists``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``lengths`` - positive integers - lengths of the separatrices</span>

<span class="sd">        - ``heights`` - positive integers - heights of the cylinders</span>

<span class="sd">        - ``twists`` - (optional) non-negative integers - twists. The twist</span>
<span class="sd">          is measured as the difference in horizontal coordinates between</span>
<span class="sd">          the smallest element in bottom and the smallest in element in top.</span>

<span class="sd">        OUTPUT: a pillowcase cover</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        Some pillows in `Q(-1^4)`::</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,0)-(1,1)&#39;)</span>
<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([1,1],[1],[0])</span>
<span class="sd">            g0 = (1)</span>
<span class="sd">            g1 = (1)</span>
<span class="sd">            g2 = (1)</span>
<span class="sd">            g3 = (1)</span>
<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([1,1],[1],[1])</span>
<span class="sd">            g0 = (1)</span>
<span class="sd">            g1 = (1)</span>
<span class="sd">            g2 = (1)</span>
<span class="sd">            g3 = (1)</span>
<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([2,2],[1],[0])</span>
<span class="sd">            g0 = (1)(2)</span>
<span class="sd">            g1 = (1,2)</span>
<span class="sd">            g2 = (1,2)</span>
<span class="sd">            g3 = (1)(2)</span>
<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([2,2],[1],[1])</span>
<span class="sd">            g0 = (1)(2)</span>
<span class="sd">            g1 = (1,2)</span>
<span class="sd">            g2 = (1)(2)</span>
<span class="sd">            g3 = (1,2)</span>
<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([2,2],[1],[2]) == q.cylcoord_to_pillowcase_cover([2,2],[1],[2])</span>
<span class="sd">            True</span>
<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([3,3],[1],[0])</span>
<span class="sd">            g0 = (1)(2,3)</span>
<span class="sd">            g1 = (1,3)(2)</span>
<span class="sd">            g2 = (1,3)(2)</span>
<span class="sd">            g3 = (1)(2,3)</span>
<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([3,3],[1],[1])</span>
<span class="sd">            g0 = (1)(2,3)</span>
<span class="sd">            g1 = (1,3)(2)</span>
<span class="sd">            g2 = (1)(2,3)</span>
<span class="sd">            g3 = (1,2)(3)</span>

<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([1,1],[2],[0])</span>
<span class="sd">            g0 = (1)(2)</span>
<span class="sd">            g1 = (1)(2)</span>
<span class="sd">            g2 = (1,2)</span>
<span class="sd">            g3 = (1,2)</span>
<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([1,1],[2],[1]) == q.cylcoord_to_pillowcase_cover([1,1],[2],[0])</span>
<span class="sd">            True</span>

<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([2,2],[2],[1])</span>
<span class="sd">            g0 = (1)(2)(3,4)</span>
<span class="sd">            g1 = (1,2)(3)(4)</span>
<span class="sd">            g2 = (1,3)(2,4)</span>
<span class="sd">            g3 = (1,4)(2,3)</span>

<span class="sd">        Two one cylinder examples in `Q(2^2)`::</span>

<span class="sd">            sage: q1 = QuadraticCylinderDiagram(&#39;(0,1,0,1)-(2,3,2,3)&#39;)</span>
<span class="sd">            sage: q2 = QuadraticCylinderDiagram(&#39;(0,1,0,2)-(3,1,3,2)&#39;)</span>

<span class="sd">            sage: q1.cylcoord_to_pillowcase_cover([2,2,2,2],[1],[0])</span>
<span class="sd">            g0 = (1,2,3,4)</span>
<span class="sd">            g1 = (1,3)(2,4)</span>
<span class="sd">            g2 = (1,3)(2,4)</span>
<span class="sd">            g3 = (1,4,3,2)</span>
<span class="sd">            sage: q1.cylcoord_to_pillowcase_cover([2,2,2,2],[1],[1])</span>
<span class="sd">            g0 = (1,2,3,4)</span>
<span class="sd">            g1 = (1,3)(2,4)</span>
<span class="sd">            g2 = (1,4,3,2)</span>
<span class="sd">            g3 = (1,3)(2,4)</span>
<span class="sd">            sage: p = q1.cylcoord_to_pillowcase_cover([2,6,4,4],[3],[1])</span>
<span class="sd">            sage: p.stratum()</span>
<span class="sd">            Q_2(2^2)</span>
<span class="sd">            sage: p.nb_pillows()</span>
<span class="sd">            24</span>

<span class="sd">        One two cylinders example in `Q(2^2)`::</span>

<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,1)-(2,3) (0,3)-(1,2)&#39;)</span>
<span class="sd">            sage: p = q.cylcoord_to_pillowcase_cover([1,1,1,1], [2,2], [0,1])</span>
<span class="sd">            sage: p</span>
<span class="sd">            g0 = (1,4,2,3)</span>
<span class="sd">            g1 = (1,3,2,4)</span>
<span class="sd">            g2 = (1,2)(3,4)</span>
<span class="sd">            g3 = (1,2)(3,4)</span>
<span class="sd">            sage: p.stratum()</span>
<span class="sd">            Q_2(2^2)</span>
<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([1,3,1,3], [2,2], [0,1]).stratum()</span>
<span class="sd">            Q_2(2^2)</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>
<span class="sd">            sage: q = QuadraticCylinderDiagram(&#39;(0,0)-(1,1)&#39;)</span>
<span class="sd">            sage: q.cylcoord_to_pillowcase_cover([1,2],[1])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: sum of lengths on top and bottom differ</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>

        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">G</span><span class="o">.</span><span class="n">num_edges</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;lengths&#39; has wrong length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cylinders</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;heights&#39; has wrong length&quot;</span><span class="p">)</span>

        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lengths</span><span class="p">]</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heights</span><span class="p">]</span>
        <span class="n">ZZ_zero</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lengths</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">ZZ_zero</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;each length should be positive&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heights</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="n">ZZ_zero</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;each height should be positive&quot;</span><span class="p">)</span>

        <span class="n">widths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bot</span><span class="p">,</span> <span class="n">top</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">(</span><span class="n">dart</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">w1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bot</span><span class="p">)</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">top</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w1</span> <span class="o">!=</span> <span class="n">w2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sum of lengths on top and bottom differ&#39;</span><span class="p">)</span>
            <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span>

        <span class="n">areas</span> <span class="o">=</span> <span class="p">[</span><span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncyls</span><span class="p">())]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>  <span class="c1"># number of squares</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;got an odd area&#39;</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;area = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">twists</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">twists</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ_zero</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cylinders</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">twists</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the &#39;twists&#39; vector has wrong length&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">twists</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">%</span> <span class="n">w</span> <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">twists</span><span class="p">,</span> <span class="n">widths</span><span class="p">)]</span>

        <span class="c1"># now glue the boundaries</span>
        <span class="c1"># (distance with respect to the minimum dart in the face)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lengths_to_dart_x_coords</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
        <span class="n">dart_to_corner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cylcoord_dart_to_corner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">twists</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># building dart_to_pillow</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Constructing dart_to_pillow&#39;</span><span class="p">)</span>
        <span class="n">dart_to_pillow</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">num_darts</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">t</span><span class="p">,(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">twists</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">(</span><span class="kc">True</span><span class="p">)):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;new cylinder (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) w=</span><span class="si">{}</span><span class="s1"> h=</span><span class="si">{}</span><span class="s1"> t=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pillows in [n, n + h*w[ = [</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">[&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">w</span><span class="p">))</span>
            <span class="c1"># pillows in the bottom</span>
            <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">bot</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bot</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">bot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">_dart_to_edge_index</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># changing vertex nature (0 &lt;-&gt; 1, 2 &lt;-&gt; 3)</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  odd length </span><span class="si">{}</span><span class="s1"> for dart </span><span class="si">{}</span><span class="s1"> at (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">nn</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">nn</span> <span class="o">+=</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nn</span> <span class="o">+=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># keeping vertex nature</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  even length </span><span class="si">{}</span><span class="s1"> for dart </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
                    <span class="n">nn</span> <span class="o">+=</span> <span class="n">l</span> <span class="o">//</span> <span class="mi">2</span>

                <span class="k">if</span> <span class="n">nn</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">w</span><span class="p">:</span>
                    <span class="n">nn</span> <span class="o">-=</span> <span class="n">w</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  n=</span><span class="si">{}</span><span class="s1"> w=</span><span class="si">{}</span><span class="s1"> nn = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">nn</span><span class="p">))</span>
                <span class="k">assert</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">nn</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">w</span>
                <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">bot</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nn</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  dart to pillow done on bot&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  dart_to_pillow </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dart_to_pillow</span><span class="p">))</span>

            <span class="c1"># pillow of top[0] (depends on twist)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tadj</span> <span class="o">=</span> <span class="n">t</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">bot</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">tadj</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tadj</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="n">nn</span> <span class="o">=</span> <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">bot</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">tadj</span>
            <span class="k">if</span> <span class="n">nn</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span><span class="p">:</span>
                <span class="n">nn</span> <span class="o">-=</span> <span class="n">w</span>
            <span class="k">assert</span> <span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">nn</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span>
            <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nn</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  crossing cylinder: dart </span><span class="si">{}</span><span class="s1"> at (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                         <span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

            <span class="c1"># other pillows on top</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">_dart_to_edge_index</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># changing vertex nature (0 &lt;-&gt; 1, 2 &lt;-&gt; 3)</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  odd length </span><span class="si">{}</span><span class="s1"> for dart </span><span class="si">{}</span><span class="s1"> at (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">nn</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">nn</span> <span class="o">-=</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nn</span> <span class="o">-=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  ends at </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nn</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># keeping vertex nature</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  even length </span><span class="si">{}</span><span class="s1"> for dart </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
                    <span class="n">nn</span> <span class="o">-=</span> <span class="n">l</span> <span class="o">//</span> <span class="mi">2</span>

                <span class="k">if</span> <span class="n">nn</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">w</span><span class="p">:</span>
                    <span class="n">nn</span> <span class="o">+=</span> <span class="n">w</span>

                <span class="k">assert</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">nn</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span>
                <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nn</span>

            <span class="n">n</span> <span class="o">+=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  dart to pillow done on top&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  dart_to_pillow: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dart_to_pillow</span><span class="p">))</span>
        <span class="c1"># safety check</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dart_to_pillow</span><span class="p">)</span>

        <span class="c1"># fill the cylinders and record the number at a dart</span>
        <span class="c1"># (g01 and g23 correspond to horizontal displacements)</span>
        <span class="n">g0</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="n">g3</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">]</span>
        <span class="n">g01</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>    <span class="c1"># redundant information (will be used to glue edges)</span>
        <span class="n">g23</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>    <span class="c1"># redundant information (will be used to glue edges)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Filling permutations inside cylinders&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">t</span><span class="p">,(</span><span class="n">bot</span><span class="p">,</span><span class="n">top</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">twists</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinders</span><span class="p">(</span><span class="kc">True</span><span class="p">)):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;** new cylinder **&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; w = </span><span class="si">{}</span><span class="s1"> h = </span><span class="si">{}</span><span class="s1"> t = </span><span class="si">{}</span><span class="s1"> n = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

            <span class="n">u</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">bot</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">h0</span> <span class="o">=</span> <span class="n">g0</span>
                <span class="n">h1</span> <span class="o">=</span> <span class="n">g1</span>
                <span class="n">h2</span> <span class="o">=</span> <span class="n">g2</span>
                <span class="n">h3</span> <span class="o">=</span> <span class="n">g3</span>
                <span class="n">h01</span> <span class="o">=</span> <span class="n">g01</span>
                <span class="n">h23</span> <span class="o">=</span> <span class="n">g23</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h0</span> <span class="o">=</span> <span class="n">g2</span>
                <span class="n">h1</span> <span class="o">=</span> <span class="n">g3</span>
                <span class="n">h2</span> <span class="o">=</span> <span class="n">g0</span>
                <span class="n">h3</span> <span class="o">=</span> <span class="n">g1</span>
                <span class="n">h01</span> <span class="o">=</span> <span class="n">g23</span>
                <span class="n">h23</span> <span class="o">=</span> <span class="n">g01</span>


            <span class="c1"># filling all rows but the top one</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  filling row k=</span><span class="si">{}</span><span class="s1"> from n=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">w</span><span class="p">):</span>
                    <span class="n">h2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">w</span>
                    <span class="n">h2</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">h3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">h3</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">h23</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">h01</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

                <span class="c1"># adjustments at the gluings (left and right of the cylinders)</span>
                <span class="n">h3</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">h3</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                <span class="n">h23</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                <span class="n">h01</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="c1"># 3 2  -&gt; 1 0</span>
                <span class="c1"># 0 1     2 3</span>
                <span class="n">h0</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">h3</span> <span class="o">=</span> <span class="n">h2</span><span class="p">,</span> <span class="n">h3</span><span class="p">,</span> <span class="n">h0</span><span class="p">,</span> <span class="n">h1</span>
                <span class="n">h01</span><span class="p">,</span> <span class="n">h23</span> <span class="o">=</span> <span class="n">h23</span><span class="p">,</span> <span class="n">h01</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">w</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  done&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g0 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g0</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g1 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g1</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g2 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g2</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g3 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g3</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g01 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g01</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g23 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g23</span><span class="p">))</span>

            <span class="c1"># top row</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  filling top row from n=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">h23</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">h01</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">h23</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="n">h01</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="n">w</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  done&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g0 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g0</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g1 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g1</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g2 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g2</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g3 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g3</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g01 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g01</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    g23 = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g23</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done filling cylinders:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g0 : </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g0</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g1 : </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g1</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g2 : </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g2</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g3 : </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g3</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g01: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g01</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g23: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g23</span><span class="p">))</span>

        <span class="c1"># safety check</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g2</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g3</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g01</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g23</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">g0</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">g2</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">g3</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

        <span class="c1"># gluing corners</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">_vertex_cycles</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gluing vertex c = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  c[0] = </span><span class="si">{}</span><span class="s1"> at (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  c[</span><span class="si">{}</span><span class="s1">] = </span><span class="si">{}</span><span class="s1"> at (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="k">assert</span> <span class="n">u</span> <span class="o">==</span> <span class="n">v</span>
                <span class="c1"># safety check</span>
                <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done gluing corners&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g0: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g0</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g1: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g1</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g2: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g2</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g3: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g3</span><span class="p">))</span>

        <span class="c1"># safety check</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g2</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g3</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g01</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g23</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">g0</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">g2</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">g3</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

        <span class="c1"># gluing edges</span>
        <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">_edge_cycles</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="c1"># endpoint of first edge</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span> <span class="c1"># endpoint of second edge</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
            <span class="n">u1</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
            <span class="n">j1</span> <span class="o">=</span> <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">t1</span><span class="p">]</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">t1</span><span class="p">]</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span>
            <span class="n">u2</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span>
            <span class="n">j2</span> <span class="o">=</span> <span class="n">dart_to_pillow</span><span class="p">[</span><span class="n">t2</span><span class="p">]</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">dart_to_corner</span><span class="p">[</span><span class="n">t2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gluing edge </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) - </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) to </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) - </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                         <span class="n">s1</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="n">u1</span><span class="p">,</span>
                         <span class="n">t1</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span>
                         <span class="n">s2</span><span class="p">,</span><span class="n">i2</span><span class="p">,</span><span class="n">u2</span><span class="p">,</span>
                         <span class="n">t2</span><span class="p">,</span><span class="n">j2</span><span class="p">,</span><span class="n">v2</span><span class="p">))</span>

            <span class="c1"># safety check</span>
            <span class="k">assert</span> <span class="n">u1</span> <span class="o">==</span> <span class="n">v2</span> <span class="ow">and</span> <span class="n">u2</span> <span class="o">==</span> <span class="n">v1</span>

            <span class="c1"># gluing the central part</span>
            <span class="n">j2</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">move_backward</span><span class="p">(</span><span class="n">j2</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">g01</span><span class="p">,</span> <span class="n">g23</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;MOVE BACKWARD (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j2</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">u1</span> <span class="o">=</span> <span class="n">move_forward</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="n">g01</span><span class="p">,</span> <span class="n">g23</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;MOVE FORWARD (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">u1</span><span class="p">))</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">j2</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span><span class="n">u2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  glue (i1,u1) = (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) and (j2,v2) = (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span>
                <span class="c1"># safety check</span>
                <span class="k">assert</span> <span class="n">u1</span> <span class="o">==</span> <span class="n">v2</span>
                <span class="n">g</span><span class="p">[</span><span class="n">v2</span><span class="p">][</span><span class="n">j2</span><span class="p">]</span> <span class="o">=</span> <span class="n">i1</span>
                <span class="n">g</span><span class="p">[</span><span class="n">v2</span><span class="p">][</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j2</span>
                <span class="n">j2</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">move_backward</span><span class="p">(</span><span class="n">j2</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">g01</span><span class="p">,</span> <span class="n">g23</span><span class="p">)</span>
                <span class="n">i1</span><span class="p">,</span> <span class="n">u1</span> <span class="o">=</span> <span class="n">move_forward</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="n">g01</span><span class="p">,</span> <span class="n">g23</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done gluing edges&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  (i1,u1) = (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">u1</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  (j1,v1) = (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span><span class="n">v1</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  (i2,u2) = (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i2</span><span class="p">,</span><span class="n">u2</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  (j2,v2) = (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j2</span><span class="p">,</span><span class="n">v2</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g0: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g0</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g1: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g1</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g2: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g2</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  g3: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g3</span><span class="p">))</span>

        <span class="c1"># safety check</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">u1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">j1</span><span class="p">,</span><span class="n">v1</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.origamis.pillowcase_cover</span> <span class="kn">import</span> <span class="n">PillowcaseCover</span>
        <span class="k">return</span> <span class="n">PillowcaseCover</span><span class="p">(</span><span class="n">g0</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
</div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2021-2023, the surface-dynamics authors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=1dd76d02"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=4e2eecee"></script>
    </body>
</html>