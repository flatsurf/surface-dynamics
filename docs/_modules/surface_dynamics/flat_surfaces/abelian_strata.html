<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2023.05.20 -->
        <title>surface_dynamics.flat_surfaces.abelian_strata - surface-dynamics 0.4.7 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=e6660623a769aa55fea372102b9bf3151b292993" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="https://doc.sagemath.org/html/en/reference/_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">surface-dynamics 0.4.7 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">surface-dynamics 0.4.7 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/interval_exchanges.html">Interval exchange transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/square_tiled_surfaces.html">Square-tiled surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/rank2_genus3_classification.html">Filtering Possible <span class="math notranslate nohighlight">\(\mathcal M\)</span>-Parallel Classes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../strata.html">Strata of Abelian and quadratic differentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../surface_topology.html">Surface topology and geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../origamis.html">Origamis</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../interval_exchanges/index.html">Interval exchange transformations</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Interval exchange transformations</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/constructors.html">Interval exchange constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/template.html">Permutation template</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/labelled.html">Labelled permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/reduced.html">Reduced permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/rauzy_class_cardinality.html">Rauzy class cardinality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/cover.html">Covering construction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/iet.html">Interval exchange transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/integer_iet.html">Integral interval exchanges</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/iet_family.html">Interval exchange families</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/flip_sequence.html">Flip sequences</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../database.html">Database of cylinder diagrams and quadratic permutations</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../topological_recursion/index.html">Topological recursion</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Topological recursion</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../topological_recursion/topological_recursion.html">Generic topological recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../topological_recursion/kontsevich.html">Kontsevich topological recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../topological_recursion/masur_veech.html">Masur-Veech topological recursion</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../misc/index.html">Miscellaneous</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Miscellaneous</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/constellation.html">Constellations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/group_representation.html">Finite group representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/plane_tree.html">Plane trees</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for surface_dynamics.flat_surfaces.abelian_strata</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Strata of differentials on Riemann surfaces</span>

<span class="sd">The space of Abelian differentials on Riemann surfaces of a given genus is</span>
<span class="sd">stratified by degrees of zeros. Each stratum has one, two or three connected</span>
<span class="sd">components each of which is associated to an extended Rauzy class. The</span>
<span class="sd">:meth:`~surface_dynamics.flat_surfaces.strata.Stratum.components` method</span>
<span class="sd">lists connected components of a stratum.</span>

<span class="sd">The work for Abelian differentials was done by Maxim Kontsevich and Anton</span>
<span class="sd">Zorich in [KonZor03]_ and for quadratic differentials by Erwan Lanneau in</span>
<span class="sd">[Lan08]_. Zorich gave an algorithm to pass from a connected component of a</span>
<span class="sd">stratum to the associated Rauzy class (for both interval exchange</span>
<span class="sd">transformations and linear involutions) in [Zor08]_ and is implemented for</span>
<span class="sd">Abelian stratum at different level (approximately one for each component):</span>

<span class="sd">- for connected stratum :meth:`~AbelianStratumComponent.permutation_representative`</span>

<span class="sd">- for hyperellitic component</span>
<span class="sd">  :meth:`~HypAbelianStratumComponent.permutation_representative`</span>

<span class="sd">- for non hyperelliptic component, the algorithm is the same as for connected</span>
<span class="sd">  component</span>

<span class="sd">- for odd component :meth:`~OddAbelianStratumComponent.permutation_representative`</span>

<span class="sd">- for even component :meth:`~EvenAbelianStratumComponent.permutation_representative`</span>

<span class="sd">The inverse operation (pass from an interval exchange transformation to</span>
<span class="sd">the connected component) is partially written in [KonZor03]_ and</span>
<span class="sd">simply named here</span>
<span class="sd">?</span>

<span class="sd">Some of the code here was first available on Mathematica [ZS]_.</span>

<span class="sd">A refinement of Zorich representatives was worked out by L. Jefreys in</span>
<span class="sd">[Jef19]_. Namely, for each connected component of Abelian differential</span>
<span class="sd">his construction provides a square-tiled surface with both in horizontal</span>
<span class="sd">and vertical direction a decomposition with single cylinder of height one.</span>
<span class="sd">The implementation is available as</span>

<span class="sd">- for connected stratum :meth:`~AbelianStratumComponent.single_cylinder_representative`</span>

<span class="sd">- for hyperelliptic component</span>
<span class="sd">  :meth:`~HypAbelianStratumComponent.single_cylinder_representative`</span>

<span class="sd">- for odd component :meth:`~OddAbelianStratumComponent.single_cylinder_representative`</span>

<span class="sd">- for even component :meth:`~EvenAbelianStratumComponent.single_cylinder_representative`</span>

<span class="sd">AUTHORS:</span>

<span class="sd">- Vincent Delecroix (2009-09-29): initial version</span>

<span class="sd">EXAMPLES:</span>

<span class="sd">    sage: from surface_dynamics import *</span>

<span class="sd">Construction of a stratum from a list of singularity degrees::</span>

<span class="sd">    sage: a = AbelianStratum(1,1)</span>
<span class="sd">    sage: a</span>
<span class="sd">    H_2(1^2)</span>
<span class="sd">    sage: a.genus()</span>
<span class="sd">    2</span>
<span class="sd">    sage: a.dimension()</span>
<span class="sd">    5</span>

<span class="sd">::</span>

<span class="sd">    sage: a = AbelianStratum(4,3,2,1)</span>
<span class="sd">    sage: a</span>
<span class="sd">    H_6(4, 3, 2, 1)</span>
<span class="sd">    sage: a.genus()</span>
<span class="sd">    6</span>
<span class="sd">    sage: a.dimension()</span>
<span class="sd">    15</span>

<span class="sd">By convention, the degrees are always written in decreasing order::</span>

<span class="sd">    sage: a1 = AbelianStratum(4,3,2,1)</span>
<span class="sd">    sage: a1</span>
<span class="sd">    H_6(4, 3, 2, 1)</span>
<span class="sd">    sage: a2 = AbelianStratum(2,3,1,4)</span>
<span class="sd">    sage: a2</span>
<span class="sd">    H_6(4, 3, 2, 1)</span>
<span class="sd">    sage: a1 == a2</span>
<span class="sd">    True</span>

<span class="sd">It is possible to lis strata and their connected components::</span>

<span class="sd">    sage: AbelianStratum(10).components()</span>
<span class="sd">    [H_6(10)^hyp, H_6(10)^odd, H_6(10)^even]</span>

<span class="sd">Get a list of strata with constraints on genus or on the number of intervals</span>
<span class="sd">of a representative::</span>

<span class="sd">    sage: AbelianStrata(genus=3).list()</span>
<span class="sd">    [H_3(4), H_3(3, 1), H_3(2^2), H_3(2, 1^2), H_3(1^4)]</span>

<span class="sd">Obtains the connected components of a stratum::</span>

<span class="sd">    sage: a = AbelianStratum(0)</span>
<span class="sd">    sage: a.components()</span>
<span class="sd">    [H_1(0)^hyp]</span>

<span class="sd">::</span>

<span class="sd">    sage: @cached_function</span>
<span class="sd">    ....: def nb_irred_perm(n):</span>
<span class="sd">    ....:     if n == 0 or n == 1: return 1</span>
<span class="sd">    ....:     return factorial(n) - sum(nb_irred_perm(k) * factorial(n - k) for k in range(1,n))</span>
<span class="sd">    sage: [nb_irred_perm(i) for i in range(10)]</span>
<span class="sd">    [1, 1, 1, 3, 13, 71, 461, 3447, 29093, 273343]</span>

<span class="sd">::</span>

<span class="sd">    sage: A = AbelianStrata(dimension=5, fake_zeros=True)</span>
<span class="sd">    sage: N = 0</span>
<span class="sd">    sage: for a in A:</span>
<span class="sd">    ....:    for cc in a.components():</span>
<span class="sd">    ....:       for z in set(a.zeros()):</span>
<span class="sd">    ....:           p = cc.permutation_representative(left_degree=z)</span>
<span class="sd">    ....:           n = p.rauzy_diagram().cardinality()</span>
<span class="sd">    ....:           print(&quot;%13s, %d  :  %d&quot;%(cc, z, n))</span>
<span class="sd">    ....:           print(p)</span>
<span class="sd">    ....:           N += n</span>
<span class="sd">    H_2(2, 0)^hyp, 0  :  11</span>
<span class="sd">    0 1 2 3 4</span>
<span class="sd">    4 2 1 3 0</span>
<span class="sd">    H_2(2, 0)^hyp, 2  :  35</span>
<span class="sd">    0 1 2 3 4</span>
<span class="sd">    4 1 3 2 0</span>
<span class="sd">     H_2(1^2)^hyp, 1  :  15</span>
<span class="sd">    0 1 2 3 4</span>
<span class="sd">    4 3 2 1 0</span>
<span class="sd">     H_1(0^4)^hyp, 0  :  10</span>
<span class="sd">    0 1 2 3 4</span>
<span class="sd">    4 0 1 2 3</span>
<span class="sd">    sage: N</span>
<span class="sd">    71</span>
<span class="sd">    sage: nb_irred_perm(5)</span>
<span class="sd">    71</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#*****************************************************************************</span>
<span class="c1">#       Copyright (C) 2009-2019 Vincent Delecroix &lt;20100.delecroix@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1">#  Distributed under the terms of the GNU General Public License (GPL)</span>
<span class="c1">#  as published by the Free Software Foundation; either version 2 of</span>
<span class="c1">#  the License, or (at your option) any later version.</span>
<span class="c1">#                  https://www.gnu.org/licenses/</span>
<span class="c1">#*****************************************************************************</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">iteritems</span>

<span class="kn">import</span> <span class="nn">numbers</span>

<span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">UniqueRepresentation</span>
<span class="kn">from</span> <span class="nn">sage.structure.parent</span> <span class="kn">import</span> <span class="n">Parent</span>
<span class="kn">from</span> <span class="nn">sage.categories.finite_enumerated_sets</span> <span class="kn">import</span> <span class="n">FiniteEnumeratedSets</span>
<span class="kn">from</span> <span class="nn">sage.categories.infinite_enumerated_sets</span> <span class="kn">import</span> <span class="n">InfiniteEnumeratedSets</span>

<span class="kn">from</span> <span class="nn">sage.combinat.partition</span> <span class="kn">import</span> <span class="n">Partitions</span><span class="p">,</span> <span class="n">Partition</span>
<span class="kn">from</span> <span class="nn">sage.rings.integer</span> <span class="kn">import</span> <span class="n">Integer</span>
<span class="kn">from</span> <span class="nn">sage.rings.rational</span> <span class="kn">import</span> <span class="n">Rational</span>
<span class="kn">from</span> <span class="nn">sage.rings.infinity</span> <span class="kn">import</span> <span class="n">Infinity</span>

<span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.strata</span> <span class="kn">import</span> <span class="n">Stratum</span><span class="p">,</span> <span class="n">StratumComponent</span><span class="p">,</span> <span class="n">Strata</span>

<span class="k">def</span> <span class="nf">_cylinder_diagrams_with_symmetric</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterate through all possible reflections of the cylinder diagrams in ``iterator``.</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from surface_dynamics import CylinderDiagram</span>
<span class="sd">        sage: from surface_dynamics.flat_surfaces.abelian_strata import _cylinder_diagrams_with_symmetric</span>

<span class="sd">        sage: cd_000 = CylinderDiagram(&quot;(0,1)-(0,3,4) (2,3)-(1) (4)-(2)&quot;)</span>
<span class="sd">        sage: cd_100 = CylinderDiagram(&quot;(0,2,3,1)-(0,2,1,4) (4)-(3)&quot;)</span>
<span class="sd">        sage: cd_010 = CylinderDiagram(&quot;(0,1)-(0,2,4,5) (2,5)-(3) (3,4)-(1)&quot;)</span>
<span class="sd">        sage: cd_001 = CylinderDiagram(&quot;(0,3)-(0,4,5) (1,4,2)-(1,3) (5)-(2)&quot;)</span>
<span class="sd">        sage: cd_111 = CylinderDiagram(&quot;(0,3,1,2)-(0,4,1,5) (4)-(2) (5)-(3)&quot;)</span>

<span class="sd">        sage: sum(1 for _ in _cylinder_diagrams_with_symmetric([cd_000]))</span>
<span class="sd">        4</span>
<span class="sd">        sage: sum(1 for _ in _cylinder_diagrams_with_symmetric([cd_100]))</span>
<span class="sd">        2</span>
<span class="sd">        sage: sum(1 for _ in _cylinder_diagrams_with_symmetric([cd_010]))</span>
<span class="sd">        2</span>
<span class="sd">        sage: sum(1 for _ in _cylinder_diagrams_with_symmetric([cd_001]))</span>
<span class="sd">        2</span>
<span class="sd">        sage: sum(1 for _ in _cylinder_diagrams_with_symmetric([cd_111]))</span>
<span class="sd">        1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">cd</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="n">cd</span><span class="o">.</span><span class="n">symmetries</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="o">==</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">cd</span><span class="o">.</span><span class="n">horizontal_symmetry</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">cd</span><span class="o">.</span><span class="n">vertical_symmetry</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">cd</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="o">==</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">cd</span><span class="o">.</span><span class="n">vertical_symmetry</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="o">==</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">cd</span><span class="o">.</span><span class="n">horizontal_symmetry</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="o">==</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">cd</span><span class="o">.</span><span class="n">horizontal_symmetry</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>

<div class="viewcode-block" id="AbelianStratum"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum">[docs]</a><span class="k">class</span> <span class="nc">AbelianStratum</span><span class="p">(</span><span class="n">Stratum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stratum of Abelian differentials.</span>

<span class="sd">    A stratum with a marked outgoing separatrix corresponds to Rauzy diagram</span>
<span class="sd">    with left induction, a stratum with marked incoming separatrix correspond</span>
<span class="sd">    to Rauzy diagram with right induction.</span>
<span class="sd">    If there is no marked separatrix, the associated Rauzy diagram is the</span>
<span class="sd">    extended Rauzy diagram (consideration of the</span>
<span class="sd">    :meth:`surface_dynamics.interval_exchanges.template.Permutation.symmetric`</span>
<span class="sd">    operation of Boissy-Lanneau).</span>

<span class="sd">    When you want to specify a marked separatrix, the degree on which it is is</span>
<span class="sd">    the first term of your degrees list.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``marked_separatrix`` - ``None`` (default) or &#39;in&#39; (for incoming</span>
<span class="sd">      separatrix) or &#39;out&#39; (for outgoing separatrix).</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">    Creation of an Abelian stratum and get its connected components::</span>

<span class="sd">        sage: a = AbelianStratum(2, 2)</span>
<span class="sd">        sage: a</span>
<span class="sd">        H_3(2^2)</span>
<span class="sd">        sage: a.components()</span>
<span class="sd">        [H_3(2^2)^hyp, H_3(2^2)^odd]</span>

<span class="sd">    Get a permutation representative of a connected component::</span>

<span class="sd">        sage: a = AbelianStratum(2,2)</span>
<span class="sd">        sage: a_hyp, a_odd = a.components()</span>
<span class="sd">        sage: a_hyp.permutation_representative()</span>
<span class="sd">        0 1 2 3 4 5 6</span>
<span class="sd">        6 5 4 3 2 1 0</span>
<span class="sd">        sage: a_odd.permutation_representative()</span>
<span class="sd">        0 1 2 3 4 5 6</span>
<span class="sd">        3 2 4 6 5 1 0</span>

<span class="sd">    You can specify the alphabet::</span>

<span class="sd">        sage: a_odd.permutation_representative(alphabet=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)</span>
<span class="sd">        A B C D E F G</span>
<span class="sd">        D C E G F B A</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;H&#39;</span>
    <span class="n">_latex_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">mathcal</span><span class="si">{H}</span><span class="s1">&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__classcall_private__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">l</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Integer</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(([</span><span class="n">v</span><span class="p">]</span><span class="o">*</span><span class="n">e</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">l</span><span class="p">)),</span> <span class="p">[])</span>

        <span class="n">zeros</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zeros</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the degrees must be non negative&quot;</span><span class="p">)</span>
        <span class="n">nb_fake_zeros</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">zeros</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the sum of the degrees must be even&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">zeros</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">nb_fake_zeros</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;there must be at least one zero&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">UniqueRepresentation</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="n">AbelianStratum</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">nb_fake_zeros</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">nb_fake_zeros</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = AbelianStratum(0)</span>
<span class="sd">            sage: s == loads(dumps(s))</span>
<span class="sd">            True</span>
<span class="sd">            sage: s = AbelianStratum(1,1,1,1)</span>
<span class="sd">            sage: s == loads(dumps(s))</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zeros</span> <span class="o">=</span> <span class="n">zeros</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nb_fake_zeros</span> <span class="o">=</span> <span class="n">nb_fake_zeros</span>

        <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zeros</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the sum of the degrees must be even&quot;</span><span class="p">)</span>
        <span class="n">genus</span> <span class="o">=</span> <span class="n">s</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">genus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">HypASC</span><span class="p">,)</span>

        <span class="k">elif</span> <span class="n">genus</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">HypASC</span><span class="p">,)</span>

        <span class="k">elif</span> <span class="n">genus</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">zeros</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">zeros</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">HypASC</span><span class="p">,</span> <span class="n">OddASC</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ASC</span><span class="p">,)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># just one zeros [2g-2]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">HypASC</span><span class="p">,</span> <span class="n">OddASC</span><span class="p">,</span> <span class="n">EvenASC</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">zeros</span> <span class="o">==</span> <span class="p">(</span><span class="n">genus</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">genus</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># two similar zeros [g-1, g-1]</span>
            <span class="k">if</span> <span class="n">genus</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">HypASC</span><span class="p">,</span> <span class="n">NonHypASC</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">HypASC</span><span class="p">,</span> <span class="n">OddASC</span><span class="p">,</span> <span class="n">EvenASC</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">zeros</span><span class="p">):</span>
            <span class="c1"># even zeroes [2 l_1, 2 l_2, ..., 2 l_n]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">OddASC</span><span class="p">,</span> <span class="n">EvenASC</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># connected</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ASC</span><span class="p">,</span> <span class="p">)</span>

<div class="viewcode-block" id="AbelianStratum.zeros"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.zeros">[docs]</a>    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_zeros</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the multiplicities of the zeros.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum([1,2,3]).zeros()</span>
<span class="sd">            (3, 2, 1)</span>
<span class="sd">            sage: AbelianStratum({2:4}).zeros()</span>
<span class="sd">            (2, 2, 2, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fake_zeros</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zeros</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_nb_fake_zeros</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zeros</span></div>

<div class="viewcode-block" id="AbelianStratum.nb_zeros"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.nb_zeros">[docs]</a>    <span class="k">def</span> <span class="nf">nb_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_zeros</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of zeros of self.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum(0).nb_zeros()</span>
<span class="sd">            1</span>
<span class="sd">            sage: AbelianStratum({2:4,3:2}).nb_zeros()</span>
<span class="sd">            6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fake_zeros</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zeros</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nb_fake_zeros</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zeros</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStratum.nb_fake_zeros"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.nb_fake_zeros">[docs]</a>    <span class="k">def</span> <span class="nf">nb_fake_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of fake zeros.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum(0).nb_fake_zeros()</span>
<span class="sd">            1</span>
<span class="sd">            sage: AbelianStratum(1,1,0,0).nb_fake_zeros()</span>
<span class="sd">            2</span>

<span class="sd">            sage: QuadraticStratum(0,4,2,2).nb_fake_zeros()</span>
<span class="sd">            1</span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nb_fake_zeros</span></div>

<div class="viewcode-block" id="AbelianStratum.genus"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.genus">[docs]</a>    <span class="k">def</span> <span class="nf">genus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the genus of the stratum.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        integer -- the genus</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum(0).genus()</span>
<span class="sd">            1</span>
<span class="sd">            sage: AbelianStratum(1,1).genus()</span>
<span class="sd">            2</span>
<span class="sd">            sage: AbelianStratum(3,2,1).genus()</span>
<span class="sd">            4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zeros</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStratum.dimension"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.dimension">[docs]</a>    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the complex dimension of this stratum.</span>

<span class="sd">        The dimension is `2g-2+s+1` where `g` is the genus of surfaces in the</span>
<span class="sd">        stratum, `s` the number of singularities. The complex dimension of a</span>
<span class="sd">        stratum is also the number of intervals of any interval exchange</span>
<span class="sd">        transformations associated to the strata.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum(0).dimension()</span>
<span class="sd">            2</span>
<span class="sd">            sage: AbelianStratum(0,0).dimension()</span>
<span class="sd">            3</span>
<span class="sd">            sage: AbelianStratum(2).dimension()</span>
<span class="sd">            4</span>
<span class="sd">            sage: AbelianStratum(1,1).dimension()</span>
<span class="sd">            5</span>

<span class="sd">        ::</span>

<span class="sd">            sage: a = AbelianStratum(4,3,2,1,0)</span>
<span class="sd">            sage: p = a.permutation_representative()</span>
<span class="sd">            sage: len(p) == a.dimension()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_zeros</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="AbelianStratum.rank"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.rank">[docs]</a>    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the rank of this manifold (half dimension of the absolute part of the tangent space).</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import AbelianStratum</span>

<span class="sd">            sage: AbelianStratum(0,0).rank()</span>
<span class="sd">            1</span>
<span class="sd">            sage: AbelianStratum(2).rank()</span>
<span class="sd">            2</span>
<span class="sd">            sage: AbelianStratum(2,0,0).rank()</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span></div>

    <span class="c1">#</span>
    <span class="c1"># Connected component</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="AbelianStratum.has_odd_component"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.has_odd_component">[docs]</a>    <span class="k">def</span> <span class="nf">has_odd_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether this stratum has an odd spin component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum(2).has_odd_component()</span>
<span class="sd">            False</span>
<span class="sd">            sage: AbelianStratum(4).has_odd_component()</span>
<span class="sd">            True</span>
<span class="sd">            sage: AbelianStratum(4).odd_component()</span>
<span class="sd">            H_3(4)^odd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">z</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">())</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="AbelianStratum.has_even_component"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.has_even_component">[docs]</a>    <span class="k">def</span> <span class="nf">has_even_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether this stratum has an even spin component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum(2,2).has_even_component()</span>
<span class="sd">            False</span>
<span class="sd">            sage: AbelianStratum(6).has_even_component()</span>
<span class="sd">            True</span>
<span class="sd">            sage: AbelianStratum(6).even_component()</span>
<span class="sd">            H_4(6)^even</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">z</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">())</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">4</span></div>

<div class="viewcode-block" id="AbelianStratum.has_hyperelliptic_component"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.has_hyperelliptic_component">[docs]</a>    <span class="k">def</span> <span class="nf">has_hyperelliptic_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether this stratum has an hyperelliptic component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum(2,1,1).has_hyperelliptic_component()</span>
<span class="sd">            False</span>
<span class="sd">            sage: AbelianStratum(2,2).has_hyperelliptic_component()</span>
<span class="sd">            True</span>
<span class="sd">            sage: AbelianStratum(2,2).hyperelliptic_component()</span>
<span class="sd">            H_3(2^2)^hyp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="AbelianStratum.has_non_hyperelliptic_component"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.has_non_hyperelliptic_component">[docs]</a>    <span class="k">def</span> <span class="nf">has_non_hyperelliptic_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether this stratum has a non-hyperelliptic component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum(1,1).has_non_hyperelliptic_component()</span>
<span class="sd">            False</span>
<span class="sd">            sage: AbelianStratum(3,3).has_non_hyperelliptic_component()</span>
<span class="sd">            True</span>
<span class="sd">            sage: AbelianStratum(3,3).non_hyperelliptic_component()</span>
<span class="sd">            H_4(3^2)^nonhyp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="AbelianStratum.odd_component"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.odd_component">[docs]</a>    <span class="k">def</span> <span class="nf">odd_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the odd component of self (if any).</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStratum([2,2]); a</span>
<span class="sd">            H_3(2^2)</span>
<span class="sd">            sage: a.odd_component()</span>
<span class="sd">            H_3(2^2)^odd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">OddASC</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span><span class="p">:</span> <span class="k">return</span> <span class="n">OddASC</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No odd spin component in this stratum&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStratum.even_component"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.even_component">[docs]</a>    <span class="k">def</span> <span class="nf">even_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the even component of self (if any)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStratum({2:4}); a</span>
<span class="sd">            H_5(2^4)</span>
<span class="sd">            sage: a.even_component()</span>
<span class="sd">            H_5(2^4)^even</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">EvenASC</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span><span class="p">:</span> <span class="k">return</span> <span class="n">EvenASC</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No even spin component in this stratum&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStratum.hyperelliptic_component"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.hyperelliptic_component">[docs]</a>    <span class="k">def</span> <span class="nf">hyperelliptic_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the hyperelliptic component of self (if any)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStratum(10); a</span>
<span class="sd">            H_6(10)</span>
<span class="sd">            sage: a.hyperelliptic_component()</span>
<span class="sd">            H_6(10)^hyp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">HypASC</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span><span class="p">:</span> <span class="k">return</span> <span class="n">HypASC</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No hyperelliptic component in this stratum&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStratum.non_hyperelliptic_component"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.non_hyperelliptic_component">[docs]</a>    <span class="k">def</span> <span class="nf">non_hyperelliptic_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the non hyperelliptic component of self (if any)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStratum(3,3); a</span>
<span class="sd">            H_4(3^2)</span>
<span class="sd">            sage: a.non_hyperelliptic_component()</span>
<span class="sd">            H_4(3^2)^nonhyp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">NonHypASC</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cc</span><span class="p">:</span> <span class="k">return</span> <span class="n">NonHypASC</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No non hyperelliptic component in this stratum&quot;</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># Quadratic cover</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="AbelianStratum.orientation_quotients"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.orientation_quotients">[docs]</a>    <span class="k">def</span> <span class="nf">orientation_quotients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of quadratic strata such that their orientation cover</span>
<span class="sd">        are contained in this stratum.</span>

<span class="sd">        If ``fake_zeros`` (default: False) is True we do care about poles which</span>
<span class="sd">        becomes a marked zero.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        The stratum H(2g-2) has one conic singularities of angle `2(2g-1)pi`. The</span>
<span class="sd">        only way a surface in H(2g-2) covers a quadratic differential is that</span>
<span class="sd">        the quadratic differential has as unique zeros a conical singularity of</span>
<span class="sd">        angle `(2g-1) \pi`. The number of poles may vary and give a collection</span>
<span class="sd">        of possibilities::</span>

<span class="sd">            sage: AbelianStratum(2).orientation_quotients()</span>
<span class="sd">            [Q_0(1, -1^5)]</span>
<span class="sd">            sage: AbelianStratum(4).orientation_quotients()</span>
<span class="sd">            [Q_1(3, -1^3), Q_0(3, -1^7)]</span>
<span class="sd">            sage: AbelianStratum(6).orientation_quotients()</span>
<span class="sd">            [Q_2(5, -1), Q_1(5, -1^5), Q_0(5, -1^9)]</span>

<span class="sd">        A stratum with two zeros may or may not have orientation quotients::</span>

<span class="sd">            sage: AbelianStratum(1,1).orientation_quotients()</span>
<span class="sd">            [Q_1(2, -1^2), Q_0(2, -1^6)]</span>
<span class="sd">            sage: AbelianStratum(2,2).orientation_quotients()</span>
<span class="sd">            [Q_1(1^2, -1^2), Q_0(1^2, -1^6), Q_1(4, -1^4), Q_0(4, -1^8)]</span>
<span class="sd">            sage: AbelianStratum(3,1).orientation_quotients()</span>
<span class="sd">            []</span>

<span class="sd">        To impose that covering of poles are fake zeros, switch option</span>
<span class="sd">        ``fake_zeros`` to ``True``::</span>

<span class="sd">            sage: AbelianStratum(2,2,0,0).orientation_quotients(fake_zeros=True)</span>
<span class="sd">            [Q_1(1^2, -1^2)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fake_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># the odd degrees (corresponding to angles 2((2m+1)+1) times pi should</span>
        <span class="c1"># be non ramified and hence come by pair.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">e</span> <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">pairings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># if the degree is odd it is necessarily non ramified</span>
                <span class="n">pairings</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">d</span><span class="p">,</span><span class="n">m</span><span class="o">//</span><span class="mi">2</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># if the degree is even ramified and non ramified are possible</span>
                <span class="n">pairings</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">d</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>

        <span class="kn">import</span> <span class="nn">itertools</span>
        <span class="kn">from</span> <span class="nn">.quadratic_strata</span> <span class="kn">import</span> <span class="n">QuadraticStratum</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">pairings</span><span class="p">):</span>
            <span class="n">ee</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">ee</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">ee</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">e</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span>
                <span class="n">ee</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="n">m</span>

            <span class="n">degrees</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ee</span><span class="p">:</span> <span class="n">degrees</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">d</span><span class="p">]</span><span class="o">*</span><span class="n">ee</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

            <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nb_poles</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="mi">4</span><span class="p">,</span><span class="n">s</span><span class="o">+</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">QuadraticStratum</span><span class="p">(</span><span class="n">degrees</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nb_poles</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">fake_zeros</span> <span class="ow">or</span> <span class="n">q</span><span class="o">.</span><span class="n">nb_poles</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()):</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

    <span class="c1">#</span>
    <span class="c1"># Separatrix and cylinder diagrams</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="AbelianStratum.separatrix_diagram_iterator"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.separatrix_diagram_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">separatrix_diagram_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator over the separatrix diagrams of this stratum.</span>

<span class="sd">        For strata of small dimension, it could be faster to use the method</span>
<span class="sd">        separatrix_diagrams.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ncyls`` -- an optional number of cylinders</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.separatrix_diagram</span> <span class="kn">import</span> <span class="n">separatrix_diagram_iterator</span>
        <span class="k">return</span> <span class="n">separatrix_diagram_iterator</span><span class="p">([</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">()],</span><span class="n">ncyls</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStratum.separatrix_diagrams"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.separatrix_diagrams">[docs]</a>    <span class="k">def</span> <span class="nf">separatrix_diagrams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of separatrix diagrams that appears in this stratum.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``database`` - boolean (default: True) - if True, use the</span>
<span class="sd">          FlatSurfacesDatabase</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStratum(2); a</span>
<span class="sd">            H_2(2)</span>
<span class="sd">            sage: for s in a.separatrix_diagrams(): print(s)</span>
<span class="sd">            (0,1,2)-(0,1,2)</span>
<span class="sd">            (0)(1,2)-(0,1)(2)</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: for (zeros, ncyl) in [((4,), 3), ((2,2), 4)]:</span>
<span class="sd">            ....:     S = AbelianStratum(4).separatrix_diagrams(3)</span>
<span class="sd">            ....:     for i in range(len(S)):</span>
<span class="sd">            ....:         for j in range(i):</span>
<span class="sd">            ....:              assert not S[i].is_isomorphic(S[j])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">separatrix_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbelianStratum.cylinder_diagram_iterator"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.cylinder_diagram_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">cylinder_diagram_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_computation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all cylinder diagram of this stratum.</span>

<span class="sd">        The generation is up to isomorphism and horizontal/vertical symmetry</span>
<span class="sd">        (and they are in standard form).</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ncyls`` -- an optional number of cylinders</span>

<span class="sd">        - ``up_to_symmetry`` - (boolean, default ``True``) to return only</span>
<span class="sd">          cylinder diagrams up to horizontal and vertical symmetry.</span>

<span class="sd">        - ``force_computation`` -- if ``True`` do no use the database of</span>
<span class="sd">          cylinder diagrams (default is ``False``)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: A = AbelianStratum(4)</span>
<span class="sd">            sage: C1 = [CylinderDiagram(&#39;(0,2,1)-(0,3,4) (3)-(2) (4)-(1)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,2,1)-(0,3,4) (3)-(1) (4)-(2)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,1)-(0,3,4) (2,3)-(1) (4)-(2)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,2)-(4) (1,4)-(2,3) (3)-(0,1)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,2)-(0,3) (1,3)-(1,4) (4)-(2)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,1)-(0,3) (2,3)-(1,4) (4)-(2)&#39;)]</span>
<span class="sd">            sage: C2 = list(A.cylinder_diagram_iterator(3, force_computation=True))</span>
<span class="sd">            sage: assert len(C1) == len(C2)</span>
<span class="sd">            sage: for (c1, c2) in zip(C1, C2):</span>
<span class="sd">            ....:     assert c1.is_isomorphic(c2) or \</span>
<span class="sd">            ....:            c1.is_isomorphic(c2.horizontal_symmetry()) or \</span>
<span class="sd">            ....:            c1.is_isomorphic(c2.vertical_symmetry()) or \</span>
<span class="sd">            ....:            c1.is_isomorphic(c2.inverse())</span>

<span class="sd">            sage: sum(1 for _ in A.cylinder_diagram_iterator(3, True, True))</span>
<span class="sd">            6</span>
<span class="sd">            sage: sum(1 for _ in A.cylinder_diagram_iterator(3, True, False))</span>
<span class="sd">            6</span>
<span class="sd">            sage: sum(1 for _ in A.cylinder_diagram_iterator(3, False, True))</span>
<span class="sd">            9</span>
<span class="sd">            sage: sum(1 for _ in A.cylinder_diagram_iterator(3, False, False))</span>
<span class="sd">            9</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ncyls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ncyls should be None or an integer&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ncyls</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ncyls</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_zeros</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ncyls is not valid&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_computation</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">():</span>
                <span class="k">yield from</span> <span class="n">cc</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">separatrix_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">):</span>
                <span class="n">iterator</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">up_to_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">up_to_symmetry</span><span class="p">:</span>
                    <span class="n">iterator</span> <span class="o">=</span> <span class="n">_cylinder_diagrams_with_symmetric</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
                <span class="k">yield from</span> <span class="n">iterator</span></div>

<div class="viewcode-block" id="AbelianStratum.cylinder_diagrams"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.cylinder_diagrams">[docs]</a>    <span class="k">def</span> <span class="nf">cylinder_diagrams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_computation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of cylinder diagram of this stratum.</span>

<span class="sd">        INPUT::</span>

<span class="sd">        - ``ncyls`` -- an optional number of cylinders</span>

<span class="sd">        - ``up_to_symmetry`` - (boolean, default ``True``) to return only</span>
<span class="sd">          cylinder diagrams up to horizontal and vertical symmetry.</span>

<span class="sd">        - ``force_computation`` -- If ``True`` then do not use the database of</span>
<span class="sd">          cylinder diagrams (default is ``False``).</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: A = AbelianStratum(2,2)</span>
<span class="sd">            sage: C1 = [CylinderDiagram(&#39;(0,1)-(0,5) (2)-(4) (3,4)-(1) (5)-(2,3)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,2,1)-(3,4,5) (3)-(1) (4)-(2) (5)-(0)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,2,1)-(3,5,4) (3)-(1) (4)-(2) (5)-(0)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,3)-(5) (1)-(0) (2,5)-(3,4) (4)-(1,2)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,3)-(0,5) (1,2)-(1,4) (4)-(3) (5)-(2)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,5)-(3,4) (1,4)-(2,5) (2)-(0) (3)-(1)&#39;),</span>
<span class="sd">            ....:       CylinderDiagram(&#39;(0,5)-(3,4) (1,4)-(2,5) (2)-(1) (3)-(0)&#39;)]</span>
<span class="sd">            sage: C2 = A.cylinder_diagrams(4)</span>
<span class="sd">            sage: assert len(C1) == len(C2)</span>
<span class="sd">            sage: isoms = []</span>
<span class="sd">            sage: for c in A.cylinder_diagrams(4):</span>
<span class="sd">            ....:     isom = []</span>
<span class="sd">            ....:     for i,cc in enumerate(C1):</span>
<span class="sd">            ....:         if c.is_isomorphic(cc) or \</span>
<span class="sd">            ....:            c.is_isomorphic(cc.horizontal_symmetry()) or \</span>
<span class="sd">            ....:            c.is_isomorphic(cc.vertical_symmetry()) or \</span>
<span class="sd">            ....:            c.is_isomorphic(cc.inverse()):</span>
<span class="sd">            ....:              isom.append(i)</span>
<span class="sd">            ....:     assert len(isom) == 1, isom</span>
<span class="sd">            ....:     isoms.extend(isom)</span>
<span class="sd">            sage: assert sorted(isoms) == [0, 1, 2, 3, 4, 5, 6]</span>

<span class="sd">            sage: len(A.cylinder_diagrams(4, up_to_symmetry=False))</span>
<span class="sd">            7</span>
<span class="sd">            sage: sum(4 / (1 + sum(cd.symmetries())) for cd in A.cylinder_diagrams(4, up_to_symmetry=True))</span>
<span class="sd">            7</span>

<span class="sd">        Recovering the multiplicity of the symmetric versions::</span>

<span class="sd">            sage: total = 0</span>
<span class="sd">            sage: for c in AbelianStratum(2,1,1).cylinder_diagrams(2):</span>
<span class="sd">            ....:     total += 4 // (1 + sum(c.symmetries()))</span>
<span class="sd">            sage: total</span>
<span class="sd">            61</span>
<span class="sd">            sage: len(AbelianStratum(2, 1, 1).cylinder_diagrams(2, up_to_symmetry=False))</span>
<span class="sd">            61</span>

<span class="sd">        You obtain the same number directly::</span>

<span class="sd">            sage: AbelianStratum(2, 1, 1).cylinder_diagrams_number(2, up_to_symmetry=False)</span>
<span class="sd">            61</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="p">,</span> <span class="n">force_computation</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbelianStratum.cylinder_diagrams_by_component"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.cylinder_diagrams_by_component">[docs]</a>    <span class="k">def</span> <span class="nf">cylinder_diagrams_by_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_computation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary component -&gt; list of cylinder diagrams.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ncyls`` - None or integer (default: None) - the number of cylinders</span>

<span class="sd">        - ``up_to_symmetry`` - (boolean, default ``True``) to return only</span>
<span class="sd">          cylinder diagrams up to horizontal and vertical symmetry.</span>

<span class="sd">        - ``force_computation`` - boolean (default: ``False``) - if ``False``,</span>
<span class="sd">          then try to use the database.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: A = AbelianStratum(4)</span>
<span class="sd">            sage: cyls = A.cylinder_diagrams_by_component(ncyls=2, force_computation=True)</span>
<span class="sd">            sage: A_hyp = A.hyperelliptic_component()</span>
<span class="sd">            sage: A_odd = A.odd_component()</span>
<span class="sd">            sage: len(cyls[A_odd])</span>
<span class="sd">            4</span>
<span class="sd">            sage: len(cyls[A_hyp])</span>
<span class="sd">            2</span>

<span class="sd">            sage: all(c.ncyls() == 2 for c in cyls[A_hyp])</span>
<span class="sd">            True</span>
<span class="sd">            sage: all(c.stratum_component() == A_hyp for c in cyls[A_hyp])</span>
<span class="sd">            True</span>

<span class="sd">            sage: all(c.ncyls() == 2 for c in cyls[A_odd])</span>
<span class="sd">            True</span>
<span class="sd">            sage: all(c.stratum_component() == A_odd for c in cyls[A_odd])</span>
<span class="sd">            True</span>

<span class="sd">            sage: for ncyls in range(1, 4):</span>
<span class="sd">            ....:     for up_to_symmetry in [True, False]:</span>
<span class="sd">            ....:         cd1 = A.cylinder_diagrams_by_component(ncyls, up_to_symmetry, True)</span>
<span class="sd">            ....:         cd2 = A.cylinder_diagrams_by_component(ncyls, up_to_symmetry, False)</span>
<span class="sd">            ....:         assert len(cd1[A_hyp]) == len(cd2[A_hyp])</span>
<span class="sd">            ....:         assert len(cd1[A_odd]) == len(cd2[A_odd])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ncyls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ncyls should be None or an integer&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ncyls</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ncyls</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_zeros</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_computation</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">cylinder_diagrams</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">())</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">cyl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinder_diagrams</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">cyl</span><span class="o">.</span><span class="n">stratum_component</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">up_to_symmetry</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_cylinder_diagrams_with_symmetric</span><span class="p">([</span><span class="n">cyl</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cyl</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="AbelianStratum.one_cylinder_diagram"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.one_cylinder_diagram">[docs]</a>    <span class="k">def</span> <span class="nf">one_cylinder_diagram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a diagram with one cylinder in this connected component.</span>

<span class="sd">        The diagram returned is the one deduced from the method representative.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ncyls`` - the number of cylinders</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStratum(3,2,1); a</span>
<span class="sd">            H_4(3, 2, 1)</span>
<span class="sd">            sage: c = a.one_cylinder_diagram();c</span>
<span class="sd">            (0,8,3,2,1,6,5,4,7)-(0,8,7,6,5,4,3,2,1)</span>
<span class="sd">            sage: c.stratum()</span>
<span class="sd">            H_4(3, 2, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_component</span><span class="p">()</span><span class="o">.</span><span class="n">one_cylinder_diagram</span><span class="p">()</span></div>

<div class="viewcode-block" id="AbelianStratum.separatrix_diagrams_number"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.separatrix_diagrams_number">[docs]</a>    <span class="k">def</span> <span class="nf">separatrix_diagrams_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of separatrix diagram that belongs to this stratum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">separatrix_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbelianStratum.cylinder_diagrams_number"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.cylinder_diagrams_number">[docs]</a>    <span class="k">def</span> <span class="nf">cylinder_diagrams_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_computation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of cylinder diagram that belongs to this stratum.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ncyls`` -- an optional number of cylinders</span>

<span class="sd">        - ``up_to_symmetry`` - (boolean, default ``True``) to return only</span>
<span class="sd">          cylinder diagrams up to horizontal and vertical symmetry.</span>

<span class="sd">        - ``force_computation`` -- if ``True`` do no use the database of</span>
<span class="sd">          cylinder diagrams (default is ``False``)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: H22 = AbelianStratum(2,2)</span>
<span class="sd">            sage: H22.cylinder_diagrams_number(3)</span>
<span class="sd">            18</span>
<span class="sd">            sage: H22.cylinder_diagrams_number(4)</span>
<span class="sd">            7</span>

<span class="sd">        If ``force_computation`` is set to ``True`` then the database is not</span>
<span class="sd">        used. It might be slower for large strata::</span>

<span class="sd">            sage: H22.cylinder_diagrams_number(3, force_computation=True)</span>
<span class="sd">            18</span>
<span class="sd">            sage: H22.cylinder_diagrams_number(4, force_computation=True)</span>
<span class="sd">            7</span>

<span class="sd">            sage: H31 = AbelianStratum(3,1)</span>
<span class="sd">            sage: for d in range(1,5):</span>
<span class="sd">            ....:     print(&quot;%d %d&quot; %(H31.cylinder_diagrams_number(d, True, False),</span>
<span class="sd">            ....:                     H31.cylinder_diagrams_number(d, True, True)))</span>
<span class="sd">            2 2</span>
<span class="sd">            12 12</span>
<span class="sd">            16 16</span>
<span class="sd">            4 4</span>

<span class="sd">            sage: H211 = AbelianStratum(2,1,1)</span>
<span class="sd">            sage: for d in range(1,6):</span>
<span class="sd">            ....:     print(&quot;%d %d&quot; % (H211.cylinder_diagrams_number(d, True, False),</span>
<span class="sd">            ....:               H211.cylinder_diagrams_number(d, True, True)))</span>
<span class="sd">            5 5</span>
<span class="sd">            29 29</span>
<span class="sd">            53 53</span>
<span class="sd">            27 27</span>
<span class="sd">            8 8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ncyls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ncyls</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_zeros</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_computation</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.databases.flat_surfaces</span> <span class="kn">import</span> <span class="n">CylinderDiagrams</span>
            <span class="n">CDB</span> <span class="o">=</span> <span class="n">CylinderDiagrams</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">CDB</span><span class="o">.</span><span class="n">has_component</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">up_to_symmetry</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">CDB</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">cylinder_diagrams_number</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">up_to_symmetry</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">4</span> <span class="o">//</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cd</span><span class="o">.</span><span class="n">symmetries</span><span class="p">()))</span> <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbelianStratum.single_cylinder_representative"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.single_cylinder_representative">[docs]</a>    <span class="k">def</span> <span class="nf">single_cylinder_representative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a single cylinder permutation representative.</span>

<span class="sd">        Returns a permutation representative of a square-tiled surface in this</span>
<span class="sd">        component having a single vertical cylinder and a single horizontal cylinder.</span>

<span class="sd">        Such representatives were constructed for every stratum of Abelian</span>
<span class="sd">        differentials by Jeffreys [Jef19]_.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``alphabet`` -- an optional alphabet for the permutation representative</span>

<span class="sd">        - ``reduced`` (boolean, default ``True``) -- whether to return a reduced</span>
<span class="sd">          permutation (ie without labels)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: C = AbelianStratum(2,0)</span>
<span class="sd">            sage: p = C.single_cylinder_representative()</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1 2 3 4</span>
<span class="sd">            4 3 1 2 0</span>
<span class="sd">            sage: p.stratum() == C</span>
<span class="sd">            True</span>

<span class="sd">            sage: C = AbelianStratum(3,1)</span>
<span class="sd">            sage: p = C.single_cylinder_representative(alphabet=Alphabet(name=&#39;lower&#39;))</span>
<span class="sd">            sage: p</span>
<span class="sd">            a b c d e f g</span>
<span class="sd">            c f b g e d a</span>
<span class="sd">            sage: p.stratum() == C</span>
<span class="sd">            True</span>

<span class="sd">            sage: C = AbelianStratum(2)</span>
<span class="sd">            sage: C.single_cylinder_representative()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no 1,1-square-tiled surfaces in this stratum try again with H_2(2, 0)</span>
<span class="sd">            sage: C = AbelianStratum(1,1)</span>
<span class="sd">            sage: C.single_cylinder_representative()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no 1,1-square-tiled surfaces in this stratum try again with H_2(1^2, 0^2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">genus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
        <span class="n">nb_real_zeros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_zeros</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">genus</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">nb_real_zeros</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no 1,1-square-tiled surfaces in this stratum try again with H_2(2, 0)&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">genus</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">nb_real_zeros</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no 1,1-square-tiled surfaces in this stratum try again with H_2(1^2, 0^2)&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_component</span><span class="p">()</span><span class="o">.</span><span class="n">single_cylinder_representative</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span> <span class="n">reduced</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStratum.single_cylinder_origami"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratum.single_cylinder_origami">[docs]</a>    <span class="k">def</span> <span class="nf">single_cylinder_origami</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an origami associated to a single cylinder permutation representative.</span>

<span class="sd">        Returns an origami in this connected component having a single vertical</span>
<span class="sd">        cylinder and a single horizontal cylinder.</span>

<span class="sd">        Examples::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: C = AbelianStratum(4)</span>
<span class="sd">            sage: O = C.single_cylinder_origami()</span>
<span class="sd">            sage: O</span>
<span class="sd">            (1,2,3,4,5)</span>
<span class="sd">            (1,4,3,5,2)</span>
<span class="sd">            sage: O.stratum() == AbelianStratum(4)</span>
<span class="sd">            True</span>
<span class="sd">            sage: C = AbelianStratum(2,0)</span>
<span class="sd">            sage: O = C.single_cylinder_origami()</span>
<span class="sd">            sage: O</span>
<span class="sd">            (1,2,3,4)</span>
<span class="sd">            (1,3,2,4)</span>
<span class="sd">            sage: O.stratum() == AbelianStratum(2)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cylinder_representative</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">to_origami</span><span class="p">()</span></div></div>

<div class="viewcode-block" id="AbelianStratumComponent"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent">[docs]</a><span class="k">class</span> <span class="nc">AbelianStratumComponent</span><span class="p">(</span><span class="n">StratumComponent</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connected component of Abelian stratum.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Internal class! Do not use directly!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span>

<div class="viewcode-block" id="AbelianStratumComponent.spin"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.spin">[docs]</a>    <span class="k">def</span> <span class="nf">spin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``None`` since surfaces in this component have no spin.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = AbelianStratum([1,1,1,1]).unique_component(); c</span>
<span class="sd">            H_3(1^4)^c</span>
<span class="sd">            sage: c.spin() is None</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.permutation_representative"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.permutation_representative">[docs]</a>    <span class="k">def</span> <span class="nf">permutation_representative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Zorich representative of this connected component.</span>

<span class="sd">        Zorich constructs explicitly interval exchange</span>
<span class="sd">        transformations for each stratum in [Zor08]_.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``reduced`` - boolean (default: ``True``): whether you</span>
<span class="sd">          obtain a reduced or labelled permutation</span>

<span class="sd">        - ``alphabet`` - an alphabet or ``None``: whether you want to</span>
<span class="sd">          specify an alphabet for your permutation</span>

<span class="sd">        - ``left_degree`` - the degree of the singularity on the left of the</span>
<span class="sd">          interval.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        permutation -- a permutation which lives in this component</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = AbelianStratum(1,1,1,1).unique_component()</span>
<span class="sd">            sage: p = c.permutation_representative(alphabet=&quot;abcdefghi&quot;)</span>
<span class="sd">            sage: p</span>
<span class="sd">            a b c d e f g h i</span>
<span class="sd">            e d c f i h g b a</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_3(1^4)^c</span>

<span class="sd">            sage: cc = AbelianStratum(3,2,1,0).unique_component()</span>
<span class="sd">            sage: p = cc.permutation_representative(left_degree=3); p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10</span>
<span class="sd">            4 3 7 6 5 10 9 8 2 0 1</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(3, 2, 1, 0)^c</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            4</span>
<span class="sd">            sage: p.rauzy_diagram()  # not tested</span>
<span class="sd">            Rauzy diagram with 1060774 permutations</span>

<span class="sd">            sage: p = cc.permutation_representative(left_degree=2); p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10</span>
<span class="sd">            4 3 5 7 6 10 9 8 2 0 1</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(3, 2, 1, 0)^c</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            3</span>
<span class="sd">            sage: p.rauzy_diagram()  # not tested</span>
<span class="sd">            Rauzy diagram with 792066 permutations</span>

<span class="sd">            sage: p = cc.permutation_representative(left_degree=1); p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10</span>
<span class="sd">            5 4 3 7 6 8 10 9 2 0 1</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(3, 2, 1, 0)^c</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            2</span>
<span class="sd">            sage: p.rauzy_diagram()  # not tested</span>
<span class="sd">            Rauzy diagram with 538494 permutations</span>

<span class="sd">            sage: p = cc.permutation_representative(left_degree=0); p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10</span>
<span class="sd">            4 2 7 6 5 10 9 8 1 3 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(3, 2, 1, 0)^c</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            1</span>
<span class="sd">            sage: p.rauzy_diagram()  # not tested</span>
<span class="sd">            Rauzy diagram with 246914 permutations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stratum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fake_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">left_degree</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">zeros</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">left_degree</span><span class="p">)</span>
            <span class="n">zeros</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zeros</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alphabet</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">stratum</span><span class="o">.</span><span class="n">dimension</span><span class="p">())</span>

        <span class="n">l0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">l1</span> <span class="o">+=</span> <span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">l1</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">zeros</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">l0</span><span class="p">[</span><span class="n">l0</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                <span class="k">del</span> <span class="n">l1</span><span class="p">[</span><span class="n">l1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="n">n</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">left_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">l0</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">l0</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                <span class="n">l1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l0</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                <span class="n">l1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.reduced</span> <span class="kn">import</span> <span class="n">ReducedPermutationIET</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">ReducedPermutationIET</span><span class="p">([</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.labelled</span> <span class="kn">import</span> <span class="n">LabelledPermutationIET</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">LabelledPermutationIET</span><span class="p">([</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>

        <span class="n">p</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.lyapunov_exponents_approx"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.lyapunov_exponents_approx">[docs]</a>    <span class="k">def</span> <span class="nf">lyapunov_exponents_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the approximate Lyapunov exponents of the KZ-cocycle.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum(2).unique_component().lyapunov_exponents_approx(nb_iterations=2**21)  # abs tol .05</span>
<span class="sd">            [1.000, 0.333]</span>

<span class="sd">            sage: H4hyp, H4odd = AbelianStratum(4).components()</span>
<span class="sd">            sage: H4hyp.lyapunov_exponents_approx(nb_iterations=2**21) # abs tol .05</span>
<span class="sd">            [1.000, 0.616, 0.184]</span>
<span class="sd">            sage: H4odd.lyapunov_exponents_approx(nb_iterations=2**21) # abs tol .05</span>
<span class="sd">            [1.000, 0.418, 0.182]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation_representative</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">perm</span><span class="o">.</span><span class="n">lyapunov_exponents_approx</span><span class="p">(</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span></div>

    <span class="c1"># TODO</span>
    <span class="c1"># def sum_of_lyapunov_exponents(self)</span>
    <span class="c1"># TODO</span>
    <span class="c1"># def volume(self)</span>
    <span class="c1"># TODO</span>
    <span class="c1"># def carea(self)</span>

<div class="viewcode-block" id="AbelianStratumComponent.random_standard_permutation"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.random_standard_permutation">[docs]</a>    <span class="k">def</span> <span class="nf">random_standard_permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">64</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a random walk on rauzy diagram stopped on a standard permutation.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``nsteps`` - integer or None - perform nsteps and then stops as soon</span>
<span class="sd">          as a Strebel differential is found.</span>

<span class="sd">        At each step, with probability 1/3 we perform one of the following</span>
<span class="sd">        moves:</span>

<span class="sd">        - exchange top,bottom and left,right (proba 1/10)</span>

<span class="sd">        - top rauzy move (proba 9/20)</span>

<span class="sd">        - bot rauzy move (proba 9/20)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: C = AbelianStratum(10).hyperelliptic_component()</span>
<span class="sd">            sage: p = C.random_standard_permutation(); p   # random</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10 11</span>
<span class="sd">            11 10 9 8 7 6 5 4 3 2 1 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_6(10)^hyp</span>

<span class="sd">            sage: C = AbelianStratum(6,4,2).odd_component(); C</span>
<span class="sd">            H_7(6, 4, 2)^odd</span>
<span class="sd">            sage: p = C.random_standard_permutation(); p  # random</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</span>
<span class="sd">            15 2 14 12 3 11 6 10 8 5 9 13 7 4 1 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_7(6, 4, 2)^odd</span>

<span class="sd">            sage: C = AbelianStratum(2,2,2,2).even_component(); C</span>
<span class="sd">            H_5(2^4)^even</span>
<span class="sd">            sage: p = C.random_standard_permutation(); p  # random</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10 11 12</span>
<span class="sd">            12 4 9 11 8 3 7 6 1 10 2 5 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_5(2^4)^even</span>

<span class="sd">            sage: C = AbelianStratum(32).odd_component(); C</span>
<span class="sd">            H_17(32)^odd</span>
<span class="sd">            sage: p = C.random_standard_permutation(); p  # random</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33</span>
<span class="sd">            33 30 10 3 32 19 11 28 4 14 24 15 21 20 9 12 25 6 2 29 26 23 27 13 8 1 18 17 16 31 7 22 5 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_17(32)^odd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">sage.misc.prandom</span> <span class="k">as</span> <span class="nn">prandom</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation_representative</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nsteps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nsteps</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsteps</span><span class="p">):</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">prandom</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">rd</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>   <span class="c1"># (inplace) symmetric with proba 1/10</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_inversed_twin</span><span class="p">()</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_reversed_twin</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">rd</span> <span class="o">&lt;</span> <span class="mf">.55</span><span class="p">:</span> <span class="c1"># (inplace) rauzy move top with proba 9/20</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>          <span class="c1"># (inplace) rauzy move bot with proba 9/20</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">is_standard</span><span class="p">():</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">prandom</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">rd</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>   <span class="c1"># (inplace) symmetric with proba 1/10</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_inversed_twin</span><span class="p">()</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_reversed_twin</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">rd</span> <span class="o">&lt;</span> <span class="mf">.55</span><span class="p">:</span> <span class="c1"># (inplace) rauzy move top with proba 9/20</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>          <span class="c1"># (inplace) rauzy move bot with proba 9/20</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.rauzy_diagram"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.rauzy_diagram">[docs]</a>    <span class="k">def</span> <span class="nf">rauzy_diagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the extended Rauzy diagram associated to this connected component.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        rauzy diagram -- the Rauzy diagram associated to this stratum</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = AbelianStratum(0).components()[0]</span>
<span class="sd">            sage: r = c.rauzy_diagram()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;left_degree&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation_representative</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span><span class="o">.</span><span class="n">rauzy_diagram</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation_representative</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span><span class="o">.</span><span class="n">rauzy_diagram</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.rauzy_class_cardinality"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.rauzy_class_cardinality">[docs]</a>    <span class="k">def</span> <span class="nf">rauzy_class_cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rauzy diagram cardinality for connected components.</span>

<span class="sd">        Returns the cardinality of the extended Rauzy diagram associated to this</span>
<span class="sd">        connected component.</span>

<span class="sd">        If left_degree is provided then it returns the cardinality of the Rauzy</span>
<span class="sd">        diagram with a singularity of that degree attached on the left.</span>
<span class="sd">        Otherwise it returns the cardinality of the extended Rauzy diagram.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``left_degree`` - the degree to be attached to the singularity on the</span>
<span class="sd">          left</span>

<span class="sd">        - ``reduced`` - boolean (default: True) - consider the cardinality of</span>
<span class="sd">          reduced or extended Rauzy diagram</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStratum({1:4}).unique_component(); a</span>
<span class="sd">            H_3(1^4)^c</span>
<span class="sd">            sage: a.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 1255 permutations</span>
<span class="sd">            sage: a.rauzy_class_cardinality()</span>
<span class="sd">            1255</span>

<span class="sd">            sage: cc = AbelianStratum(3,2,1).unique_component()</span>
<span class="sd">            sage: cc.rauzy_diagram(left_degree=3)   # long time</span>
<span class="sd">            Rauzy diagram with 96434 permutations</span>
<span class="sd">            sage: cc.rauzy_class_cardinality(left_degree=3)</span>
<span class="sd">            96434</span>

<span class="sd">            sage: cc.rauzy_diagram(left_degree=2)   # long time</span>
<span class="sd">            Rauzy diagram with 72006 permutations</span>
<span class="sd">            sage: cc.rauzy_class_cardinality(left_degree=2)</span>
<span class="sd">            72006</span>

<span class="sd">            sage: cc.rauzy_diagram(left_degree=1)   # long time</span>
<span class="sd">            Rauzy diagram with 48954 permutations</span>
<span class="sd">            sage: cc.rauzy_class_cardinality(left_degree=1)</span>
<span class="sd">            48954</span>

<span class="sd">            sage: a = AbelianStratum({1:8}).unique_component(); a</span>
<span class="sd">            H_5(1^8)^c</span>
<span class="sd">            sage: a.rauzy_class_cardinality()</span>
<span class="sd">            55184875</span>

<span class="sd">        Cardinalities for labeled Rauzy classes instead of reduced::</span>

<span class="sd">            sage: cc=AbelianStratum(2,1,1).unique_component()</span>
<span class="sd">            sage: cc.rauzy_diagram(left_degree=2,reduced=False)</span>
<span class="sd">            Rauzy diagram with 3676 permutations</span>
<span class="sd">            sage: cc.rauzy_class_cardinality(left_degree=2,reduced=False)</span>
<span class="sd">            3676</span>

<span class="sd">            sage: cc.rauzy_diagram(left_degree=1,reduced=False)</span>
<span class="sd">            Rauzy diagram with 3774 permutations</span>
<span class="sd">            sage: cc.rauzy_class_cardinality(left_degree=1,reduced=False)</span>
<span class="sd">            3774</span>

<span class="sd">            sage: cc=AbelianStratum(2,1,1,0).unique_component()</span>
<span class="sd">            sage: cc.rauzy_diagram(left_degree=2,reduced=False) # long time</span>
<span class="sd">            Rauzy diagram with 33084 permutations</span>
<span class="sd">            sage: cc.rauzy_diagram(left_degree=1,reduced=False) # long time</span>
<span class="sd">            Rauzy diagram with 33966 permutations</span>
<span class="sd">            sage: cc.rauzy_diagram(left_degree=0,reduced=False) # long time</span>
<span class="sd">            Rauzy diagram with 30828 permutations</span>

<span class="sd">            sage: cc.rauzy_class_cardinality(left_degree=2,reduced=False)</span>
<span class="sd">            33084</span>
<span class="sd">            sage: cc.rauzy_class_cardinality(left_degree=1,reduced=False)</span>
<span class="sd">            33966</span>
<span class="sd">            sage: cc.rauzy_class_cardinality(left_degree=0,reduced=False)</span>
<span class="sd">            30828</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">surface_dynamics.interval_exchanges.rauzy_class_cardinality</span> <span class="k">as</span> <span class="nn">rdc</span>

        <span class="n">profile</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_zeros</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)),</span> <span class="s2">&quot;if not None, left_degree should be an integer&quot;</span>
            <span class="n">left_degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">left_degree</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">left_degree</span> <span class="ow">in</span> <span class="n">profile</span><span class="p">,</span> <span class="s2">&quot;if not None, the degree should be one of the degree of the stratum&quot;</span>

            <span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">gamma_irr</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span><span class="n">left_degree</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">Rational</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">Partition</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span><span class="o">.</span><span class="n">centralizer_size</span><span class="p">()</span> <span class="o">/</span>
                    <span class="p">(</span><span class="n">left_degree</span> <span class="o">*</span> <span class="n">profile</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">left_degree</span><span class="p">))</span> <span class="o">*</span>
                    <span class="n">Integer</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">gamma_irr</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span><span class="n">left_degree</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">gamma_irr</span><span class="p">(</span><span class="n">profile</span><span class="p">))</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;not known formula for labeled extended Rauzy classes&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.standard_permutations_number"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.standard_permutations_number">[docs]</a>    <span class="k">def</span> <span class="nf">standard_permutations_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of standard permutations in the Rauzy class associated</span>
<span class="sd">        to this connected component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cc = AbelianStratum(3,1).unique_component()</span>
<span class="sd">            sage: sum(1 for p in cc.rauzy_diagram() if p.is_standard())</span>
<span class="sd">            24</span>
<span class="sd">            sage: cc.standard_permutations_number()</span>
<span class="sd">            24</span>

<span class="sd">            sage: sum(1 for p in cc.rauzy_diagram(left_degree=3) if p.is_standard())</span>
<span class="sd">            16</span>
<span class="sd">            sage: cc.standard_permutations_number(left_degree=3)</span>
<span class="sd">            16</span>

<span class="sd">            sage: sum(1 for p in cc.rauzy_diagram(left_degree=1) if p.is_standard())</span>
<span class="sd">            8</span>
<span class="sd">            sage: cc.standard_permutations_number(left_degree=1)</span>
<span class="sd">            8</span>

<span class="sd">            sage: cc = AbelianStratum({1:10}).unique_component(); cc</span>
<span class="sd">            H_6(1^10)^c</span>
<span class="sd">            sage: cc.standard_permutations_number()</span>
<span class="sd">            59520825</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">surface_dynamics.interval_exchanges.rauzy_class_cardinality</span> <span class="k">as</span> <span class="nn">rdc</span>

        <span class="n">profile</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()]</span>

        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)),</span> <span class="s2">&quot;if not None, left_degree should be an integer&quot;</span>
            <span class="n">left_degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">left_degree</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">left_degree</span> <span class="ow">in</span> <span class="n">profile</span><span class="p">,</span> <span class="s2">&quot;if not None, the degree should be one of the degree of the stratum&quot;</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">number_of_standard_permutations</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span><span class="n">left_degree</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">number_of_standard_permutations</span><span class="p">(</span><span class="n">profile</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.standard_permutations"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.standard_permutations">[docs]</a>    <span class="k">def</span> <span class="nf">standard_permutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of standard permutations.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: C = AbelianStratum(4).odd_component()</span>
<span class="sd">            sage: C</span>
<span class="sd">            H_3(4)^odd</span>
<span class="sd">            sage: for p in C.standard_permutations(): print(&quot;%s\n***********&quot; % p)</span>
<span class="sd">            0 1 2 3 4 5</span>
<span class="sd">            5 2 1 4 3 0</span>
<span class="sd">            ***********</span>
<span class="sd">            0 1 2 3 4 5</span>
<span class="sd">            5 3 1 4 2 0</span>
<span class="sd">            ***********</span>
<span class="sd">            0 1 2 3 4 5</span>
<span class="sd">            5 4 1 3 2 0</span>
<span class="sd">            ***********</span>
<span class="sd">            0 1 2 3 4 5</span>
<span class="sd">            5 2 4 1 3 0</span>
<span class="sd">            ***********</span>
<span class="sd">            0 1 2 3 4 5</span>
<span class="sd">            5 4 2 1 3 0</span>
<span class="sd">            ***********</span>
<span class="sd">            0 1 2 3 4 5</span>
<span class="sd">            5 2 4 3 1 0</span>
<span class="sd">            ***********</span>
<span class="sd">            0 1 2 3 4 5</span>
<span class="sd">            5 3 2 4 1 0</span>
<span class="sd">            ***********</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation_representative</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">rauzy_diagram</span><span class="p">(</span><span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">is_standard</span><span class="p">())</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.one_cylinder_diagram"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.one_cylinder_diagram">[docs]</a>    <span class="k">def</span> <span class="nf">one_cylinder_diagram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a diagram with one cylinder in this connected component.</span>

<span class="sd">        The diagram returned is the one deduced from the method</span>
<span class="sd">        permutation_representative.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: A = AbelianStratum(2,2).odd_component()</span>
<span class="sd">            sage: c = A.one_cylinder_diagram(); c</span>
<span class="sd">            (0,5,1,3,2,4)-(0,5,4,3,2,1)</span>
<span class="sd">            sage: c.stratum_component()</span>
<span class="sd">            H_3(2^2)^odd</span>

<span class="sd">            sage: A = AbelianStratum(3,3).non_hyperelliptic_component()</span>
<span class="sd">            sage: c = A.one_cylinder_diagram(); c</span>
<span class="sd">            (0,7,3,2,1,5,4,6)-(0,7,6,5,4,3,2,1)</span>
<span class="sd">            sage: c.stratum_component()</span>
<span class="sd">            H_4(3^2)^nonhyp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.separatrix_diagram</span> <span class="kn">import</span> <span class="n">CylinderDiagram</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation_representative</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to_standard</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">CylinderDiagram</span><span class="p">([(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])],</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.cylinder_diagram_iterator"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.cylinder_diagram_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">cylinder_diagram_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_computation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An iterator over the cylinder diagrams.</span>

<span class="sd">        INPUT::</span>

<span class="sd">        - ``ncyls`` -- (optional) a fixed number of cylinders</span>

<span class="sd">        - ``up_to_symmetry`` - (boolean, default ``True``) to return only</span>
<span class="sd">          cylinder diagrams up to horizontal and vertical symmetry.</span>

<span class="sd">        - ``force_computation`` -- (default ``False``) whether the database</span>
<span class="sd">          should be used or not</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: A = AbelianStratum(1,1,1,1)</span>
<span class="sd">            sage: cc = A.unique_component()</span>
<span class="sd">            sage: it = cc.cylinder_diagram_iterator(3)</span>
<span class="sd">            sage: cyl = next(it); cyl</span>
<span class="sd">            (0,7)-(0,5) (1,6)-(1,4) (2,4,3,5)-(2,7,3,6)</span>
<span class="sd">            sage: cyl.stratum_component()</span>
<span class="sd">            H_3(1^4)^c</span>
<span class="sd">            sage: cyl.ncyls()</span>
<span class="sd">            3</span>

<span class="sd">        Note that if you set ``force_computation`` to ``True`` the order of the</span>
<span class="sd">        iteration might be different and you might obtain cylinder diagram with some</span>
<span class="sd">        symmetries applied::</span>

<span class="sd">            sage: C1 = list(cc.cylinder_diagram_iterator(3, force_computation=False))  # long time</span>
<span class="sd">            sage: C2 = list(cc.cylinder_diagram_iterator(3, force_computation=True))   # long time</span>
<span class="sd">            sage: assert len(C1) == len(C2)                                            # long time</span>
<span class="sd">            sage: isoms = []                                                           # long time</span>
<span class="sd">            sage: for c in C1:                                                         # long time</span>
<span class="sd">            ....:     isom = []</span>
<span class="sd">            ....:     for i,cc in enumerate(C2):</span>
<span class="sd">            ....:         if c.is_isomorphic(cc) or \</span>
<span class="sd">            ....:            c.is_isomorphic(cc.horizontal_symmetry()) or \</span>
<span class="sd">            ....:            c.is_isomorphic(cc.vertical_symmetry()) or \</span>
<span class="sd">            ....:            c.is_isomorphic(cc.inverse()):</span>
<span class="sd">            ....:              isom.append(i)</span>
<span class="sd">            ....:     assert len(isom) == 1, isom</span>
<span class="sd">            ....:     isoms.extend(isom)</span>
<span class="sd">            sage: assert sorted(isoms) == list(range(len(C1)))                         # long time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ncyls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ncyls should be None or an integer&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ncyls</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ncyls</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_zeros</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ncyls is not valid&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_computation</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.databases.flat_surfaces</span> <span class="kn">import</span> <span class="n">CylinderDiagrams</span>
            <span class="n">CDB</span> <span class="o">=</span> <span class="n">CylinderDiagrams</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">CDB</span><span class="o">.</span><span class="n">has_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">iterator</span> <span class="o">=</span> <span class="n">CDB</span><span class="o">.</span><span class="n">get_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">up_to_symmetry</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">iterator</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_cylinder_diagrams_with_symmetric</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>

        <span class="n">iterator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">up_to_symmetry</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">iterator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_cylinder_diagrams_with_symmetric</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_cylinder_diagram_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Default implementation for cylinder diagrams for connected stratum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="AbelianStratumComponent.cylinder_diagrams"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.cylinder_diagrams">[docs]</a>    <span class="k">def</span> <span class="nf">cylinder_diagrams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_computation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of cylinder diagrams associated to this component.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ncyls`` - integer or list of integers (default: None) - consider</span>
<span class="sd">          only the cylinder diagrams with a given number of cylinders.</span>

<span class="sd">        - ``up_to_symmetry`` - (boolean, default ``True``) to return only</span>
<span class="sd">          cylinder diagrams up to horizontal and vertical symmetry.</span>

<span class="sd">        - ``force_computation`` -- boolean (default ``False``). If ``True``, the</span>
<span class="sd">          database of cylinder diagrams is not used.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: C = AbelianStratum(1,1,1,1).unique_component(); C</span>
<span class="sd">            H_3(1^4)^c</span>
<span class="sd">            sage: for c in C.cylinder_diagrams(6): print(c)</span>
<span class="sd">            (0,1)-(7) (2)-(0) (3)-(4) (4,7)-(5,6) (5)-(1) (6)-(2,3)</span>
<span class="sd">            (0,1)-(7) (2)-(1) (3)-(0) (4,7)-(5,6) (5)-(4) (6)-(2,3)</span>
<span class="sd">            (0,3)-(6,7) (1,2)-(4,5) (4)-(1) (5)-(3) (6)-(2) (7)-(0)</span>
<span class="sd">            (0,3)-(6,7) (1,2)-(4,5) (4)-(3) (5)-(0) (6)-(2) (7)-(1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="p">,</span> <span class="n">force_computation</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.cylinder_diagrams_number"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.cylinder_diagrams_number">[docs]</a>    <span class="k">def</span> <span class="nf">cylinder_diagrams_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">up_to_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_computation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of cylinder diagrams.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ncyls`` - integer or list of integers (default: None) - restrict the</span>
<span class="sd">          counting to a given number of cylinders.</span>

<span class="sd">        - ``up_to_symmetry`` - (boolean, default ``True``) to count only</span>
<span class="sd">          cylinder diagrams up to horizontal and vertical symmetry.</span>

<span class="sd">        - ``force_computation`` - (default: ``False``) whether we use the</span>
<span class="sd">          database or compute explicitly using the generation algorithm.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: C = AbelianStratum(3,1).unique_component()</span>
<span class="sd">            sage: C.cylinder_diagrams_number(1)</span>
<span class="sd">            2</span>
<span class="sd">            sage: C.cylinder_diagrams_number(2)</span>
<span class="sd">            12</span>
<span class="sd">            sage: C.cylinder_diagrams_number(3)</span>
<span class="sd">            16</span>
<span class="sd">            sage: C.cylinder_diagrams_number(4)</span>
<span class="sd">            4</span>

<span class="sd">        Note that when setting ``force_computation`` to ``True`` we got the</span>
<span class="sd">        same numbers::</span>

<span class="sd">            sage: for i in range(1,5):</span>
<span class="sd">            ....:     print(C.cylinder_diagrams_number(i, force_computation=True))</span>
<span class="sd">            2</span>
<span class="sd">            12</span>
<span class="sd">            16</span>
<span class="sd">            4</span>

<span class="sd">            sage: C = AbelianStratum(6)</span>
<span class="sd">            sage: C_hyp = C.hyperelliptic_component()</span>
<span class="sd">            sage: C_odd = C.odd_component()</span>
<span class="sd">            sage: C_even = C.even_component()</span>
<span class="sd">            sage: for i in range(1,5): print(C.cylinder_diagrams_number(i))</span>
<span class="sd">            16</span>
<span class="sd">            76</span>
<span class="sd">            130</span>
<span class="sd">            67</span>
<span class="sd">            sage: for i in range(1,5): print(C_hyp.cylinder_diagrams_number(i))</span>
<span class="sd">            1</span>
<span class="sd">            3</span>
<span class="sd">            8</span>
<span class="sd">            4</span>
<span class="sd">            sage: for i in range(1,5): print(C_odd.cylinder_diagrams_number(i))</span>
<span class="sd">            11</span>
<span class="sd">            49</span>
<span class="sd">            80</span>
<span class="sd">            42</span>

<span class="sd">            sage: for i in range(1,5):</span>
<span class="sd">            ....:     print(C_even.cylinder_diagrams_number(i, True, False))</span>
<span class="sd">            4</span>
<span class="sd">            24</span>
<span class="sd">            42</span>
<span class="sd">            21</span>
<span class="sd">            sage: for i in range(1,5):                                      # long time</span>
<span class="sd">            ....:     print(C_even.cylinder_diagrams_number(i, True, True)) # long time</span>
<span class="sd">            4</span>
<span class="sd">            24</span>
<span class="sd">            42</span>
<span class="sd">            21</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ncyls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ncyls</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_zeros</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_computation</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.databases.flat_surfaces</span> <span class="kn">import</span> <span class="n">CylinderDiagrams</span>
            <span class="n">CDB</span> <span class="o">=</span> <span class="n">CylinderDiagrams</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">CDB</span><span class="o">.</span><span class="n">has_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">up_to_symmetry</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">CDB</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">4</span> <span class="o">//</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cd</span><span class="o">.</span><span class="n">symmetries</span><span class="p">()))</span> <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">CDB</span><span class="o">.</span><span class="n">get_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">up_to_symmetry</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">4</span> <span class="o">//</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cd</span><span class="o">.</span><span class="n">symmetries</span><span class="p">()))</span> <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.one_origami"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.one_origami">[docs]</a>    <span class="k">def</span> <span class="nf">one_origami</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an origami in this component</span>

<span class="sd">        The origami returned has the minimal number of squares and one</span>
<span class="sd">        cylinder. It is obtained from the permutation representative of the</span>
<span class="sd">        stratum.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStratum(2,2).one_component()</span>
<span class="sd">            sage: a.one_origami().stratum()</span>
<span class="sd">            H_3(2^2)</span>

<span class="sd">            sage: AbelianStratum(3,2,1).unique_component().one_origami().stratum()</span>
<span class="sd">            H_4(3, 2, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.origamis.origami_dense</span> <span class="kn">import</span> <span class="n">Origami_dense_pyx</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation_representative</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to_standard</span><span class="p">()</span>
        <span class="n">t</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
        <span class="n">h_perm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v_perm</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">Origami_dense_pyx</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">h_perm</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v_perm</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.origami_iterator"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.origami_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">origami_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">primitive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator through the set of origamis with ``n`` squares in this stratum.</span>

<span class="sd">        The output origamis are in normal form. But be careful as there may be</span>
<span class="sd">        repetition in the output!</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``n`` - integer - the number of squares</span>

<span class="sd">        - ``reduced`` - boolean (default: ``True``)</span>

<span class="sd">        - ``primitive`` - boolean (default: ``False``)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cc = AbelianStratum(6).even_component()</span>
<span class="sd">            sage: it = cc.origami_iterator(13)</span>
<span class="sd">            sage: o = next(it)</span>
<span class="sd">            sage: o</span>
<span class="sd">            (1,2,3,4,5,6,7,8,9,10,11,12,13)</span>
<span class="sd">            (1,8,2)(3,12,6,11,5,13,7,9)(4,10)</span>
<span class="sd">            sage: o.stratum_component()</span>
<span class="sd">            H_4(6)^even</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reduced</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">reduced</span>
        <span class="n">primitive</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">primitive</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">():</span>
            <span class="n">do_h</span><span class="p">,</span> <span class="n">do_v</span><span class="p">,</span> <span class="n">do_i</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">symmetries</span><span class="p">()</span>
            <span class="n">do_h</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">do_h</span>
            <span class="n">do_v</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">do_v</span>
            <span class="n">do_i</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">do_i</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">origami_iterator</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">reduced</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">is_reduced</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">primitive</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">is_primitive</span><span class="p">())):</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">o</span>

                    <span class="k">if</span> <span class="n">do_h</span><span class="p">:</span>
                        <span class="n">oo</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">horizontal_symmetry</span><span class="p">()</span>
                        <span class="n">oo</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">oo</span>

                    <span class="k">if</span> <span class="n">do_v</span><span class="p">:</span>
                        <span class="n">oo</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">vertical_symmetry</span><span class="p">()</span>
                        <span class="n">oo</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">oo</span>

                    <span class="k">if</span> <span class="n">do_i</span><span class="p">:</span>
                        <span class="n">oo</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
                        <span class="n">oo</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">oo</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.origamis"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.origamis">[docs]</a>    <span class="k">def</span> <span class="nf">origamis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">primitive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of origamis with n squares in this stratum.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``n`` - integer - the number of squares</span>

<span class="sd">        - ``reduced`` - boolean (default: True)</span>

<span class="sd">        - ``primitive`` - boolean (default: False)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: H11_hyp = AbelianStratum(1,1).hyperelliptic_component()</span>
<span class="sd">            sage: len(H11_hyp.origamis(6))</span>
<span class="sd">            88</span>

<span class="sd">            sage: T6 = H11_hyp.arithmetic_teichmueller_curves(6)</span>
<span class="sd">            sage: len(T6)</span>
<span class="sd">            5</span>
<span class="sd">            sage: sum(t.veech_group().index() for t in T6)</span>
<span class="sd">            88</span>

<span class="sd">            sage: H4_odd = AbelianStratum(4).odd_component()</span>
<span class="sd">            sage: len(H4_odd.origamis(6))</span>
<span class="sd">            155</span>
<span class="sd">            sage: T6 = H4_odd.arithmetic_teichmueller_curves(6)</span>
<span class="sd">            sage: sum(t.veech_group().index() for t in T6)</span>
<span class="sd">            155</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origami_iterator</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">primitive</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.arithmetic_teichmueller_curves"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.arithmetic_teichmueller_curves">[docs]</a>    <span class="k">def</span> <span class="nf">arithmetic_teichmueller_curves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">primitive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the arithmetic Teichmueller curves in that component of stratum.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: A = AbelianStratum(2).hyperelliptic_component(); A</span>
<span class="sd">            H_2(2)^hyp</span>
<span class="sd">            sage: for i in range(3,10):</span>
<span class="sd">            ....:     print(&quot;%d %d&quot; % (i,len(A.arithmetic_teichmueller_curves(i))))</span>
<span class="sd">            3 1</span>
<span class="sd">            4 1</span>
<span class="sd">            5 2</span>
<span class="sd">            6 1</span>
<span class="sd">            7 2</span>
<span class="sd">            8 1</span>
<span class="sd">            9 2</span>

<span class="sd">            sage: A = AbelianStratum(1,1).hyperelliptic_component(); A</span>
<span class="sd">            H_2(1^2)^hyp</span>
<span class="sd">            sage: for i in range(4,10):</span>
<span class="sd">            ....:    T = A.arithmetic_teichmueller_curves(i)</span>
<span class="sd">            ....:    T_prim = list(filter(lambda t:t.origami().is_primitive(), T))</span>
<span class="sd">            ....:    print(&quot;%d %d %d&quot; % (i,len(T),len(T_prim)))</span>
<span class="sd">            4 2 1</span>
<span class="sd">            5 1 1</span>
<span class="sd">            6 5 2</span>
<span class="sd">            7 2 2</span>
<span class="sd">            8 4 2</span>
<span class="sd">            9 4 2</span>

<span class="sd">            sage: A = AbelianStratum(4).hyperelliptic_component(); A</span>
<span class="sd">            H_3(4)^hyp</span>
<span class="sd">            sage: for i in range(5,10):</span>
<span class="sd">            ....:    print(&quot;%d %d&quot; % (i,len(A.arithmetic_teichmueller_curves(i))))</span>
<span class="sd">            5 2</span>
<span class="sd">            6 4</span>
<span class="sd">            7 3</span>
<span class="sd">            8 3</span>
<span class="sd">            9 4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.origamis.teichmueller_curve</span> <span class="kn">import</span> <span class="n">TeichmuellerCurvesOfOrigamis</span>
        <span class="n">tcurves</span> <span class="o">=</span> <span class="n">TeichmuellerCurvesOfOrigamis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origamis</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">assume_normal_form</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">primitive</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tcurve</span> <span class="k">for</span> <span class="n">tcurve</span> <span class="ow">in</span> <span class="n">tcurves</span> <span class="k">if</span> <span class="n">tcurve</span><span class="o">.</span><span class="n">origami</span><span class="p">()</span><span class="o">.</span><span class="n">is_primitive</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">tcurves</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.lyapunov_exponents"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.lyapunov_exponents">[docs]</a>    <span class="k">def</span> <span class="nf">lyapunov_exponents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permutation_representative</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">lyapunov_exponents_H_plus</span><span class="p">(</span><span class="o">**</span><span class="n">kargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.single_cylinder_representative"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.single_cylinder_representative">[docs]</a>    <span class="k">def</span> <span class="nf">single_cylinder_representative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a single cylinder permutation representative.</span>

<span class="sd">        Returns a cylindric permutation representative of this connected</span>
<span class="sd">        stratum (or non-hyperelliptic component) such that the associated</span>
<span class="sd">        square-tiled surface is made of a single cylinder of height one in both</span>
<span class="sd">        horizontal and vertical direction.</span>

<span class="sd">        Such representatives were constructed for every stratum of Abelian</span>
<span class="sd">        differentials by Jeffreys [Jef19]_.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``alphabet`` -- an optional alphabet for the permutation representative</span>

<span class="sd">        - ``reduced`` (boolean, default ``True``) -- whether to return a reduced</span>
<span class="sd">          permutation (ie without labels)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cc = AbelianStratum(1,1,1,1).unique_component()</span>
<span class="sd">            sage: p = cc.single_cylinder_representative()</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8</span>
<span class="sd">            2 6 5 3 1 8 4 7 0</span>
<span class="sd">            sage: p.stratum_component() == cc</span>
<span class="sd">            True</span>

<span class="sd">            sage: cc = AbelianStratum(2,1,1).unique_component()</span>
<span class="sd">            sage: p = cc.single_cylinder_representative()</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1 2 3 4 5 6 7</span>
<span class="sd">            2 6 4 1 7 5 3 0</span>
<span class="sd">            sage: p.stratum_component() == cc</span>
<span class="sd">            True</span>

<span class="sd">            sage: cc = AbelianStratum(3,3).non_hyperelliptic_component()</span>
<span class="sd">            sage: p = cc.single_cylinder_representative(alphabet=Alphabet(name=&#39;lower&#39;))</span>
<span class="sd">            sage: p</span>
<span class="sd">            a b c d e f g h i</span>
<span class="sd">            c i g f h e b d a</span>
<span class="sd">            sage: p.stratum_component() == cc</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.single_cylinder</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cylinder_concatenation</span><span class="p">,</span>
                <span class="n">only_even_2</span><span class="p">,</span> <span class="n">only_odds_11</span><span class="p">,</span> <span class="n">odd_zeros_one_one</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.constructors</span> <span class="kn">import</span> <span class="n">GeneralizedPermutation</span>

        <span class="n">zeros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
        <span class="n">real_zeros</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zeros</span> <span class="k">if</span> <span class="n">z</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">odd_zeros</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">real_zeros</span> <span class="k">if</span> <span class="n">z</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">even_zeros</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">real_zeros</span> <span class="k">if</span> <span class="n">z</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">fk_zeros_perm</span> <span class="o">=</span> <span class="n">GeneralizedPermutation</span><span class="p">([</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mk_pt_perm</span> <span class="o">=</span> <span class="n">GeneralizedPermutation</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()):</span>
            <span class="n">fk_zeros_perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">mk_pt_perm</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">even_zeros</span> <span class="o">==</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">only_even_2</span><span class="p">(</span><span class="n">odd_zeros</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">odd_zeros</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">only_odds_11</span><span class="p">(</span><span class="n">even_zeros</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">even_zeros</span><span class="p">:</span>
                <span class="n">even_perm</span> <span class="o">=</span> <span class="n">AbelianStratum</span><span class="p">(</span><span class="n">even_zeros</span><span class="p">)</span><span class="o">.</span><span class="n">odd_component</span><span class="p">()</span><span class="o">.</span><span class="n">single_cylinder_representative</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">even_perm</span> <span class="o">=</span> <span class="n">GeneralizedPermutation</span><span class="p">([</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">odd_perm</span> <span class="o">=</span> <span class="n">odd_zeros_one_one</span><span class="p">(</span><span class="n">odd_zeros</span><span class="p">)</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">even_perm</span><span class="p">,</span><span class="n">odd_perm</span><span class="p">)</span>

        <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">perm</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">perm</span></div>

<div class="viewcode-block" id="AbelianStratumComponent.single_cylinder_origami"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStratumComponent.single_cylinder_origami">[docs]</a>    <span class="k">def</span> <span class="nf">single_cylinder_origami</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an origami associated to a single cylinder permutation representative.</span>

<span class="sd">        Returns an origami in this connected (or non-hyperelliptic) component</span>
<span class="sd">        having a single vertical cylinder and a single horizontal cylinder.</span>

<span class="sd">        Such representatives were constructed for every stratum of Abelian</span>
<span class="sd">        differentials by Jeffreys [Jef19]_.</span>

<span class="sd">        Examples::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cc = AbelianStratum(4).odd_component()</span>
<span class="sd">            sage: O = cc.single_cylinder_origami()</span>
<span class="sd">            sage: O</span>
<span class="sd">            (1,2,3,4,5)</span>
<span class="sd">            (1,4,3,5,2)</span>
<span class="sd">            sage: O.stratum_component() == cc</span>
<span class="sd">            True</span>
<span class="sd">            sage: cc = AbelianStratum(5,3).unique_component()</span>
<span class="sd">            sage: O = cc.single_cylinder_origami()</span>
<span class="sd">            sage: O</span>
<span class="sd">            (1,2,3,4,5,6,7,8,9,10)</span>
<span class="sd">            (1,9,8,10,6,7,4,3,5,2)</span>
<span class="sd">            sage: O.stratum_component() == cc</span>
<span class="sd">            True</span>
<span class="sd">            sage: cc = AbelianStratum(4,2).even_component()</span>
<span class="sd">            sage: O = cc.single_cylinder_origami()</span>
<span class="sd">            sage: O</span>
<span class="sd">            (1,2,3,4,5,6,7,8)</span>
<span class="sd">            (1,3,7,5,6,8,4,2)</span>
<span class="sd">            sage: O.stratum_component() == cc</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cylinder_representative</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">to_origami</span><span class="p">()</span></div></div>

<span class="n">ASC</span> <span class="o">=</span> <span class="n">AbelianStratumComponent</span>

<div class="viewcode-block" id="HypAbelianStratumComponent"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.HypAbelianStratumComponent">[docs]</a><span class="k">class</span> <span class="nc">HypAbelianStratumComponent</span><span class="p">(</span><span class="n">ASC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hyperelliptic component of Abelian stratum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;hyp&#39;</span>

<div class="viewcode-block" id="HypAbelianStratumComponent.spin"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.HypAbelianStratumComponent.spin">[docs]</a>    <span class="k">def</span> <span class="nf">spin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spin parity of hyperelliptic stratum.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        For the strata `H(2g-2)`::</span>

<span class="sd">            sage: c = AbelianStratum(0).hyperelliptic_component()</span>
<span class="sd">            sage: c.spin()</span>
<span class="sd">            1</span>
<span class="sd">            sage: p = c.permutation_representative()</span>
<span class="sd">            sage: p.arf_invariant()</span>
<span class="sd">            1</span>

<span class="sd">            sage: c = AbelianStratum(2).hyperelliptic_component()</span>
<span class="sd">            sage: c.spin()</span>
<span class="sd">            1</span>
<span class="sd">            sage: p = c.permutation_representative()</span>
<span class="sd">            sage: p.arf_invariant()</span>
<span class="sd">            1</span>

<span class="sd">            sage: c = AbelianStratum(4).hyperelliptic_component()</span>
<span class="sd">            sage: c.spin()</span>
<span class="sd">            0</span>
<span class="sd">            sage: p = c.permutation_representative()</span>
<span class="sd">            sage: p.arf_invariant()</span>
<span class="sd">            0</span>

<span class="sd">        For the strata `H(g-1,g-1)`::</span>

<span class="sd">            sage: c = AbelianStratum(2,2).hyperelliptic_component()</span>
<span class="sd">            sage: c.spin()</span>
<span class="sd">            0</span>
<span class="sd">            sage: p = c.permutation_representative()</span>
<span class="sd">            sage: p.arf_invariant()</span>
<span class="sd">            0</span>

<span class="sd">            sage: c = AbelianStratum(4,4).hyperelliptic_component()</span>
<span class="sd">            sage: c.spin()</span>
<span class="sd">            1</span>
<span class="sd">            sage: p = c.permutation_representative()</span>
<span class="sd">            sage: p.arf_invariant()</span>
<span class="sd">            1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fake_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">z</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="HypAbelianStratumComponent.permutation_representative"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.HypAbelianStratumComponent.permutation_representative">[docs]</a>    <span class="k">def</span> <span class="nf">permutation_representative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Zorich representative of this connected component.</span>

<span class="sd">        Zorich constructs explicitly interval exchange</span>
<span class="sd">        transformations for each stratum in [Zor08]_.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``reduced`` - boolean (default: ``True``): whether you obtain</span>
<span class="sd">          a reduced or labelled permutation</span>

<span class="sd">        - ``alphabet`` - alphabet or ``None`` (default: ``None``):</span>
<span class="sd">          whether you want to specify an alphabet for your</span>
<span class="sd">          representative</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = AbelianStratum(0).hyperelliptic_component()</span>
<span class="sd">            sage: p = c.permutation_representative()</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1</span>
<span class="sd">            1 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_1(0)^hyp</span>

<span class="sd">            sage: c = AbelianStratum(0,0).hyperelliptic_component()</span>
<span class="sd">            sage: p = c.permutation_representative(alphabet=&quot;abc&quot;)</span>
<span class="sd">            sage: p</span>
<span class="sd">            a b c</span>
<span class="sd">            c b a</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_1(0^2)^hyp</span>

<span class="sd">            sage: c = AbelianStratum(2,2).hyperelliptic_component()</span>
<span class="sd">            sage: p = c.permutation_representative(alphabet=&quot;ABCDEFGHIJKL&quot;)</span>
<span class="sd">            sage: p</span>
<span class="sd">            A B C D E F G</span>
<span class="sd">            G F E D C B A</span>
<span class="sd">            sage: c = AbelianStratum(1,1,0).hyperelliptic_component()</span>
<span class="sd">            sage: p = c.permutation_representative(left_degree=1); p</span>
<span class="sd">            0 1 2 3 4 5</span>
<span class="sd">            5 1 4 3 2 0</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            2</span>
<span class="sd">            sage: p.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 90 permutations</span>

<span class="sd">            sage: p = c.permutation_representative(left_degree=0); p</span>
<span class="sd">            0 1 2 3 4 5</span>
<span class="sd">            5 3 2 1 4 0</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            1</span>
<span class="sd">            sage: p.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 20 permutations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stratum</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stratum</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stratum</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fake_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">))</span> <span class="ow">or</span> <span class="n">left_degree</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left_degree (=</span><span class="si">%d</span><span class="s2">) should be one of the degree&quot;</span><span class="o">%</span><span class="n">left_degree</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># on the torus</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">l0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">l0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># H(2g-2,0^n) or H(0,2g-2,0^(n-1))</span>
            <span class="n">l0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">left_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">l0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                <span class="n">l1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l0</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                <span class="n">l1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># H(g-1,g-1,0^n) or H(0,g-1,g-1,0^(n-1))</span>
            <span class="n">l0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">left_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">l0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                <span class="n">l1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l0</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                <span class="n">l1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>

        <span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.reduced</span> <span class="kn">import</span> <span class="n">ReducedPermutationIET</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">ReducedPermutationIET</span><span class="p">([</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.labelled</span> <span class="kn">import</span> <span class="n">LabelledPermutationIET</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">LabelledPermutationIET</span><span class="p">([</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">relabel</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="HypAbelianStratumComponent.rauzy_class_cardinality"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.HypAbelianStratumComponent.rauzy_class_cardinality">[docs]</a>    <span class="k">def</span> <span class="nf">rauzy_class_cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cardinality of the extended Rauzy diagram associated to the</span>
<span class="sd">        hyperelliptic component</span>

<span class="sd">        The cardinality of the Rauzy diagram or extended Rauzy diagram</span>
<span class="sd">        associated to `H_{hyp}(2g-2,0^k)` or `H_{hyp}(g-1,g-1,0^k)` depends only</span>
<span class="sd">        on the dimension `d` of the initial stratum `\mathcal{H}_{hyp}(2g-2)`</span>
<span class="sd">        for which `d=2g` or `\mathcal{H}_{hyp}(g-1,g-1)` for which</span>
<span class="sd">        `d=2g+1` and the number of fake zeros `k`. The formula is</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \binom{d+k+1}{k} (2^{d-1}-1) + d \binom{d+k}{k-1}</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``left_degree`` - integer - the degree of the singularity attached at</span>
<span class="sd">          the left of the interval.</span>

<span class="sd">        - ``reduced`` - boolean (default: True) - if False, consider labeled</span>
<span class="sd">          Rauzy diagrams instead of reduced.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        The case of the torus is a little bit different::</span>

<span class="sd">            sage: c = AbelianStratum(0).hyperelliptic_component()</span>
<span class="sd">            sage: c.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 1 permutation</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            1</span>
<span class="sd">            sage: c = AbelianStratum(0,0).hyperelliptic_component()</span>
<span class="sd">            sage: c.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 3 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            3</span>

<span class="sd">        Examples in genus 2::</span>

<span class="sd">            sage: c = AbelianStratum(2,0).hyperelliptic_component()</span>
<span class="sd">            sage: c.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 46 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            46</span>

<span class="sd">            sage: c.rauzy_diagram(left_degree=2)</span>
<span class="sd">            Rauzy diagram with 35 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=2)</span>
<span class="sd">            35</span>

<span class="sd">            sage: c.rauzy_diagram(left_degree=0)</span>
<span class="sd">            Rauzy diagram with 11 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=0)</span>
<span class="sd">            11</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=0, reduced=False)</span>
<span class="sd">            Rauzy diagram with 33 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=0, reduced=False)</span>
<span class="sd">            33</span>

<span class="sd">            sage: c = AbelianStratum(1,1,0,0).hyperelliptic_component()</span>
<span class="sd">            sage: c.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 455 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            455</span>

<span class="sd">            sage: c.rauzy_diagram(left_degree=1)</span>
<span class="sd">            Rauzy diagram with 315 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=1)</span>
<span class="sd">            315</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=1, reduced=False)</span>
<span class="sd">            Rauzy diagram with 630 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=1, reduced=False)</span>
<span class="sd">            630</span>

<span class="sd">            sage: c.rauzy_diagram(left_degree=0)</span>
<span class="sd">            Rauzy diagram with 140 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=0)</span>
<span class="sd">            140</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=0, reduced=False)</span>
<span class="sd">            Rauzy diagram with 560 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=0, reduced=False)</span>
<span class="sd">            560</span>

<span class="sd">        Other examples in higher genus::</span>

<span class="sd">            sage: c = AbelianStratum(12,0,0).hyperelliptic_component()</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            1114200</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=12, reduced=False)</span>
<span class="sd">            1965840</span>

<span class="sd">            sage: c = AbelianStratum(14).hyperelliptic_component()</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            32767</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.arith.all</span> <span class="kn">import</span> <span class="n">binomial</span>

        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)),</span> <span class="s2">&quot;if not None, left_degree should be an integer&quot;</span>
            <span class="k">assert</span> <span class="n">left_degree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">(),</span> <span class="s2">&quot;if not None, the degree should be one of the degree of the stratum&quot;</span>

        <span class="k">if</span> <span class="n">reduced</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;no formula known for cardinality of labeled extended Rauzy classes&quot;</span><span class="p">)</span>
            <span class="n">zeros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">Partition</span><span class="p">([</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">zeros</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_zeros</span><span class="p">(</span><span class="n">fake_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">genus</span><span class="p">()))</span>
            <span class="k">return</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">centralizer_size</span><span class="p">()</span> <span class="o">/</span>
                    <span class="p">((</span><span class="n">left_degree</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">zeros</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">left_degree</span><span class="p">))</span> <span class="o">*</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rauzy_class_cardinality</span><span class="p">(</span><span class="n">left_degree</span><span class="o">=</span><span class="n">left_degree</span><span class="p">,</span><span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>  <span class="c1"># it is d+k</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-</span><span class="n">k</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">binomial</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binomial</span><span class="p">(</span><span class="n">dd</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">binomial</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">left_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binomial</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binomial</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="HypAbelianStratumComponent.random_standard_permutation"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.HypAbelianStratumComponent.random_standard_permutation">[docs]</a>    <span class="k">def</span> <span class="nf">random_standard_permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In hyperelliptic component there is only one standard permutation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation_representative</span><span class="p">()</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;not implemented when there are fake zeros&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HypAbelianStratumComponent.standard_permutations"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.HypAbelianStratumComponent.standard_permutations">[docs]</a>    <span class="k">def</span> <span class="nf">standard_permutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the standard permutations in this hyperelliptic component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStratum(6).hyperelliptic_component().standard_permutations()</span>
<span class="sd">            [0 1 2 3 4 5 6 7</span>
<span class="sd">             7 6 5 4 3 2 1 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">():</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
            <span class="n">l0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.reduced</span> <span class="kn">import</span> <span class="n">ReducedPermutationIET</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">ReducedPermutationIET</span><span class="p">([</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.labelled</span> <span class="kn">import</span> <span class="n">LabelledPermutationIET</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">LabelledPermutationIET</span><span class="p">([</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;not implemented when there are fake zeros&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HypAbelianStratumComponent.standard_permutations_number"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.HypAbelianStratumComponent.standard_permutations_number">[docs]</a>    <span class="k">def</span> <span class="nf">standard_permutations_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of standard permutations in this hyperelliptic</span>
<span class="sd">        component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;not implemented when there are fake zeros&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_cylinder_diagram_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of cylinder diagrams associated to this hyperelliptic</span>
<span class="sd">        component.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``ncyls`` -- an optional number of cylinders</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: C = AbelianStratum(2,2).hyperelliptic_component()</span>
<span class="sd">            sage: [sum(1 for c in C.cylinder_diagram_iterator(n)) for n in range(1,5)]</span>
<span class="sd">            [1, 3, 5, 2]</span>

<span class="sd">        When ``ncyls`` is set to ``None``, the iterator can reasonably be used</span>
<span class="sd">        with very large data::</span>

<span class="sd">            sage: C = AbelianStratum(10,10).hyperelliptic_component()</span>
<span class="sd">            sage: it = C.cylinder_diagram_iterator()</span>
<span class="sd">            sage: c = next(it)</span>
<span class="sd">            sage: c.is_isomorphic(CylinderDiagram(&#39;(0,2,5,1)-(0,2,21,1) (3,4)-(3,6) (6,19)-(4,20) (7,9)-(8,10) (8,12)-(7,11) (10,14)-(9,13) (11,15)-(12,16) (13,17)-(14,18) (16,20)-(15,19) (18,21)-(5,17)&#39;))</span>
<span class="sd">            True</span>
<span class="sd">            sage: c.stratum_component()</span>
<span class="sd">            H_11(10^2)^hyp</span>
<span class="sd">            sage: c.ncyls()</span>
<span class="sd">            10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.separatrix_diagram</span> <span class="kn">import</span> <span class="n">hyperelliptic_cylinder_diagram_iterator</span>

        <span class="k">if</span> <span class="n">ncyls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ncyls</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ncyls</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">ncyls</span><span class="p">()</span> <span class="o">==</span> <span class="n">ncyls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">())</span>

        <span class="n">stratum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">stratum</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the stratum has fake zeros&quot;</span><span class="p">)</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">hyperelliptic_cylinder_diagram_iterator</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>

<div class="viewcode-block" id="HypAbelianStratumComponent.single_cylinder_representative"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.HypAbelianStratumComponent.single_cylinder_representative">[docs]</a>    <span class="k">def</span> <span class="nf">single_cylinder_representative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a single cylinder permutation representative.</span>

<span class="sd">        Returns a permutation representative of a square-tiled surface in this</span>
<span class="sd">        component having a single vertical cylinder and a single horizontal cylinder.</span>

<span class="sd">        Such representatives were constructed for every stratum of Abelian</span>
<span class="sd">        differentials by Jeffreys [Jef19]_.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``alphabet`` -- an optional alphabet for the permutation representative</span>

<span class="sd">        - ``reduced`` (boolean, default ``True``) -- whether to return a reduced</span>
<span class="sd">          permutation (ie without labels)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cc = AbelianStratum(2,0).hyperelliptic_component()</span>
<span class="sd">            sage: p = cc.single_cylinder_representative(alphabet=Alphabet(name=&#39;upper&#39;))</span>
<span class="sd">            sage: p</span>
<span class="sd">            A B C D E</span>
<span class="sd">            E D B C A</span>
<span class="sd">            sage: p.stratum_component() == cc</span>
<span class="sd">            True</span>

<span class="sd">            sage: cc = AbelianStratum({3:2,0:6}).hyperelliptic_component()</span>
<span class="sd">            sage: p = cc.single_cylinder_representative()</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10 11 12 13 14</span>
<span class="sd">            14 12 13 10 11 8 9 7 5 6 3 4 1 2 0</span>
<span class="sd">            sage: p.stratum_component() == cc</span>
<span class="sd">            True</span>

<span class="sd">            sage: cc = AbelianStratum(2).hyperelliptic_component()</span>
<span class="sd">            sage: cc.single_cylinder_representative()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no 1,1-square-tiled surfaces in this connected component try again with H_2(2, 0)^hyp</span>
<span class="sd">            sage: cc = AbelianStratum({3:2,0:5}).hyperelliptic_component()</span>
<span class="sd">            sage: cc.single_cylinder_representative()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: no 1,1-square-tiled surfaces in this connected component try again with H_4(3^2, 0^6)^hyp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stratum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span>
        <span class="n">genus</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>
        <span class="n">nb_fk_zeros</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()</span>
        <span class="n">nb_real_zeros</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">nb_zeros</span><span class="p">()</span><span class="o">-</span><span class="n">nb_fk_zeros</span>
        <span class="n">add_fk_zeros</span> <span class="o">=</span> <span class="n">nb_fk_zeros</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">genus</span><span class="o">+</span><span class="mi">4</span><span class="o">-</span><span class="n">nb_real_zeros</span>

        <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.constructors</span> <span class="kn">import</span> <span class="n">GeneralizedPermutation</span>

        <span class="k">if</span> <span class="n">nb_real_zeros</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">add_fk_zeros</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no 1,1-square-tiled surfaces in this connected component try again with </span><span class="si">%s</span><span class="s2">^hyp&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">AbelianStratum</span><span class="p">({</span><span class="mi">2</span><span class="o">*</span><span class="n">genus</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">genus</span><span class="o">-</span><span class="mi">3</span><span class="p">}))))</span>
        <span class="k">elif</span> <span class="n">nb_real_zeros</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">add_fk_zeros</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no 1,1-square-tiled surfaces in this connected component try again with </span><span class="si">%s</span><span class="s2">^hyp&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">AbelianStratum</span><span class="p">({</span><span class="n">genus</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">genus</span><span class="o">-</span><span class="mi">2</span><span class="p">}))))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">nb_real_zeros</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.single_cylinder</span> <span class="kn">import</span> <span class="n">cylinder_concatenation</span>
            <span class="n">fk_zeros_perm</span> <span class="o">=</span> <span class="n">GeneralizedPermutation</span><span class="p">([</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">mk_pt_perm</span> <span class="o">=</span> <span class="n">GeneralizedPermutation</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_fk_zeros</span><span class="p">):</span>
                <span class="n">fk_zeros_perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span> <span class="n">mk_pt_perm</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fk_zeros_perm</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">fk_zeros_perm</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span> <span class="k">if</span> <span class="n">reduced</span> <span class="k">else</span> <span class="n">fk_zeros_perm</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">top_row</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">genus</span><span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nb_real_zeros</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">add_fk_zeros</span><span class="p">))</span>
            <span class="n">bot_row</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">genus</span><span class="o">-</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nb_real_zeros</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">add_fk_zeros</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">genus</span><span class="o">-</span><span class="mi">6</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nb_real_zeros</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">add_fk_zeros</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">genus</span><span class="o">-</span><span class="mi">2</span><span class="o">+</span><span class="n">add_fk_zeros</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">bot_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">bot_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">bot_row</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">genus</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">add_fk_zeros</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">genus</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">bot_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">bot_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">bot_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">perm</span> <span class="o">=</span> <span class="n">GeneralizedPermutation</span><span class="p">(</span><span class="n">top_row</span><span class="p">,</span> <span class="n">bot_row</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="n">reduced</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">perm</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">perm</span></div></div>


<span class="n">HypASC</span> <span class="o">=</span> <span class="n">HypAbelianStratumComponent</span>

<div class="viewcode-block" id="NonHypAbelianStratumComponent"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.NonHypAbelianStratumComponent">[docs]</a><span class="k">class</span> <span class="nc">NonHypAbelianStratumComponent</span><span class="p">(</span><span class="n">ASC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Non hyperelliptic component of Abelian stratum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;nonhyp&#39;</span>

<div class="viewcode-block" id="NonHypAbelianStratumComponent.rauzy_class_cardinality"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.NonHypAbelianStratumComponent.rauzy_class_cardinality">[docs]</a>    <span class="k">def</span> <span class="nf">rauzy_class_cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cardinality of Rauzy diagram associated to this non</span>
<span class="sd">        hyperelliptic component.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``left_degree`` - integer</span>

<span class="sd">        - ``reduced`` - boolean (default: True)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        Examples in genus 3::</span>

<span class="sd">            sage: c = AbelianStratum(3,3).non_hyperelliptic_component()</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            15568</span>

<span class="sd">            sage: c = AbelianStratum(3,3,0).non_hyperelliptic_component()</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            173723</span>

<span class="sd">            sage: c.rauzy_diagram(left_degree=3)  # long time</span>
<span class="sd">            Rauzy diagram with 155680 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=3)</span>
<span class="sd">            155680</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=3, reduced=False)  # not tested</span>
<span class="sd">            Rauzy diagram with 311360 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=3, reduced=False)</span>
<span class="sd">            311360</span>

<span class="sd">            sage: c.rauzy_diagram(left_degree=0)  # long time</span>
<span class="sd">            Rauzy diagram with 18043 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=0)</span>
<span class="sd">            18043</span>
<span class="sd">            sage: cc.rauzy_diagram(left_degree=0, reduced=False) # not tested</span>
<span class="sd">            Rauzy diagram with 288688 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=0,reduced=False)</span>
<span class="sd">            288688</span>

<span class="sd">        When genus growths, the size of the Rauzy diagram becomes very big::</span>

<span class="sd">            sage: c = AbelianStratum(5,5).non_hyperelliptic_component()</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            136116680</span>

<span class="sd">            sage: c = AbelianStratum(7,7,0).non_hyperelliptic_component()</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            88484743236111</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=7, reduced=False)</span>
<span class="sd">            334071852804864</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">surface_dynamics.interval_exchanges.rauzy_class_cardinality</span> <span class="k">as</span> <span class="nn">rdc</span>

        <span class="n">profile</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()))</span>
        <span class="n">hyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">hyperelliptic_component</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)),</span> <span class="s2">&quot;if not None, left_degree should be an integer&quot;</span>
            <span class="n">left_degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">left_degree</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">left_degree</span> <span class="ow">in</span> <span class="n">profile</span><span class="p">,</span> <span class="s2">&quot;if not None, the degree should be one of the degree of the stratum&quot;</span>

            <span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">gamma_irr</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span><span class="n">left_degree</span><span class="p">))</span>
                <span class="n">n_hyp</span> <span class="o">=</span> <span class="n">hyp</span><span class="o">.</span><span class="n">rauzy_class_cardinality</span><span class="p">(</span><span class="n">left_degree</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Rational</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">Partition</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span><span class="o">.</span><span class="n">centralizer_size</span><span class="p">()</span> <span class="o">/</span>
                    <span class="p">((</span><span class="n">left_degree</span><span class="p">)</span> <span class="o">*</span> <span class="n">profile</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">left_degree</span><span class="p">))</span> <span class="o">*</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rauzy_class_cardinality</span><span class="p">(</span><span class="n">left_degree</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">reduced</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">gamma_irr</span><span class="p">(</span><span class="n">profile</span><span class="p">))</span>
            <span class="n">n_hyp</span> <span class="o">=</span> <span class="n">hyp</span><span class="o">.</span><span class="n">rauzy_class_cardinality</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;no formula known for cardinality of  extended labeled Rauzy classes&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n_hyp</span></div>

<div class="viewcode-block" id="NonHypAbelianStratumComponent.standard_permutations_number"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.NonHypAbelianStratumComponent.standard_permutations_number">[docs]</a>    <span class="k">def</span> <span class="nf">standard_permutations_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: C = AbelianStratum(3,3).non_hyperelliptic_component()</span>
<span class="sd">            sage: len(C.standard_permutations())  # long time</span>
<span class="sd">            275</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            275</span>

<span class="sd">            sage: C = AbelianStratum(5,5).non_hyperelliptic_component()</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            1022399</span>

<span class="sd">            sage: C = AbelianStratum(7,7).non_hyperelliptic_component()</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            19229011199</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">surface_dynamics.interval_exchanges.rauzy_class_cardinality</span> <span class="k">as</span> <span class="nn">rdc</span>

        <span class="n">profile</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">rdc</span><span class="o">.</span><span class="n">number_of_standard_permutations</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">hyperelliptic_component</span><span class="p">()</span><span class="o">.</span><span class="n">standard_permutations_number</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_cylinder_diagram_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of cylinder diagrams (or completely periodic</span>
<span class="sd">        configurations) associated to this non-hyperelliptic component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cc = AbelianStratum(3,3).non_hyperelliptic_component()</span>
<span class="sd">            sage: it = cc.cylinder_diagram_iterator()</span>
<span class="sd">            sage: c0 = next(it); c0</span>
<span class="sd">            (0,1,4,6,2,5,3,7)-(0,1,4,5,3,6,2,7)</span>
<span class="sd">            sage: c0.stratum_component()</span>
<span class="sd">            H_4(3^2)^nonhyp</span>

<span class="sd">            sage: it = cc.cylinder_diagram_iterator(4, force_computation=True)</span>
<span class="sd">            sage: c0 = next(it); c0  # random</span>
<span class="sd">            (0,4,2)-(0,6) (1,5,3)-(1,7) (6)-(4,5) (7)-(2,3)</span>
<span class="sd">            sage: c0.stratum_component()</span>
<span class="sd">            H_4(3^2)^nonhyp</span>
<span class="sd">            sage: c0.ncyls()</span>
<span class="sd">            4</span>
<span class="sd">            sage: all(cd.stratum_component() == cc and cd.ncyls() == 4 for cd in it)</span>
<span class="sd">            True</span>
<span class="sd">            sage: sum(1 for _ in cc.cylinder_diagram_iterator(4, force_computation=True))</span>
<span class="sd">            184</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_hyperelliptic</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>

<span class="n">NonHypASC</span> <span class="o">=</span> <span class="n">NonHypAbelianStratumComponent</span>

<div class="viewcode-block" id="EvenAbelianStratumComponent"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.EvenAbelianStratumComponent">[docs]</a><span class="k">class</span> <span class="nc">EvenAbelianStratumComponent</span><span class="p">(</span><span class="n">ASC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connected component of Abelian stratum with even spin structure.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Internal class! Do not use directly!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;even&#39;</span>

<div class="viewcode-block" id="EvenAbelianStratumComponent.spin"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.EvenAbelianStratumComponent.spin">[docs]</a>    <span class="k">def</span> <span class="nf">spin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``0``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = AbelianStratum(4,2).even_component(); c</span>
<span class="sd">            H_4(4, 2)^even</span>
<span class="sd">            sage: c.spin()</span>
<span class="sd">            0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="EvenAbelianStratumComponent.permutation_representative"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.EvenAbelianStratumComponent.permutation_representative">[docs]</a>    <span class="k">def</span> <span class="nf">permutation_representative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Zorich representative of this connected component.</span>

<span class="sd">        Zorich constructs explicitly interval exchange</span>
<span class="sd">        transformations for each stratum in [Zor08]_.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``reduced`` - boolean (default: True): whether you obtain a reduced or</span>
<span class="sd">          labelled permutation</span>

<span class="sd">        - ``left_degree`` - integer (optional) - a specified degree of zero at</span>
<span class="sd">          the left of the interval.</span>

<span class="sd">        - ``alphabet`` - alphabet or None (default: None): whether you want to</span>
<span class="sd">          specify an alphabet for your representative</span>

<span class="sd">        - ``relabel`` - boolean (default: True) - if False uses Zorich&#39;s natural</span>
<span class="sd">          numbering otherwise uses 0,1,...</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = AbelianStratum(6).even_component()</span>
<span class="sd">            sage: c</span>
<span class="sd">            H_4(6)^even</span>
<span class="sd">            sage: p = c.permutation_representative(alphabet=range(8))</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1 2 3 4 5 6 7</span>
<span class="sd">            5 4 3 2 7 6 1 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(6)^even</span>

<span class="sd">        ::</span>

<span class="sd">            sage: c = AbelianStratum(4,4).even_component()</span>
<span class="sd">            sage: c</span>
<span class="sd">            H_5(4^2)^even</span>
<span class="sd">            sage: p = c.permutation_representative(alphabet=range(11))</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10</span>
<span class="sd">            5 4 3 2 6 8 7 10 9 1 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_5(4^2)^even</span>

<span class="sd">        Different markings lead to different Rauzy diagrams::</span>

<span class="sd">            sage: c = AbelianStratum(4,2,0).even_component()</span>
<span class="sd">            sage: p = c.permutation_representative(left_degree=4); p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9</span>
<span class="sd">            6 5 4 3 7 9 8 2 0 1</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(4, 2, 0)^even</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            5</span>
<span class="sd">            sage: p.rauzy_diagram()   # long time</span>
<span class="sd">            Rauzy diagram with 66140 permutations</span>

<span class="sd">            sage: p = c.permutation_representative(left_degree=2); p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9</span>
<span class="sd">            7 6 5 4 3 9 8 2 0 1</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(4, 2, 0)^even</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            3</span>
<span class="sd">            sage: p.rauzy_diagram()   # long time</span>
<span class="sd">            Rauzy diagram with 39540 permutations</span>

<span class="sd">            sage: p = c.permutation_representative(left_degree=0); p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9</span>
<span class="sd">            6 4 3 2 7 9 8 1 5 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(4, 2, 0)^even</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            1</span>
<span class="sd">            sage: p.rauzy_diagram()   # long time</span>
<span class="sd">            Rauzy diagram with 11792 permutations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stratum</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fake_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stratum</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stratum</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left_degree (=</span><span class="si">%d</span><span class="s2">) should be one of the degree&quot;</span><span class="o">%</span><span class="n">left_degree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">left_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left_degree (=</span><span class="si">%d</span><span class="s2">) should be one of the degree&quot;</span> <span class="o">%</span> <span class="n">left_degree</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">left_degree</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">z</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left_degree (=</span><span class="si">%d</span><span class="s2">) should be one of the degree&quot;</span> <span class="o">%</span> <span class="n">left_degree</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">left_degree</span><span class="p">)</span>
                <span class="n">z</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">left_degree</span><span class="p">)</span>

        <span class="n">l0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">l1</span> <span class="o">+=</span> <span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">l1</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">k</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">z</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">l0</span><span class="p">[</span><span class="n">l0</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                <span class="k">del</span> <span class="n">l1</span><span class="p">[</span><span class="n">l1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">3</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">3</span>

        <span class="c1"># if there are marked points we transform 0 in [3g-2, 3g-3, ...]</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">g</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">left_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">l0</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
                <span class="n">l0</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                <span class="n">l1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l0</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                <span class="n">l1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.reduced</span> <span class="kn">import</span> <span class="n">ReducedPermutationIET</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">ReducedPermutationIET</span><span class="p">([</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.labelled</span> <span class="kn">import</span> <span class="n">LabelledPermutationIET</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">LabelledPermutationIET</span><span class="p">([</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">relabel</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="EvenAbelianStratumComponent.rauzy_class_cardinality"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.EvenAbelianStratumComponent.rauzy_class_cardinality">[docs]</a>    <span class="k">def</span> <span class="nf">rauzy_class_cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cardinality of rauzy diagram for even component of a stratum</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``left_degree`` - integer</span>

<span class="sd">        - ``reduced`` - boolean</span>


<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = AbelianStratum(6).even_component()</span>
<span class="sd">            sage: c.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 2327 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            2327</span>

<span class="sd">            sage: c = AbelianStratum(4,2,0).even_component()</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            117472</span>

<span class="sd">            sage: c.rauzy_diagram(left_degree=4)  # long time</span>
<span class="sd">            Rauzy diagram with 66140 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=4)</span>
<span class="sd">            66140</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=4, reduced=False)  # long time</span>
<span class="sd">            Rauzy diagram with 198420 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=4,reduced=False)</span>
<span class="sd">            198420</span>

<span class="sd">            sage: c.rauzy_class_cardinality(2)</span>
<span class="sd">            39540</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=2)  # long time</span>
<span class="sd">            Rauzy diagram with 39540 permutations</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=2, reduced=False)  # long time</span>
<span class="sd">            Rauzy diagram with 197700 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=2, reduced=False)</span>
<span class="sd">            197700</span>

<span class="sd">            sage: c.rauzy_class_cardinality(0)</span>
<span class="sd">            11792</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=0)</span>
<span class="sd">            Rauzy diagram with 11792 permutations</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=0, reduced=False)  # long time</span>
<span class="sd">            Rauzy diagram with 176880 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=0, reduced=False)</span>
<span class="sd">            176880</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">surface_dynamics.interval_exchanges.rauzy_class_cardinality</span> <span class="k">as</span> <span class="nn">rdc</span>

        <span class="n">profile</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)),</span> <span class="s2">&quot;if not None, left_degree should be an integer&quot;</span>
            <span class="n">left_degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">left_degree</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">left_degree</span> <span class="ow">in</span> <span class="n">profile</span><span class="p">,</span> <span class="s2">&quot;if not None, the degree should be one of the degree of the stratum&quot;</span>

            <span class="k">if</span> <span class="n">reduced</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">Partition</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span><span class="o">.</span><span class="n">centralizer_size</span><span class="p">()</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">left_degree</span> <span class="o">*</span> <span class="n">profile</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">left_degree</span><span class="p">))</span> <span class="o">*</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rauzy_class_cardinality</span><span class="p">(</span><span class="n">left_degree</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">reduced</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;no formula known for extended labeled Rauzy classes&quot;</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">gamma_irr</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span><span class="n">left_degree</span><span class="p">)</span> <span class="o">-</span> <span class="n">rdc</span><span class="o">.</span><span class="n">delta_irr</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span><span class="n">left_degree</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">number_of_components</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">hyperelliptic_component</span><span class="p">()</span><span class="o">.</span><span class="n">spin</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hyp_card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">hyperelliptic_component</span><span class="p">()</span><span class="o">.</span><span class="n">rauzy_class_cardinality</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hyp_card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">hyperelliptic_component</span><span class="p">()</span><span class="o">.</span><span class="n">rauzy_class_cardinality</span><span class="p">(</span><span class="n">left_degree</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">N</span> <span class="o">-</span> <span class="n">hyp_card</span>

        <span class="k">return</span> <span class="n">N</span></div>

<div class="viewcode-block" id="EvenAbelianStratumComponent.standard_permutations_number"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.EvenAbelianStratumComponent.standard_permutations_number">[docs]</a>    <span class="k">def</span> <span class="nf">standard_permutations_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of standard permutation of this even component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        For strata in genus 3, the number of standard permutations is reasonably</span>
<span class="sd">        small and the whole set can be computed::</span>

<span class="sd">            sage: C = AbelianStratum(6).even_component()</span>
<span class="sd">            sage: len(C.standard_permutations())  # long time</span>
<span class="sd">            44</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            44</span>

<span class="sd">            sage: C = AbelianStratum(4,2).even_component()</span>
<span class="sd">            sage: len(C.standard_permutations())   # long time</span>
<span class="sd">            136</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            136</span>

<span class="sd">            sage: C = AbelianStratum(2,2,2).even_component()</span>
<span class="sd">            sage: len(C.standard_permutations())   # long time</span>
<span class="sd">            92</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            92</span>

<span class="sd">        For higher genera, this number can be very big::</span>

<span class="sd">            sage: C = AbelianStratum(20).even_component()</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            109398514483439999</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">surface_dynamics.interval_exchanges.rauzy_class_cardinality</span> <span class="k">as</span> <span class="nn">rdc</span>

        <span class="n">profile</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">gamma_std</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span> <span class="o">-</span> <span class="n">rdc</span><span class="o">.</span><span class="n">delta_std</span><span class="p">(</span><span class="n">profile</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">number_of_components</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">hyperelliptic_component</span><span class="p">()</span><span class="o">.</span><span class="n">spin</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">N</span></div>

    <span class="k">def</span> <span class="nf">_cylinder_diagram_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over cylinder diagram.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cc = AbelianStratum(4,2).even_component()</span>
<span class="sd">            sage: it = cc.cylinder_diagram_iterator(4)</span>
<span class="sd">            sage: next(it).stratum_component()</span>
<span class="sd">            H_4(4, 2)^even</span>

<span class="sd">            sage: it = cc.cylinder_diagram_iterator(3, force_computation=True)</span>
<span class="sd">            sage: next(it).stratum_component()</span>
<span class="sd">            H_4(4, 2)^even</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">has_hyperelliptic_component</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_hyperelliptic</span><span class="p">()</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">spin_parity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">spin_parity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">))</span>

<div class="viewcode-block" id="EvenAbelianStratumComponent.single_cylinder_representative"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.EvenAbelianStratumComponent.single_cylinder_representative">[docs]</a>    <span class="k">def</span> <span class="nf">single_cylinder_representative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a single cylinder permutation representative.</span>

<span class="sd">        Returns a permutation representative of a square-tiled surface in this</span>
<span class="sd">        component having a single vertical cylinder and a single horizontal cylinder.</span>

<span class="sd">        Such representatives were constructed for every stratum of Abelian</span>
<span class="sd">        differentials by Jeffreys [Jef19]_.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``alphabet`` -- an optional alphabet for the permutation representative</span>

<span class="sd">        - ``reduced`` (boolean, default ``True``) -- whether to return a reduced</span>
<span class="sd">          permutation (ie without labels)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cc = AbelianStratum(6).even_component()</span>
<span class="sd">            sage: p = cc.single_cylinder_representative(alphabet=Alphabet(name=&#39;lower&#39;))</span>
<span class="sd">            sage: p</span>
<span class="sd">            a b c d e f g h</span>
<span class="sd">            c h g f d b e a</span>
<span class="sd">            sage: p.stratum_component() == cc</span>
<span class="sd">            True</span>

<span class="sd">            sage: cc = AbelianStratum(4,4).even_component()</span>
<span class="sd">            sage: p = cc.single_cylinder_representative()</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10</span>
<span class="sd">            2 10 7 5 8 1 9 6 4 3 0</span>
<span class="sd">            sage: p.stratum_component() == cc</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.single_cylinder</span> <span class="kn">import</span> <span class="n">cylinder_concatenation</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.single_cylinder</span> <span class="kn">import</span> <span class="p">(</span><span class="n">no_two_even</span><span class="p">,</span>
                <span class="n">one_two_even</span><span class="p">,</span> <span class="n">two_twos_even</span><span class="p">,</span> <span class="n">even_twos_even</span><span class="p">,</span> <span class="n">odd_twos_even</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.constructors</span> <span class="kn">import</span> <span class="n">GeneralizedPermutation</span>

        <span class="n">zeros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
        <span class="n">real_zeros</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zeros</span> <span class="k">if</span> <span class="n">z</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">fk_zeros_perm</span> <span class="o">=</span> <span class="n">GeneralizedPermutation</span><span class="p">([</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mk_pt_perm</span> <span class="o">=</span> <span class="n">GeneralizedPermutation</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()):</span>
            <span class="n">fk_zeros_perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">mk_pt_perm</span><span class="p">)</span>

        <span class="n">two_count</span> <span class="o">=</span> <span class="n">real_zeros</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">two_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">no_two_even</span><span class="p">(</span><span class="n">real_zeros</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">two_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">one_two_even</span><span class="p">(</span><span class="n">real_zeros</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">two_count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">two_twos_even</span><span class="p">(</span><span class="n">real_zeros</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">two_count</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">two_count</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">even_twos_even</span><span class="p">(</span><span class="n">real_zeros</span><span class="p">,</span><span class="n">two_count</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">odd_twos_even</span><span class="p">(</span><span class="n">real_zeros</span><span class="p">,</span><span class="n">two_count</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">perm</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">perm</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span> <span class="k">if</span> <span class="n">reduced</span> <span class="k">else</span> <span class="n">perm</span></div></div>

<span class="n">EvenASC</span> <span class="o">=</span> <span class="n">EvenAbelianStratumComponent</span>


<div class="viewcode-block" id="OddAbelianStratumComponent"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.OddAbelianStratumComponent">[docs]</a><span class="k">class</span> <span class="nc">OddAbelianStratumComponent</span><span class="p">(</span><span class="n">ASC</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connected component of an Abelian stratum with odd spin parity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;odd&#39;</span>

<div class="viewcode-block" id="OddAbelianStratumComponent.spin"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.OddAbelianStratumComponent.spin">[docs]</a>    <span class="k">def</span> <span class="nf">spin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns 1 which is, by definition, the spin parity of this stratum component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: c = AbelianStratum(4).odd_component(); c</span>
<span class="sd">            H_3(4)^odd</span>
<span class="sd">            sage: c.spin()</span>
<span class="sd">            1</span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="OddAbelianStratumComponent.permutation_representative"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.OddAbelianStratumComponent.permutation_representative">[docs]</a>    <span class="k">def</span> <span class="nf">permutation_representative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Zorich representative of this connected component.</span>

<span class="sd">        A. Zorich constructs explicitly interval exchange</span>
<span class="sd">        transformations for each stratum in [Zor08]_.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStratum(6).odd_component()</span>
<span class="sd">            sage: p = a.permutation_representative()</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1 2 3 4 5 6 7</span>
<span class="sd">            3 2 5 4 7 6 1 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(6)^odd</span>

<span class="sd">        ::</span>

<span class="sd">            sage: a = AbelianStratum(4,4).odd_component()</span>
<span class="sd">            sage: p = a.permutation_representative()</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10</span>
<span class="sd">            3 2 5 4 6 8 7 10 9 1 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_5(4^2)^odd</span>

<span class="sd">        Different markings lead to different Rauzy diagrams::</span>

<span class="sd">            sage: c = AbelianStratum(4,2,0).odd_component()</span>
<span class="sd">            sage: p = c.permutation_representative(left_degree=4); p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9</span>
<span class="sd">            4 3 6 5 7 9 8 2 0 1</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(4, 2, 0)^odd</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            5</span>
<span class="sd">            sage: p.rauzy_diagram()   # not tested</span>
<span class="sd">            Rauzy diagram with 147090 permutations</span>

<span class="sd">            sage: p = c.permutation_representative(left_degree=2); p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9</span>
<span class="sd">            4 3 5 7 6 9 8 2 0 1</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(4, 2, 0)^odd</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            3</span>
<span class="sd">            sage: p.rauzy_diagram()   # long time</span>
<span class="sd">            Rauzy diagram with 87970 permutations</span>

<span class="sd">            sage: p = c.permutation_representative(left_degree=0); p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9</span>
<span class="sd">            4 2 6 5 7 9 8 1 3 0</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            H_4(4, 2, 0)^odd</span>
<span class="sd">            sage: p.marking().left()</span>
<span class="sd">            1</span>
<span class="sd">            sage: p.rauzy_diagram()   # long time</span>
<span class="sd">            Rauzy diagram with 27754 permutations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fake_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stratum</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stratum</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left_degree (=</span><span class="si">%d</span><span class="s2">) should be one of the degree&quot;</span> <span class="o">%</span> <span class="n">left_degree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">left_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left_degree (=</span><span class="si">%d</span><span class="s2">) should be one of the degree&quot;</span> <span class="o">%</span> <span class="n">left_degree</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">left_degree</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zeros</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left_degree (=</span><span class="si">%d</span><span class="s2">) should be one of the degree&quot;</span> <span class="o">%</span> <span class="n">left_degree</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zeros</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">left_degree</span><span class="p">)</span>
                <span class="n">zeros</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">left_degree</span><span class="p">)</span>

        <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">//</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">zeros</span><span class="p">]</span>

        <span class="n">l0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">l1</span> <span class="o">+=</span> <span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">l1</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">k</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">z</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">l0</span><span class="p">[</span><span class="n">l0</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                <span class="k">del</span> <span class="n">l1</span><span class="p">[</span><span class="n">l1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">3</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">3</span>

        <span class="c1"># marked points</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">g</span><span class="o">-</span><span class="mi">2</span><span class="o">+</span><span class="n">n</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">left_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">l0</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">l0</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                <span class="n">l1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l0</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                <span class="n">l1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.reduced</span> <span class="kn">import</span> <span class="n">ReducedPermutationIET</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">ReducedPermutationIET</span><span class="p">([</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.labelled</span> <span class="kn">import</span> <span class="n">LabelledPermutationIET</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">LabelledPermutationIET</span><span class="p">([</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">relabel</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="OddAbelianStratumComponent.rauzy_class_cardinality"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.OddAbelianStratumComponent.rauzy_class_cardinality">[docs]</a>    <span class="k">def</span> <span class="nf">rauzy_class_cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cardinality of rauzy diagram for odd component</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``left_degree`` - integer (optional)</span>

<span class="sd">        - ``reduced`` - boolean (default: True)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        The genus must be at least 3 to have an odd component::</span>

<span class="sd">            sage: c = AbelianStratum(4).odd_component()</span>
<span class="sd">            sage: c.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 134 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            134</span>
<span class="sd">            sage: c = AbelianStratum(4,0).odd_component()</span>
<span class="sd">            sage: c.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 1114 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            1114</span>

<span class="sd">            sage: c = AbelianStratum(2,2).odd_component()</span>
<span class="sd">            sage: c.rauzy_diagram()</span>
<span class="sd">            Rauzy diagram with 294 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            294</span>

<span class="sd">            sage: c = AbelianStratum(2,2,0).odd_component()</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            2723</span>

<span class="sd">            sage: c.rauzy_diagram(left_degree=2)</span>
<span class="sd">            Rauzy diagram with 2352 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=2)</span>
<span class="sd">            2352</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=2, reduced=False)</span>
<span class="sd">            Rauzy diagram with 7056 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=2, reduced=False)</span>
<span class="sd">            7056</span>

<span class="sd">            sage: c.rauzy_diagram(left_degree=0)</span>
<span class="sd">            Rauzy diagram with 371 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=0)</span>
<span class="sd">            371</span>
<span class="sd">            sage: c.rauzy_diagram(left_degree=0, reduced=False)</span>
<span class="sd">            Rauzy diagram with 6678 permutations</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=0, reduced=False)</span>
<span class="sd">            6678</span>


<span class="sd">        Example in higher genus for which an explicit computation of the Rauzy</span>
<span class="sd">        diagram would be very long::</span>

<span class="sd">            sage: c = AbelianStratum(4,2,0).odd_component()</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            262814</span>
<span class="sd">            sage: c = AbelianStratum(4,4,4).odd_component()</span>
<span class="sd">            sage: c.rauzy_class_cardinality()</span>
<span class="sd">            24691288838</span>
<span class="sd">            sage: c.rauzy_class_cardinality(left_degree=4, reduced=False)</span>
<span class="sd">            1234564441900</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">surface_dynamics.interval_exchanges.rauzy_class_cardinality</span> <span class="k">as</span> <span class="nn">rdc</span>

        <span class="n">profile</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">left_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)),</span> <span class="s2">&quot;if not None, left_degree should be an integer&quot;</span>
            <span class="n">left_degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">left_degree</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">left_degree</span> <span class="ow">in</span> <span class="n">profile</span><span class="p">,</span> <span class="s2">&quot;if not None, the degree should be one of the degree of the stratum&quot;</span>

            <span class="k">if</span> <span class="n">reduced</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">Partition</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span><span class="o">.</span><span class="n">centralizer_size</span><span class="p">()</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">left_degree</span> <span class="o">*</span> <span class="n">profile</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">left_degree</span><span class="p">))</span> <span class="o">*</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rauzy_class_cardinality</span><span class="p">(</span><span class="n">left_degree</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">reduced</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;no formula known for labeled extended Rauzy classes&quot;</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">gamma_irr</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span><span class="n">left_degree</span><span class="p">)</span> <span class="o">+</span> <span class="n">rdc</span><span class="o">.</span><span class="n">delta_irr</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span><span class="n">left_degree</span><span class="p">))</span><span class="o">//</span><span class="mi">2</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">number_of_components</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">hyperelliptic_component</span><span class="p">()</span><span class="o">.</span><span class="n">spin</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">N</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">hyperelliptic_component</span><span class="p">()</span><span class="o">.</span><span class="n">rauzy_class_cardinality</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">N</span></div>

<div class="viewcode-block" id="OddAbelianStratumComponent.standard_permutations_number"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.OddAbelianStratumComponent.standard_permutations_number">[docs]</a>    <span class="k">def</span> <span class="nf">standard_permutations_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of standard permutation of this even component.</span>


<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        In genus 2, there are two strata which contains an odd component::</span>

<span class="sd">            sage: C = AbelianStratum(4).odd_component()</span>
<span class="sd">            sage: len(C.standard_permutations())</span>
<span class="sd">            7</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            7</span>

<span class="sd">            sage: C = AbelianStratum(2,2).odd_component()</span>
<span class="sd">            sage: len(C.standard_permutations())</span>
<span class="sd">            11</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            11</span>

<span class="sd">        In genus 3, the number of standard permutations is reasonably small and</span>
<span class="sd">        the whole set can be computed::</span>

<span class="sd">            sage: C = AbelianStratum(6).odd_component()</span>
<span class="sd">            sage: len(C.standard_permutations())   # long time</span>
<span class="sd">            135</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            135</span>

<span class="sd">            sage: C = AbelianStratum(4,2).odd_component()</span>
<span class="sd">            sage: len(C.standard_permutations())   # long time</span>
<span class="sd">            472</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            472</span>

<span class="sd">            sage: C = AbelianStratum(2,2,2).odd_component()</span>
<span class="sd">            sage: len(C.standard_permutations())   # long time</span>
<span class="sd">            372</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            372</span>

<span class="sd">        For higher genera, this number can be very big::</span>

<span class="sd">            sage: C = AbelianStratum(8,6,4,2).odd_component()</span>
<span class="sd">            sage: C.standard_permutations_number()</span>
<span class="sd">            26596699869748377600</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">surface_dynamics.interval_exchanges.rauzy_class_cardinality</span> <span class="k">as</span> <span class="nn">rdc</span>

        <span class="n">profile</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">rdc</span><span class="o">.</span><span class="n">gamma_std</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span> <span class="o">+</span> <span class="n">rdc</span><span class="o">.</span><span class="n">delta_std</span><span class="p">(</span><span class="n">profile</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">number_of_components</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">hyperelliptic_component</span><span class="p">()</span><span class="o">.</span><span class="n">spin</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">N</span></div>

    <span class="k">def</span> <span class="nf">_cylinder_diagram_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncyls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of cylinder diagrams associated to this odd connected</span>
<span class="sd">        component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: C = AbelianStratum(4).odd_component()</span>
<span class="sd">            sage: for c in C.cylinder_diagrams(1): print(c)</span>
<span class="sd">            (0,2,1,4,3)-(0,4,2,1,3)</span>
<span class="sd">            (0,4,1,2,3)-(0,1,3,4,2)</span>
<span class="sd">            sage: for c in C.cylinder_diagrams(2): print(c)</span>
<span class="sd">            (0,1,2)-(0,3,1,4) (3,4)-(2)</span>
<span class="sd">            (0,1,3)-(4) (2,4)-(0,1,2,3)</span>
<span class="sd">            (0,2,3)-(2,4) (1,4)-(0,1,3)</span>
<span class="sd">            (0,2,3,1)-(0,2,1,4) (4)-(3)</span>
<span class="sd">            sage: for c in C.cylinder_diagrams(3): print(c)</span>
<span class="sd">            (0,1)-(0,3,4) (2,3)-(1) (4)-(2)</span>
<span class="sd">            (0,2)-(0,3) (1,3)-(1,4) (4)-(2)</span>
<span class="sd">            (0,2)-(4) (1,4)-(2,3) (3)-(0,1)</span>
<span class="sd">            (0,2,1)-(0,3,4) (3)-(1) (4)-(2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">has_hyperelliptic_component</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_hyperelliptic</span><span class="p">()</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">spin_parity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">spin_parity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">cylinder_diagram_iterator</span><span class="p">(</span><span class="n">ncyls</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">))</span>

<div class="viewcode-block" id="OddAbelianStratumComponent.single_cylinder_representative"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.OddAbelianStratumComponent.single_cylinder_representative">[docs]</a>    <span class="k">def</span> <span class="nf">single_cylinder_representative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a single cylinder permutation representative.</span>

<span class="sd">        Returns a permutation representative of a square-tiled surface in this</span>
<span class="sd">        component having a single vertical cylinder and a single horizontal cylinder.</span>

<span class="sd">        Such representatives were constructed for every stratum of Abelian</span>
<span class="sd">        differentials by Jeffreys [Jef19]_.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``alphabet`` -- an optional alphabet for the permutation representative</span>

<span class="sd">        - ``reduced`` (boolean, default ``True``) -- whether to return a reduced</span>
<span class="sd">          permutation (ie without labels)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: cc = AbelianStratum(4).odd_component()</span>
<span class="sd">            sage: p = cc.single_cylinder_representative(alphabet=Alphabet(name=&#39;upper&#39;))</span>
<span class="sd">            sage: p</span>
<span class="sd">            A B C D E F</span>
<span class="sd">            C F E B D A</span>
<span class="sd">            sage: p.stratum_component() == cc</span>
<span class="sd">            True</span>

<span class="sd">            sage: cc = AbelianStratum(6,2).odd_component()</span>
<span class="sd">            sage: p = cc.single_cylinder_representative()</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1 2 3 4 5 6 7 8 9 10</span>
<span class="sd">            2 5 4 6 3 8 10 7 1 9 0</span>
<span class="sd">            sage: p.stratum_component() == cc</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.single_cylinder</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cylinder_concatenation</span><span class="p">,</span>
                <span class="n">no_two_odd</span><span class="p">,</span> <span class="n">one_two_odd</span><span class="p">,</span> <span class="n">even_twos_odd</span><span class="p">,</span> <span class="n">odd_twos_odd</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.interval_exchanges.constructors</span> <span class="kn">import</span> <span class="n">GeneralizedPermutation</span>

        <span class="n">zeros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>
        <span class="n">real_zeros</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zeros</span> <span class="k">if</span> <span class="n">z</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">fk_zeros_perm</span> <span class="o">=</span> <span class="n">GeneralizedPermutation</span><span class="p">([</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mk_pt_perm</span> <span class="o">=</span> <span class="n">GeneralizedPermutation</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()):</span>
            <span class="n">fk_zeros_perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">mk_pt_perm</span><span class="p">)</span>

        <span class="n">two_count</span> <span class="o">=</span> <span class="n">real_zeros</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">two_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">no_two_odd</span><span class="p">(</span><span class="n">real_zeros</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">two_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">one_two_odd</span><span class="p">(</span><span class="n">real_zeros</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">two_count</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">two_count</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">even_twos_odd</span><span class="p">(</span><span class="n">real_zeros</span><span class="p">,</span><span class="n">two_count</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">cylinder_concatenation</span><span class="p">(</span><span class="n">fk_zeros_perm</span><span class="p">,</span><span class="n">odd_twos_odd</span><span class="p">(</span><span class="n">real_zeros</span><span class="p">,</span><span class="n">two_count</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">perm</span><span class="o">.</span><span class="n">alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">perm</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span> <span class="k">if</span> <span class="n">reduced</span> <span class="k">else</span> <span class="n">perm</span></div></div>

<span class="n">OddASC</span> <span class="o">=</span> <span class="n">OddAbelianStratumComponent</span>


<span class="c1">#</span>
<span class="c1"># iterators for Abelian strata with constraints on genus and dimension</span>
<span class="c1">#</span>

<div class="viewcode-block" id="AbelianStrata"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata">[docs]</a><span class="k">class</span> <span class="nc">AbelianStrata</span><span class="p">(</span><span class="n">Strata</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abelian strata.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``genus`` - a non negative integer or None</span>

<span class="sd">    - ``dimension`` - a non negative integer or None</span>

<span class="sd">    - ``fake_zeros`` - boolean</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">    Abelian strata with a given genus::</span>

<span class="sd">        sage: for s in AbelianStrata(genus=1): print(s)</span>
<span class="sd">        H_1(0)</span>

<span class="sd">    ::</span>

<span class="sd">        sage: for s in AbelianStrata(genus=2): print(s)</span>
<span class="sd">        H_2(2)</span>
<span class="sd">        H_2(1^2)</span>

<span class="sd">    ::</span>

<span class="sd">        sage: for s in AbelianStrata(genus=3): print(s)</span>
<span class="sd">        H_3(4)</span>
<span class="sd">        H_3(3, 1)</span>
<span class="sd">        H_3(2^2)</span>
<span class="sd">        H_3(2, 1^2)</span>
<span class="sd">        H_3(1^4)</span>

<span class="sd">    ::</span>

<span class="sd">        sage: for s in AbelianStrata(genus=4): print(s)</span>
<span class="sd">        H_4(6)</span>
<span class="sd">        H_4(5, 1)</span>
<span class="sd">        H_4(4, 2)</span>
<span class="sd">        H_4(4, 1^2)</span>
<span class="sd">        H_4(3^2)</span>
<span class="sd">        H_4(3, 2, 1)</span>
<span class="sd">        H_4(3, 1^3)</span>
<span class="sd">        H_4(2^3)</span>
<span class="sd">        H_4(2^2, 1^2)</span>
<span class="sd">        H_4(2, 1^4)</span>
<span class="sd">        H_4(1^6)</span>

<span class="sd">    Get outside of the tests.</span>
<span class="sd">    Abelian strata with a given number of intervals</span>

<span class="sd">    sage for s in AbelianStrata(dimension=2): print(s)</span>
<span class="sd">    H^out([0])</span>

<span class="sd">    sage for s in AbelianStrata(dimension=3): print(s)</span>
<span class="sd">    H^out([0], 0)</span>

<span class="sd">    sage for s in AbelianStrata(dimension=4): print(s)</span>
<span class="sd">    H^out([2])</span>
<span class="sd">    H^out([0], 0, 0)</span>

<span class="sd">    Get outside of tests</span>
<span class="sd">    sage  for s in AbelianStrata(dimension=5): print(s)</span>
<span class="sd">    H^out(2, [0])</span>
<span class="sd">    H^out([2], 0)</span>
<span class="sd">    H^out([1], 1)</span>
<span class="sd">    H^out([0], 0, 0, 0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">genus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fake_zeros</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fake_zeros</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">fake_zeros</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimension</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dimension</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimension must be a non-negative integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">genus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">genus</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">genus</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">genus</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;genus must be a non-negative integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">genus</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">AbelianStrata_all</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">AbelianStrata_d</span>
        <span class="k">elif</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">AbelianStrata_g</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">AbelianStrata_gd</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">Strata</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">genus</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">fake_zeros</span><span class="p">)</span>
        <span class="n">AbelianStrata</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">genus</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">fake_zeros</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">genus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fake_zeros</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: s = AbelianStrata(genus=3)</span>
<span class="sd">            sage: loads(dumps(s)) == s</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fake_zeros</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">genus</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">InfiniteEnumeratedSets</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">FiniteEnumeratedSets</span><span class="p">()</span>
        <span class="n">Parent</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">,</span> <span class="n">facade</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">=</span> <span class="n">genus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span> <span class="o">=</span> <span class="n">fake_zeros</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equality test.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbelianStrata</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_dimension</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_genus</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_fake_zeros</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Difference test.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStrata()                        # indirect doctest</span>
<span class="sd">            Abelian strata</span>

<span class="sd">            sage: AbelianStrata(dimension=2)             # indirect doctest</span>
<span class="sd">            Abelian strata of dimension 2</span>

<span class="sd">            sage: AbelianStrata(genus=3)                 # indirect doctest</span>
<span class="sd">            Abelian strata of genus 3 surfaces</span>

<span class="sd">            sage: AbelianStrata(genus=2, dimension=4)    # indirect doctest</span>
<span class="sd">            Abelian strata of genus 2 surfaces and dimension 4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Abelian strata&quot;</span>

        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;genus </span><span class="si">{}</span><span class="s2"> surfaces&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dimension </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Abelian strata of &quot;</span> <span class="o">+</span> <span class="s2">&quot; and &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Abelian strata&quot;</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pickling support.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AbelianStrata</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Containance test</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: a = AbelianStrata(genus=3)</span>
<span class="sd">            sage: all(s in a for s in a)</span>
<span class="sd">            True</span>

<span class="sd">            sage: a = AbelianStrata(genus=3,fake_zeros=False)</span>
<span class="sd">            sage: all(s in a for s in a)</span>
<span class="sd">            True</span>

<span class="sd">            sage: a = AbelianStrata(dimension=7,fake_zeros=True)</span>
<span class="sd">            sage: all(s in a for s in a)</span>
<span class="sd">            True</span>
<span class="sd">            sage: AbelianStratum(2,0,0) in a</span>
<span class="sd">            False</span>

<span class="sd">            sage: a = AbelianStrata(dimension=7,fake_zeros=False)</span>
<span class="sd">            sage: all(s in a for s in a)</span>
<span class="sd">            True</span>
<span class="sd">            sage: AbelianStratum(4,0) in a</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">AbelianStratum</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">genus</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">()))</span></div>


<div class="viewcode-block" id="AbelianStrata_g"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_g">[docs]</a><span class="k">class</span> <span class="nc">AbelianStrata_g</span><span class="p">(</span><span class="n">AbelianStrata</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stratas of genus g surfaces without fake zeros.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``genus`` - a non negative integer</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">        sage: AbelianStrata(genus=2).list()</span>
<span class="sd">        [H_2(2), H_2(1^2)]</span>
<span class="sd">        sage: AbelianStrata(genus=3).list()</span>
<span class="sd">        [H_3(4), H_3(3, 1), H_3(2^2), H_3(2, 1^2), H_3(1^4)]</span>
<span class="sd">        sage: AbelianStrata(genus=4).random_element() #random</span>
<span class="sd">        H_4(4, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="AbelianStrata_g.cardinality"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_g.cardinality">[docs]</a>    <span class="k">def</span> <span class="nf">cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of abelian strata with a given genus.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStrata(genus=1).cardinality()</span>
<span class="sd">            1</span>
<span class="sd">            sage: AbelianStrata(genus=2).cardinality()</span>
<span class="sd">            2</span>
<span class="sd">            sage: AbelianStrata(genus=3).cardinality()</span>
<span class="sd">            5</span>
<span class="sd">            sage: AbelianStrata(genus=4).cardinality()</span>
<span class="sd">            11</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: list(AbelianStrata(genus=1))</span>
<span class="sd">            [H_1(0)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">AbelianStratum</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">_list</span><span class="p">)</span>

<div class="viewcode-block" id="AbelianStrata_g.random_element"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_g.random_element">[docs]</a>    <span class="k">def</span> <span class="nf">random_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random stratum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No stratum with that genus&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">(</span><span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">())</span></div>

<div class="viewcode-block" id="AbelianStrata_g.first"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_g.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first element of this list of strata.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStrata(genus=3).first()</span>
<span class="sd">            H_3(4)</span>
<span class="sd">            sage: AbelianStrata(genus=4).first()</span>
<span class="sd">            H_4(6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span></div>

    <span class="n">an_element_</span> <span class="o">=</span> <span class="n">first</span>

<div class="viewcode-block" id="AbelianStrata_g.last"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_g.last">[docs]</a>    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last element of this list of strata.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStrata(genus=4).last()</span>
<span class="sd">            H_4(1^6)</span>
<span class="sd">            sage: AbelianStrata(genus=5).last()</span>
<span class="sd">            H_5(1^8)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span><span class="o">-</span><span class="mi">2</span><span class="p">})</span></div></div>


<div class="viewcode-block" id="AbelianStrata_d"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_d">[docs]</a><span class="k">class</span> <span class="nc">AbelianStrata_d</span><span class="p">(</span><span class="n">AbelianStrata</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Strata with prescribed dimension.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``dimension`` - an integer greater than 1</span>

<span class="sd">    - ``fake_zeros`` - boolean (default: False) - allows or not fake zeros</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">        sage: for a in AbelianStrata(dimension=5,fake_zeros=True):</span>
<span class="sd">        ....:     print(a)</span>
<span class="sd">        ....:     print(a.permutation_representative())</span>
<span class="sd">        H_2(2, 0)</span>
<span class="sd">        0 1 2 3 4</span>
<span class="sd">        4 1 3 2 0</span>
<span class="sd">        H_2(1^2)</span>
<span class="sd">        0 1 2 3 4</span>
<span class="sd">        4 3 2 1 0</span>
<span class="sd">        H_1(0^4)</span>
<span class="sd">        0 1 2 3 4</span>
<span class="sd">        4 0 1 2 3</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="AbelianStrata_d.first"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_d.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first stratum.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStrata(dimension=2).first()</span>
<span class="sd">            H_1(0)</span>
<span class="sd">            sage: AbelianStrata(dimension=3).first()</span>
<span class="sd">            H_1(0^2)</span>
<span class="sd">            sage: AbelianStrata(dimension=4).first()</span>
<span class="sd">            H_2(2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">([(</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,(</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span></div>

    <span class="n">an_element</span> <span class="o">=</span> <span class="n">first</span>

<div class="viewcode-block" id="AbelianStrata_d.last"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_d.last">[docs]</a>    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last stratum.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStrata(dimension=9,fake_zeros=True).last()</span>
<span class="sd">            H_1(0^8)</span>
<span class="sd">            sage: AbelianStrata(dimension=9,fake_zeros=False).last()</span>
<span class="sd">            H_3(1^4)</span>

<span class="sd">            sage: AbelianStrata(dimension=10,fake_zeros=True).last()</span>
<span class="sd">            H_1(0^9)</span>
<span class="sd">            sage: AbelianStrata(dimension=10,fake_zeros=False).last()</span>
<span class="sd">            H_4(2^3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nn</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span>
                <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="o">-</span><span class="n">nn</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span><span class="o">//</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">nn</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: for a in AbelianStrata(dimension=4,fake_zeros=True): print(a)</span>
<span class="sd">            H_2(2)</span>
<span class="sd">            H_1(0^3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">p</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">min_part</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">p</span><span class="p">])</span>

<div class="viewcode-block" id="AbelianStrata_d.cardinality"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_d.cardinality">[docs]</a>    <span class="k">def</span> <span class="nf">cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of Abelian strata with given dimension.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStrata(dimension=5,fake_zeros=True).cardinality()</span>
<span class="sd">            3</span>
<span class="sd">            sage: AbelianStrata(dimension=5,fake_zeros=False).cardinality()</span>
<span class="sd">            1</span>

<span class="sd">            sage: AbelianStrata(dimension=6,fake_zeros=True).cardinality()</span>
<span class="sd">            4</span>
<span class="sd">            sage: AbelianStrata(dimension=6,fake_zeros=False).cardinality()</span>
<span class="sd">            1</span>

<span class="sd">            sage: AbelianStrata(dimension=7,fake_zeros=True).cardinality()</span>
<span class="sd">            6</span>
<span class="sd">            sage: AbelianStrata(dimension=7,fake_zeros=False).cardinality()</span>
<span class="sd">            2</span>

<span class="sd">            sage: AbelianStrata(dimension=12,fake_zeros=True).cardinality()</span>
<span class="sd">            29</span>
<span class="sd">            sage: AbelianStrata(dimension=12,fake_zeros=False).cardinality()</span>
<span class="sd">            7</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: for d in range(1,15):</span>
<span class="sd">            ....:   A = AbelianStrata(dimension=d,fake_zeros=True)</span>
<span class="sd">            ....:   assert len(A.list()) == A.cardinality()</span>
<span class="sd">            ....:   A = AbelianStrata(dimension=d,fake_zeros=False)</span>
<span class="sd">            ....:   assert len(A.list()) == A.cardinality()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">min_part</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span></div></div>

<div class="viewcode-block" id="AbelianStrata_gd"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_gd">[docs]</a><span class="k">class</span> <span class="nc">AbelianStrata_gd</span><span class="p">(</span><span class="n">AbelianStrata</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abelian strata of prescribed genus and number of intervals.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``genus`` - integer: the genus of the surfaces</span>

<span class="sd">    - ``dimension`` - integer: the number of intervals</span>

<span class="sd">    - ``fake_zeros`` - boolean: whether or not consider fake zeros</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: AbelianStrata(genus=2, dimension=4).list()</span>
<span class="sd">            [H_2(2)]</span>

<span class="sd">            sage: AbelianStrata(genus=4, dimension=10, fake_zeros=True).list()</span>
<span class="sd">            [H_4(6, 0^2), H_4(5, 1, 0), H_4(4, 2, 0), H_4(4, 1^2), H_4(3^2, 0), H_4(3, 2, 1), H_4(2^3)]</span>
<span class="sd">            sage: AbelianStrata(genus=4, dimension=10, fake_zeros=False).list()</span>
<span class="sd">            [H_4(4, 1^2), H_4(3, 2, 1), H_4(2^3)]</span>

<span class="sd">            sage: AbelianStrata(genus=3, dimension=10, fake_zeros=True).list()</span>
<span class="sd">            [H_3(4, 0^4), H_3(3, 1, 0^3), H_3(2^2, 0^3), H_3(2, 1^2, 0^2), H_3(1^4, 0)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">s</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">AbelianStratum</span><span class="p">([</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">p</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_genus</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">AbelianStratum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbelianStrata_all"><a class="viewcode-back" href="../../../strata.html#surface_dynamics.flat_surfaces.abelian_strata.AbelianStrata_all">[docs]</a><span class="k">class</span> <span class="nc">AbelianStrata_all</span><span class="p">(</span><span class="n">AbelianStrata</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abelian strata.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``fake_zeros`` - boolean (default: ``False``)</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">        sage: A = AbelianStrata()</span>
<span class="sd">        sage: it = iter(A)</span>
<span class="sd">        sage: for _ in range(10):</span>
<span class="sd">        ....:     print(next(it))</span>
<span class="sd">        H_1(0)</span>
<span class="sd">        H_2(2)</span>
<span class="sd">        H_2(1^2)</span>
<span class="sd">        H_3(4)</span>
<span class="sd">        H_3(3, 1)</span>
<span class="sd">        H_3(2^2)</span>
<span class="sd">        H_4(6)</span>
<span class="sd">        H_3(2, 1^2)</span>
<span class="sd">        H_4(5, 1)</span>
<span class="sd">        H_4(4, 2)</span>

<span class="sd">        sage: A = AbelianStrata(fake_zeros=True)</span>
<span class="sd">        sage: it = iter(A)</span>
<span class="sd">        sage: for _ in range(10):</span>
<span class="sd">        ....:     print(next(it))</span>
<span class="sd">        H_1(0)</span>
<span class="sd">        H_1(0^2)</span>
<span class="sd">        H_2(2)</span>
<span class="sd">        H_1(0^3)</span>
<span class="sd">        H_2(2, 0)</span>
<span class="sd">        H_2(1^2)</span>
<span class="sd">        H_1(0^4)</span>
<span class="sd">        H_3(4)</span>
<span class="sd">        H_2(2, 0^2)</span>
<span class="sd">        H_2(1^2, 0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: next(iter(AbelianStrata()))  # indirect doctest</span>
<span class="sd">            H_1(0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">count</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="n">AbelianStrata</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">fake_zeros</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fake_zeros</span><span class="p">)</span></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2021-2023, the surface-dynamics authors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    </body>
</html>