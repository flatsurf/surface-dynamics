<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 7.3.7 and Furo 2024.05.06 -->
        <title>surface_dynamics.interval_exchanges.template - surface-dynamics 0.5.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=387cc868" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="https://doc.sagemath.org/html/en/reference/_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" /
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">surface-dynamics 0.5.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">surface-dynamics 0.5.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/interval_exchanges.html">Interval exchange transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/square_tiled_surfaces.html">Square-tiled surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/rank2_genus3_classification.html">Filtering Possible <span class="math notranslate nohighlight">\(\mathcal M\)</span>-Parallel Classes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../strata.html">Strata of Abelian and quadratic differentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../surface_topology.html">Surface topology and geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../origamis.html">Origamis</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../interval_exchanges/index.html">Interval exchange transformations</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Interval exchange transformations</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/constructors.html">Interval exchange constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/template.html">Permutation template</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/labelled.html">Labelled permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/reduced.html">Reduced permutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/rauzy_class_cardinality.html">Rauzy class cardinality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/cover.html">Covering construction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/iet.html">Interval exchange transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/integer_iet.html">Integral interval exchanges</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/iet_family.html">Interval exchange families</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../interval_exchanges/flip_sequence.html">Flip sequences</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../database.html">Database of cylinder diagrams and quadratic permutations</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../topological_recursion/index.html">Topological recursion</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Topological recursion</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../topological_recursion/topological_recursion.html">Generic topological recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../topological_recursion/kontsevich.html">Kontsevich topological recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../topological_recursion/masur_veech.html">Masur-Veech topological recursion</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../misc/index.html">Miscellaneous</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Miscellaneous</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/constellation.html">Constellations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/group_representation.html">Finite group representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../misc/plane_tree.html">Plane trees</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for surface_dynamics.interval_exchanges.template</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Template for permutations of interval exchange transformations</span>

<span class="sd">This file define high level operations on permutations (alphabet,</span>
<span class="sd">the different rauzy moves, ...) shared by reduced and labeled</span>
<span class="sd">permutations.</span>

<span class="sd">AUTHORS:</span>

<span class="sd">- Vincent Delecroix (2008-12-20): initial version</span>

<span class="sd">- Vincent Delecroix (2010-02-11): datatype simplification</span>

<span class="sd">TODO:</span>

<span class="sd">- disallow access to stratum, stratum component for permutations with flip</span>

<span class="sd">- construct dynamic Rauzy graphs and paths</span>

<span class="sd">- construct coherent _repr_</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#*****************************************************************************</span>
<span class="c1">#       Copyright (C) 2008 Vincent Delecroix &lt;20100.delecroix@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1">#  Distributed under the terms of the GNU General Public License (GPL)</span>
<span class="c1">#  as published by the Free Software Foundation; either version 2 of</span>
<span class="c1">#  the License, or (at your option) any later version.</span>
<span class="c1">#                  https://www.gnu.org/licenses/</span>
<span class="c1">#*****************************************************************************</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">iterkeys</span><span class="p">,</span> <span class="n">iteritems</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">total_ordering</span>

<span class="kn">from</span> <span class="nn">sage.structure.sage_object</span> <span class="kn">import</span> <span class="n">SageObject</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>

<span class="kn">from</span> <span class="nn">sage.rings.integer</span> <span class="kn">import</span> <span class="n">Integer</span>
<span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>
<span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">identity_matrix</span><span class="p">,</span> <span class="n">matrix</span>
<span class="kn">from</span> <span class="nn">sage.misc.nested_class</span> <span class="kn">import</span> <span class="n">NestedClassMetaclass</span>

<span class="kn">from</span> <span class="nn">surface_dynamics.misc.permutation</span> <span class="kn">import</span> <span class="n">perms_canonical_labels</span>

<div class="viewcode-block" id="to_fat_graphs">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.to_fat_graphs">[docs]</a>
<span class="k">def</span> <span class="nf">to_fat_graphs</span><span class="p">(</span><span class="n">twin</span><span class="p">):</span>
    <span class="n">lt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">twin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">lb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">twin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="c1"># non-separating</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">lt</span> <span class="o">+</span> <span class="n">lb</span> <span class="o">-</span> <span class="mi">2</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">lt</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">lb</span><span class="p">]</span>
        <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ep</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ii</span><span class="p">,</span><span class="n">jj</span> <span class="o">=</span> <span class="n">twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>
                    <span class="n">ep</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>
                    <span class="n">ep</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">k</span> <span class="o">==</span> <span class="n">n</span>
        <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lt</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">lt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">fp</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lb</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">lb</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">fp</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[(</span><span class="n">ep</span><span class="p">,</span> <span class="n">fp</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># separating</span>
        <span class="n">labelstop</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">lt</span>
        <span class="n">labelstop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">eptop</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labelstop</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">labelstop</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">jj</span> <span class="o">=</span> <span class="n">twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">labelstop</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">labelstop</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">eptop</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">eptop</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">labelstop</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">fptop</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lt</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">lt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">fptop</span><span class="p">[</span><span class="n">labelstop</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">labelstop</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="n">labelsbot</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">lb</span>
        <span class="n">labelsbot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">epbot</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lb</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labelsbot</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">labelsbot</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">jj</span> <span class="o">=</span> <span class="n">twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">labelsbot</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">labelsbot</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">epbot</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">epbot</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">labelsbot</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fpbot</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lb</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lb</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">lb</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">fpbot</span><span class="p">[</span><span class="n">labelsbot</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">labelsbot</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[(</span><span class="n">eptop</span><span class="p">,</span> <span class="n">fptop</span><span class="p">),</span> <span class="p">(</span><span class="n">epbot</span><span class="p">,</span> <span class="n">fpbot</span><span class="p">)]</span></div>


<div class="viewcode-block" id="cylindric_canonical">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.cylindric_canonical">[docs]</a>
<span class="k">def</span> <span class="nf">cylindric_canonical</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TESTS::</span>

<span class="sd">        sage: from surface_dynamics import QuadraticStratum</span>
<span class="sd">        sage: from surface_dynamics.interval_exchanges.template import cylindric_canonical</span>

<span class="sd">        sage: C = QuadraticStratum(1,genus=0).unique_component()</span>
<span class="sd">        sage: R = C.permutation_representative().rauzy_diagram()</span>
<span class="sd">        sage: K = [p for p in R if p.is_cylindric()]</span>
<span class="sd">        sage: Kcan = set(cylindric_canonical(p) for p in K)</span>
<span class="sd">        sage: Kcan</span>
<span class="sd">        {((1, 0), (1, 2, 3, 4, 5, 0))}</span>
<span class="sd">        sage: C = QuadraticStratum(1,1,genus=0).unique_component()</span>
<span class="sd">        sage: R = C.permutation_representative().rauzy_diagram()</span>
<span class="sd">        sage: K = [p for p in R if p.is_cylindric()]</span>
<span class="sd">        sage: Kcan = set(cylindric_canonical(p) for p in K)</span>
<span class="sd">        sage: Kcan</span>
<span class="sd">        {((1, 0), (1, 2, 3, 4, 6, 0, 7, 8, 9, 5)),</span>
<span class="sd">         ((1, 2, 3, 4, 5, 0), (1, 2, 3, 4, 5, 0))}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">twin</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">_twin</span>
    <span class="k">if</span> <span class="n">twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">lt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">twin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">twin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">p</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lt</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lb</span><span class="p">)</span>
    <span class="n">fg</span> <span class="o">=</span> <span class="p">[</span><span class="n">perms_canonical_labels</span><span class="p">([</span><span class="n">ep</span><span class="p">,</span><span class="n">fp</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ep</span><span class="p">,</span><span class="n">fp</span> <span class="ow">in</span> <span class="n">to_fat_graphs</span><span class="p">(</span><span class="n">twin</span><span class="p">)]</span>
    <span class="n">fg</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">fg</span><span class="p">))</span></div>


<div class="viewcode-block" id="interval_conversion">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.interval_conversion">[docs]</a>
<span class="k">def</span> <span class="nf">interval_conversion</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the argument in 0 or 1.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``winner`` - &#39;top&#39; (or &#39;t&#39; or 0) or bottom (or &#39;b&#39; or 1)</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    integer -- 0 or 1</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from surface_dynamics import *</span>

<span class="sd">        sage: from surface_dynamics.interval_exchanges.template import interval_conversion</span>
<span class="sd">        sage: interval_conversion(&#39;top&#39;)</span>
<span class="sd">        0</span>
<span class="sd">        sage: interval_conversion(&#39;t&#39;)</span>
<span class="sd">        0</span>
<span class="sd">        sage: interval_conversion(0)</span>
<span class="sd">        0</span>
<span class="sd">        sage: interval_conversion(&#39;bottom&#39;)</span>
<span class="sd">        1</span>
<span class="sd">        sage: interval_conversion(&#39;b&#39;)</span>
<span class="sd">        1</span>
<span class="sd">        sage: interval_conversion(1)</span>
<span class="sd">        1</span>

<span class="sd">    .. Non admissible strings raise a ValueError::</span>

<span class="sd">        sage: interval_conversion(&#39;&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: the interval can not be the empty string</span>
<span class="sd">        sage: interval_conversion(&#39;right&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: &#39;right&#39; can not be converted to interval</span>
<span class="sd">        sage: interval_conversion(&#39;top_right&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: &#39;top_right&#39; can not be converted to interval</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">interval</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interval must be 0 or 1&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">interval</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">interval</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the interval can not be the empty string&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;top&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="s1">&#39;bottom&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; can not be converted to interval&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">interval</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not an admissible type&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">interval</span><span class="p">)))</span></div>


<div class="viewcode-block" id="side_conversion">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.side_conversion">[docs]</a>
<span class="k">def</span> <span class="nf">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the argument in 0 or -1.</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``side`` - either &#39;left&#39; (or &#39;l&#39; or 0) or &#39;right&#39; (or &#39;r&#39; or -1)</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    integer -- 0 or -1</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from surface_dynamics.interval_exchanges.template import side_conversion</span>
<span class="sd">        sage: side_conversion(&#39;left&#39;)</span>
<span class="sd">        0</span>
<span class="sd">        sage: side_conversion(&#39;l&#39;)</span>
<span class="sd">        0</span>
<span class="sd">        sage: side_conversion(0)</span>
<span class="sd">        0</span>
<span class="sd">        sage: side_conversion(&#39;right&#39;)</span>
<span class="sd">        -1</span>
<span class="sd">        sage: side_conversion(&#39;r&#39;)</span>
<span class="sd">        -1</span>
<span class="sd">        sage: side_conversion(1)</span>
<span class="sd">        -1</span>
<span class="sd">        sage: side_conversion(-1)</span>
<span class="sd">        -1</span>

<span class="sd">    .. Non admissible strings raise a ValueError::</span>

<span class="sd">        sage: side_conversion(&#39;&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: no empty string for side</span>
<span class="sd">        sage: side_conversion(&#39;top&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: &#39;top&#39; can not be converted to a side</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">side</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">side</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">side</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no empty string for side&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;left&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">side</span><span class="p">):</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="s1">&#39;right&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">side</span><span class="p">):</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; can not be converted to a side&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">side</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;side must be 0 or 1&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not an admissible type&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">side</span><span class="p">)))</span></div>


<span class="c1">#</span>
<span class="c1"># NICE PRINTING OF FLIPS</span>
<span class="c1">#</span>

<div class="viewcode-block" id="labelize_flip">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.labelize_flip">[docs]</a>
<span class="k">def</span> <span class="nf">labelize_flip</span><span class="p">(</span><span class="n">couple</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a string from a 2-uple couple of the form (name, flip).</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from surface_dynamics.interval_exchanges.template import labelize_flip</span>
<span class="sd">        sage: labelize_flip((0,1))</span>
<span class="sd">        &#39; 0&#39;</span>
<span class="sd">        sage: labelize_flip((0,-1))</span>
<span class="sd">        &#39;-0&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">couple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">couple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">couple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<span class="c1">#</span>
<span class="c1"># CLASSES FOR PERMUTATIONS</span>
<span class="c1">#</span>

<div class="viewcode-block" id="Permutation">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation">[docs]</a>
<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">Permutation</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Template for all permutations.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Internal class! Do not use directly!</span>

<span class="sd">    This class implement generic algorithm (stratum, connected component, ...)</span>
<span class="sd">    and unfies all its children.</span>

<span class="sd">    It has four attributes</span>

<span class="sd">    - ``_alphabet`` -- the alphabet on which the permutation is defined. Be</span>
<span class="sd">      careful, it might have a different cardinality as the size of the</span>
<span class="sd">      permutation!</span>

<span class="sd">     - ``_twin`` -- the permutation</span>

<span class="sd">     - ``_labels`` -- None or the list of labels</span>

<span class="sd">     - ``_flips`` -- None or the list of flips (each flip is either ``1`` or</span>
<span class="sd">       ``-1``)</span>

<span class="sd">    The datatype for ``_twin`` differs for IET and LI (TODO: unify).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_alphabet</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_twin</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_labels</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_flips</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flips</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT:</span>

<span class="sd">        - ``intervals`` - the intervals as a list of two lists</span>

<span class="sd">        - ``alphabet`` - something that should be converted to an alphabet</span>

<span class="sd">        - ``reduced`` - (boolean) whether the permutation is reduced or labeled</span>

<span class="sd">        - ``flips`` - (optional) a list of letters of the alphabet to be flipped (in which</span>
<span class="sd">          case the permutation corresponds to non-orientable surface)</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics.interval_exchanges.labelled import LabelledPermutationIET</span>

<span class="sd">            sage: p1 = LabelledPermutationIET([[1,2,3],[3,2,1]])</span>
<span class="sd">            sage: p1 == loads(dumps(p1))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p2 = LabelledPermutationIET([[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;]])</span>
<span class="sd">            sage: p2 == loads(dumps(p2))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p3 = LabelledPermutationIET([[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;],[&#39;3&#39;,&#39;2&#39;,&#39;1&#39;]])</span>
<span class="sd">            sage: p3 == loads(dumps(p3))</span>
<span class="sd">            True</span>
<span class="sd">            sage: from surface_dynamics.interval_exchanges.labelled import LabelledPermutationLI</span>
<span class="sd">            sage: p1 = LabelledPermutationLI([[1,2,2],[3,3,1]])</span>
<span class="sd">            sage: p1 == loads(dumps(p1))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p2 = LabelledPermutationLI([[&#39;a&#39;,&#39;b&#39;,&#39;b&#39;],[&#39;c&#39;,&#39;c&#39;,&#39;a&#39;]])</span>
<span class="sd">            sage: p2 == loads(dumps(p2))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p3 = LabelledPermutationLI([[&#39;1&#39;,&#39;2&#39;,&#39;2&#39;],[&#39;3&#39;,&#39;3&#39;,&#39;1&#39;]])</span>
<span class="sd">            sage: p3 == loads(dumps(p3))</span>
<span class="sd">            True</span>

<span class="sd">            sage: from surface_dynamics.interval_exchanges.reduced import ReducedPermutationIET</span>
<span class="sd">            sage: p = ReducedPermutationIET()</span>
<span class="sd">            sage: loads(dumps(p)) == p</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = ReducedPermutationIET([[&#39;a&#39;,&#39;b&#39;],[&#39;b&#39;,&#39;a&#39;]])</span>
<span class="sd">            sage: loads(dumps(p)) == p</span>
<span class="sd">            True</span>
<span class="sd">            sage: from surface_dynamics.interval_exchanges.reduced import ReducedPermutationLI</span>
<span class="sd">            sage: p = ReducedPermutationLI()</span>
<span class="sd">            sage: loads(dumps(p)) == p</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = ReducedPermutationLI([[&#39;a&#39;,&#39;a&#39;],[&#39;b&#39;,&#39;b&#39;]])</span>
<span class="sd">            sage: loads(dumps(p)) == p</span>
<span class="sd">            True</span>

<span class="sd">            sage: from surface_dynamics.interval_exchanges.labelled import FlippedLabelledPermutationIET</span>
<span class="sd">            sage: p = FlippedLabelledPermutationIET([[&#39;a&#39;,&#39;b&#39;],[&#39;a&#39;,&#39;b&#39;]],flips=&#39;a&#39;)</span>
<span class="sd">            sage: p == loads(dumps(p))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = FlippedLabelledPermutationIET([[&#39;a&#39;,&#39;b&#39;],[&#39;b&#39;,&#39;a&#39;]],flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p == loads(dumps(p))</span>
<span class="sd">            True</span>

<span class="sd">            sage: from surface_dynamics.interval_exchanges.labelled import FlippedLabelledPermutationLI</span>
<span class="sd">            sage: p = FlippedLabelledPermutationLI([[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;],[&#39;b&#39;,&#39;c&#39;,&#39;c&#39;]],flips=&#39;a&#39;)</span>
<span class="sd">            sage: p == loads(dumps(p))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = FlippedLabelledPermutationLI([[&#39;a&#39;,&#39;a&#39;],[&#39;b&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;]],flips=&#39;ac&#39;)</span>
<span class="sd">            sage: p == loads(dumps(p))</span>
<span class="sd">            True</span>

<span class="sd">            sage: from surface_dynamics import iet</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,reduced=True,flips=&#39;a&#39;)</span>
<span class="sd">            sage: p == loads(dumps(p))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,reduced=True,flips=&#39;b&#39;)</span>
<span class="sd">            sage: p == loads(dumps(p))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,reduced=True,flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p == loads(dumps(p))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,reduced=True,flips=&#39;a&#39;)</span>
<span class="sd">            sage: p == loads(dumps(p))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,reduced=True,flips=&#39;b&#39;)</span>
<span class="sd">            sage: p == loads(dumps(p))</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,reduced=True,flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p == loads(dumps(p))</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this constructor assumes that several methods are present</span>
        <span class="c1">#  _init_twin(intervals)</span>
        <span class="c1">#  _set_alphabet(alphabet)</span>
        <span class="c1">#  _init_alphabet(intervals)</span>
        <span class="c1">#  _init_flips(intervals, flips)</span>

        <span class="c1"># setting twins</span>
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_twin</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>

        <span class="c1"># setting alphabet</span>
        <span class="k">if</span> <span class="n">alphabet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_alphabet</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>

        <span class="c1"># optionally setting labels</span>
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reduced</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_alphabet</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_alphabet</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]</span>

        <span class="c1"># optionally setting flips</span>
        <span class="k">if</span> <span class="n">flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_flips</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">flips</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_flips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">intervals</span><span class="p">,</span><span class="n">flips</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the flip list</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,flips=&#39;a&#39;).flips() #indirect doctest</span>
<span class="sd">            [&#39;a&#39;]</span>
<span class="sd">            sage: iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,flips=&#39;b&#39;).flips() #indirect doctest</span>
<span class="sd">            [&#39;b&#39;]</span>
<span class="sd">            sage: iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,flips=&#39;ab&#39;).flips() #indirect doctest</span>
<span class="sd">            [&#39;a&#39;, &#39;b&#39;]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,flips=&#39;a&#39;).flips()</span>
<span class="sd">            [&#39;a&#39;]</span>
<span class="sd">            sage: iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,flips=&#39;b&#39;).flips()</span>
<span class="sd">            [&#39;b&#39;]</span>
<span class="sd">            sage: iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,flips=&#39;ab&#39;).flips()</span>
<span class="sd">            [&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">length_top</span><span class="p">(),</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">length_bottom</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">letter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="n">interval</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">flips</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests equality</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p1 = iet.Permutation(&#39;a b&#39;,&#39;a b&#39;,reduced=True,alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(&#39;a b&#39;,&#39;a b&#39;,reduced=True,alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: q1 = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,reduced=True,alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: q2 = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,reduced=True,alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: p1 == p2 and p2 == p1 and q1 == q2 and q2 == q1</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 == q1 or p2 == q1 or q1 == p1 or q1 == p2</span>
<span class="sd">            False</span>

<span class="sd">            sage: p1 = iet.Permutation(&#39;a b&#39;, &#39;b a&#39;, alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(&#39;a b&#39;, &#39;b a&#39;, alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: q1 = iet.Permutation(&#39;b a&#39;, &#39;a b&#39;, alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: q2 = iet.Permutation(&#39;b a&#39;, &#39;a b&#39;, alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: p1 == p2 or p2 == p1</span>
<span class="sd">            False</span>
<span class="sd">            sage: p1 == q1 or q1 == p1</span>
<span class="sd">            False</span>
<span class="sd">            sage: p1 == q2 or q2 == p1</span>
<span class="sd">            False</span>
<span class="sd">            sage: p2 == q1 or q1 == p2</span>
<span class="sd">            False</span>
<span class="sd">            sage: p2 == q2 or q2 == p2</span>
<span class="sd">            False</span>
<span class="sd">            sage: q1 == q2 or q2 == q1</span>
<span class="sd">            False</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p1 = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: p2 = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: q1 = iet.GeneralizedPermutation(&#39;b b&#39;,&#39;a a&#39;,alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: q2 = iet.GeneralizedPermutation(&#39;b b&#39;,&#39;a a&#39;,alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: p1 == p2 or p2 == p1</span>
<span class="sd">            False</span>
<span class="sd">            sage: p1 == q1 or q1 == p1</span>
<span class="sd">            False</span>
<span class="sd">            sage: p1 == q2 or q2 == p1</span>
<span class="sd">            False</span>
<span class="sd">            sage: p2 == q1 or q1 == p2</span>
<span class="sd">            False</span>
<span class="sd">            sage: p2 == q2 or q2 == p2</span>
<span class="sd">            False</span>
<span class="sd">            sage: q1 == q2 or q2 == q1</span>
<span class="sd">            False</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b b&#39;, &#39;c c a&#39;, reduced = True)</span>
<span class="sd">            sage: q = iet.GeneralizedPermutation(&#39;b a a&#39;, &#39;c c b&#39;, reduced = True)</span>
<span class="sd">            sage: r = iet.GeneralizedPermutation(&#39;t s s&#39;, &#39;w w t&#39;, reduced = True)</span>
<span class="sd">            sage: p == q</span>
<span class="sd">            True</span>
<span class="sd">            sage: p == r</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;a b&#39;,reduced=True,flips=&#39;a&#39;)</span>
<span class="sd">            sage: q = copy(p)</span>
<span class="sd">            sage: q.alphabet([0,1])</span>
<span class="sd">            sage: p == q</span>
<span class="sd">            True</span>
<span class="sd">            sage: l0 = [&#39;a b&#39;,&#39;a b&#39;]</span>
<span class="sd">            sage: l1 = [&#39;a b&#39;,&#39;b a&#39;]</span>
<span class="sd">            sage: l2 = [&#39;b a&#39;, &#39;a b&#39;]</span>
<span class="sd">            sage: p0 = iet.Permutation(l0, reduced=True, flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p1 = iet.Permutation(l1, reduced=True, flips=&#39;a&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(l2, reduced=True, flips=&#39;b&#39;)</span>
<span class="sd">            sage: p3 = iet.Permutation(l1, reduced=True, flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p4 = iet.Permutation(l2 ,reduced=True,flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p0 == p1 or p0 == p2 or p0 == p3 or p0 == p4</span>
<span class="sd">            False</span>
<span class="sd">            sage: p1 == p2 and p3 == p4</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 == p3 or p1 == p4 or p2 == p3 or p2 == p4</span>
<span class="sd">            False</span>

<span class="sd">        ::</span>

<span class="sd">            sage: a0 = [0,0,1]</span>
<span class="sd">            sage: a1 = [1,2,2]</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(a0,a1,reduced=True,flips=[0])</span>
<span class="sd">            sage: q = copy(p)</span>
<span class="sd">            sage: q.alphabet(&quot;abc&quot;)</span>
<span class="sd">            sage: p == q</span>
<span class="sd">            True</span>
<span class="sd">            sage: b0 = [1,0,0]</span>
<span class="sd">            sage: b1 = [2,2,1]</span>
<span class="sd">            sage: r = iet.GeneralizedPermutation(b0,b1,reduced=True,flips=[0])</span>
<span class="sd">            sage: p == r or q == r</span>
<span class="sd">            False</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p1 = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;a&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;b&#39;)</span>
<span class="sd">            sage: p3 = iet.Permutation(&#39;d e f&#39;, &#39;f e d&#39;, flips=&#39;d&#39;)</span>
<span class="sd">            sage: p1 == p1 and p2 == p2 and p3 == p3</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 == p2</span>
<span class="sd">            False</span>
<span class="sd">            sage: p1 == p3</span>
<span class="sd">            False</span>
<span class="sd">            sage: p1.reduced() == p3.reduced()</span>
<span class="sd">            True</span>

<span class="sd">            sage: p1 = iet.Permutation(&#39;a b&#39;, &#39;a b&#39;, reduced=True, alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(&#39;a b&#39;, &#39;a b&#39;, reduced=True, alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: q1 = iet.Permutation(&#39;a b&#39;, &#39;b a&#39;, reduced=True, alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: q2 = iet.Permutation(&#39;a b&#39;, &#39;b a&#39;, reduced=True, alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: p1 != p2 or p2 != p1 or q1 != q2 or q2 != q1</span>
<span class="sd">            False</span>
<span class="sd">            sage: p1 != q1 and p2 != q1 and q1 != p1 and q1 != p2</span>
<span class="sd">            True</span>

<span class="sd">            sage: p1 = iet.Permutation(&#39;a b&#39;, &#39;b a&#39;, alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(&#39;a b&#39;, &#39;b a&#39;, alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: q1 = iet.Permutation(&#39;b a&#39;, &#39;a b&#39;, alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: q2 = iet.Permutation(&#39;b a&#39;, &#39;a b&#39;, alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: p1 != p2 and p2 != p1</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 != q1 and q1 != p1</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 != q2 and q2 != p1</span>
<span class="sd">            True</span>
<span class="sd">            sage: p2 != q1 and q1 != p2</span>
<span class="sd">            True</span>
<span class="sd">            sage: p2 != q2 and q2 != p2</span>
<span class="sd">            True</span>
<span class="sd">            sage: q1 != q2 and q2 != q1</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p1 = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: p2 = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: q1 = iet.GeneralizedPermutation(&#39;b b&#39;,&#39;a a&#39;,alphabet=&#39;ab&#39;)</span>
<span class="sd">            sage: q2 = iet.GeneralizedPermutation(&#39;b b&#39;,&#39;a a&#39;,alphabet=&#39;ba&#39;)</span>
<span class="sd">            sage: p1 != p2 or p2 != p1</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 != q1 or q1 != p1</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 != q2 or q2 != p1</span>
<span class="sd">            True</span>
<span class="sd">            sage: p2 != q1 or q1 != p2</span>
<span class="sd">            True</span>
<span class="sd">            sage: p2 != q2 or q2 != p2</span>
<span class="sd">            True</span>
<span class="sd">            sage: q1 != q2 or q2 != q1</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b b&#39;, &#39;c c a&#39;, reduced = True)</span>
<span class="sd">            sage: q = iet.GeneralizedPermutation(&#39;b b a&#39;, &#39;c c a&#39;, reduced = True)</span>
<span class="sd">            sage: r = iet.GeneralizedPermutation(&#39;i j j&#39;, &#39;k k i&#39;, reduced = True)</span>
<span class="sd">            sage: p != q</span>
<span class="sd">            True</span>
<span class="sd">            sage: p != r</span>
<span class="sd">            False</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;a b&#39;,reduced=True,flips=&#39;a&#39;)</span>
<span class="sd">            sage: q = copy(p)</span>
<span class="sd">            sage: q.alphabet([0,1])</span>
<span class="sd">            sage: p != q</span>
<span class="sd">            False</span>
<span class="sd">            sage: l0 = [&#39;a b&#39;,&#39;a b&#39;]</span>
<span class="sd">            sage: l1 = [&#39;a b&#39;,&#39;b a&#39;]</span>
<span class="sd">            sage: l2 = [&#39;b a&#39;, &#39;a b&#39;]</span>
<span class="sd">            sage: p0 = iet.Permutation(l0, reduced=True, flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p1 = iet.Permutation(l1, reduced=True, flips=&#39;a&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(l2, reduced=True, flips=&#39;b&#39;)</span>
<span class="sd">            sage: p3 = iet.Permutation(l1, reduced=True, flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p4 = iet.Permutation(l2 ,reduced=True,flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p0 != p1 and p0 != p2 and p0 != p3 and p0 != p4</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 != p2 or p3 != p4</span>
<span class="sd">            False</span>
<span class="sd">            sage: p1 != p3 and p1 != p4 and p2 != p3 and p2 != p4</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: a0 = [0,0,1]</span>
<span class="sd">            sage: a1 = [1,2,2]</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(a0,a1,reduced=True,flips=[0])</span>
<span class="sd">            sage: q = copy(p)</span>
<span class="sd">            sage: q.alphabet(&quot;abc&quot;)</span>
<span class="sd">            sage: p != q</span>
<span class="sd">            False</span>
<span class="sd">            sage: b0 = [1,0,0]</span>
<span class="sd">            sage: b1 = [2,2,1]</span>
<span class="sd">            sage: r = iet.GeneralizedPermutation(b0,b1,reduced=True,flips=[0])</span>
<span class="sd">            sage: p != r and q != r</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p1 = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;,flips=&#39;a&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;,flips=&#39;b&#39;)</span>
<span class="sd">            sage: p3 = iet.Permutation(&#39;d e f&#39;,&#39;f e d&#39;,flips=&#39;d&#39;)</span>
<span class="sd">            sage: p1 != p1 or p2 != p2 or p3 != p3</span>
<span class="sd">            False</span>
<span class="sd">            sage: p1 != p2</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 != p3</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1.reduced() != p3.reduced()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_twin</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alphabet</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_alphabet</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines a natural lexicographic order.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b&#39;,&#39;a b&#39;,reduced=True)</span>
<span class="sd">            sage: q = copy(p)</span>
<span class="sd">            sage: q.alphabet([0,1])</span>
<span class="sd">            sage: p == q</span>
<span class="sd">            True</span>
<span class="sd">            sage: p0 = iet.GeneralizedPermutation(&#39;a b&#39;, &#39;a b&#39;, reduced=True)</span>
<span class="sd">            sage: p1 = iet.GeneralizedPermutation(&#39;a b&#39;, &#39;b a&#39;, reduced=True)</span>
<span class="sd">            sage: p0 &lt; p1 and p1 &gt; p0</span>
<span class="sd">            True</span>
<span class="sd">            sage: q0 = iet.GeneralizedPermutation(&#39;a b c&#39;,&#39;a b c&#39;,reduced=True)</span>
<span class="sd">            sage: q1 = iet.GeneralizedPermutation(&#39;a b c&#39;,&#39;a c b&#39;,reduced=True)</span>
<span class="sd">            sage: q2 = iet.GeneralizedPermutation(&#39;a b c&#39;,&#39;b a c&#39;,reduced=True)</span>
<span class="sd">            sage: q3 = iet.GeneralizedPermutation(&#39;a b c&#39;,&#39;c a b&#39;,reduced=True)</span>
<span class="sd">            sage: q4 = iet.GeneralizedPermutation(&#39;a b c&#39;,&#39;b c a&#39;,reduced=True)</span>
<span class="sd">            sage: q5 = iet.GeneralizedPermutation(&#39;a b c&#39;,&#39;c b a&#39;,reduced=True)</span>
<span class="sd">            sage: p0 &lt; q0 and q0 &gt; p0 and p1 &lt; q0 and q0 &gt; p1</span>
<span class="sd">            True</span>
<span class="sd">            sage: q0 &lt; q1 and q1 &gt; q0</span>
<span class="sd">            True</span>
<span class="sd">            sage: q1 &lt; q2 and q2 &gt; q1</span>
<span class="sd">            True</span>
<span class="sd">            sage: q2 &lt; q3 and q3 &gt; q2</span>
<span class="sd">            True</span>
<span class="sd">            sage: q3 &lt; q4 and q4 &gt; q3</span>
<span class="sd">            True</span>
<span class="sd">            sage: q4 &lt; q5 and q5 &gt; q4</span>
<span class="sd">            True</span>

<span class="sd">            sage: p0 = iet.Permutation(&#39;1 2&#39;, &#39;1 2&#39;)</span>
<span class="sd">            sage: p1 = iet.Permutation(&#39;1 2&#39;, &#39;2 1&#39;)</span>
<span class="sd">            sage: p0 != p0</span>
<span class="sd">            False</span>
<span class="sd">            sage: (p0 == p0) and (p0 &lt; p1)</span>
<span class="sd">            True</span>
<span class="sd">            sage: (p1 &gt; p0) and (p1 == p1)</span>
<span class="sd">            True</span>

<span class="sd">            sage: p0 = iet.GeneralizedPermutation(&#39;0 0&#39;,&#39;1 1 2 2&#39;)</span>
<span class="sd">            sage: p1 = iet.GeneralizedPermutation(&#39;0 0&#39;,&#39;1 2 1 2&#39;)</span>
<span class="sd">            sage: p2 = iet.GeneralizedPermutation(&#39;0 0&#39;,&#39;1 2 2 1&#39;)</span>
<span class="sd">            sage: p3 = iet.GeneralizedPermutation(&#39;0 0 1 1&#39;,&#39;2 2&#39;)</span>
<span class="sd">            sage: p4 = iet.GeneralizedPermutation(&#39;0 0 1&#39;,&#39;1 2 2&#39;)</span>
<span class="sd">            sage: p5 = iet.GeneralizedPermutation(&#39;0 1 0 1&#39;,&#39;2 2&#39;)</span>
<span class="sd">            sage: p6 = iet.GeneralizedPermutation(&#39;0 1 1 0&#39;,&#39;2 2&#39;)</span>
<span class="sd">            sage: p0 == p0 and p0 &lt; p1 and p0 &lt; p2 and p0 &lt; p3 and p0 &lt; p4</span>
<span class="sd">            True</span>
<span class="sd">            sage: p0 &lt; p5 and p0 &lt; p6 and p1 &lt; p2 and p1 &lt; p3 and p1 &lt; p4</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 &lt; p5 and p1 &lt; p6 and p2 &lt; p3 and p2 &lt; p4 and p2 &lt; p5</span>
<span class="sd">            True</span>
<span class="sd">            sage: p2 &lt; p6 and p3 &lt; p4 and p3 &lt; p5 and p3 &lt; p6 and p4 &lt; p5</span>
<span class="sd">            True</span>
<span class="sd">            sage: p4 &lt; p6 and p5 &lt; p6 and p0 == p0 and p1 == p1 and p2 == p2</span>
<span class="sd">            True</span>
<span class="sd">            sage: p3 == p3 and p4 == p4 and p5 == p5 and p6 == p6</span>
<span class="sd">            True</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;a b&#39;,reduced=True,flips=&#39;a&#39;)</span>
<span class="sd">            sage: q = copy(p)</span>
<span class="sd">            sage: q.alphabet([0,1])</span>
<span class="sd">            sage: p == q</span>
<span class="sd">            True</span>
<span class="sd">            sage: l0 = [&#39;a b&#39;,&#39;a b&#39;]</span>
<span class="sd">            sage: l1 = [&#39;a b&#39;,&#39;b a&#39;]</span>
<span class="sd">            sage: p1 = iet.Permutation(l1,reduced=True, flips=&#39;b&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(l1,reduced=True, flips=&#39;a&#39;)</span>
<span class="sd">            sage: p3 = iet.Permutation(l1,reduced=True, flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p2 &gt; p3 and p3 &lt; p2</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 &gt; p2 and p2 &lt; p1</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 &gt; p3 and p3 &lt; p1</span>
<span class="sd">            True</span>
<span class="sd">            sage: q1 = iet.Permutation(l0, reduced=True, flips=&#39;a&#39;)</span>
<span class="sd">            sage: q2 = iet.Permutation(l0, reduced=True, flips=&#39;b&#39;)</span>
<span class="sd">            sage: q3 = iet.Permutation(l0, reduced=True, flips=&#39;ab&#39;)</span>
<span class="sd">            sage: q2 &gt; q1 and q2 &gt; q3 and q1 &lt; q2 and q3 &lt; q2</span>
<span class="sd">            True</span>
<span class="sd">            sage: q1 &gt; q3</span>
<span class="sd">            True</span>
<span class="sd">            sage: q3 &lt; q1</span>
<span class="sd">            True</span>
<span class="sd">            sage: r = iet.Permutation(&#39;a b c&#39;,&#39;a b c&#39;, reduced=True, flips=&#39;a&#39;)</span>
<span class="sd">            sage: r &gt; p1 and r &gt; p2 and r &gt; p3</span>
<span class="sd">            True</span>
<span class="sd">            sage: p1 &lt; r and p2 &lt; r and p3 &lt; r</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Permutations must be of the same type&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_twin</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_twin</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_labels</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_labels</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_flips</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_flips</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># equality</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d a c b&#39;, flips=[&#39;a&#39;,&#39;b&#39;])</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">letters</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;letters are bad&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">i</span><span class="p">)):</span>
                <span class="n">j</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twin</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">twin</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;self.twin is not an involution: i=</span><span class="si">{}</span><span class="s2"> p=</span><span class="si">{}</span><span class="s2"> j=</span><span class="si">{}</span><span class="s2"> q=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">q</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">q</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;uncoherent getitem i=</span><span class="si">{}</span><span class="s2"> p=</span><span class="si">{}</span><span class="s2"> j=</span><span class="si">{}</span><span class="s2"> q=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">q</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">q</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;self._labels wrong i=</span><span class="si">{}</span><span class="s2"> p=</span><span class="si">{}</span><span class="s2"> j=</span><span class="si">{}</span><span class="s2"> q=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">q</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">q</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;self._flips wrong i=</span><span class="si">{}</span><span class="s2"> p=</span><span class="si">{}</span><span class="s2"> j=</span><span class="si">{}</span><span class="s2"> q=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">q</span><span class="p">))</span>

<div class="viewcode-block" id="Permutation.letters">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.letters">[docs]</a>
    <span class="k">def</span> <span class="nf">letters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of letters of the alphabet used for representation.</span>

<span class="sd">        The letters used are not necessarily the whole alphabet (for example if</span>
<span class="sd">        the alphabet is infinite).</span>

<span class="sd">        OUTPUT: a list of labels</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation([1,2],[2,1])</span>
<span class="sd">            sage: p.alphabet(Alphabet(name=&quot;NN&quot;))</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1</span>
<span class="sd">            1 0</span>
<span class="sd">            sage: p.letters()</span>
<span class="sd">            [0, 1]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;)</span>
<span class="sd">            sage: p.letters()</span>
<span class="sd">            [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">            sage: p.alphabet(range(10))</span>
<span class="sd">            sage: p.letters()</span>
<span class="sd">            [0, 1, 2]</span>
<span class="sd">            sage: p._remove_interval(0, 2)</span>
<span class="sd">            sage: p.letters()</span>
<span class="sd">            [0, 2]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;, &#39;b c c&#39;, reduced=True)</span>
<span class="sd">            sage: p.letters()</span>
<span class="sd">            [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="sd">        For permutations with flips, the letters appear as pairs made of an element</span>
<span class="sd">        of the alphabet and the flip::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;A B C D&#39;, &#39;D C A B&#39;, flips=&#39;AC&#39;)</span>
<span class="sd">            sage: p.letters()</span>
<span class="sd">            [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;,  &#39;D&#39;]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;A A B&#39;, &#39;B C C&#39;, flips=&#39;B&#39;)</span>
<span class="sd">            sage: p.letters()</span>
<span class="sd">            [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unrank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alphabet</span><span class="o">.</span><span class="n">unrank</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">unrank</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">labels</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">unrank</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span></div>


    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Representation method of self.</span>

<span class="sd">        Apply the function str to _repr_type(_repr_options) if _repr_type is</span>
<span class="sd">        callable and _repr_type else.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: p._repr_type = &#39;str&#39;</span>
<span class="sd">            sage: p._repr_options = (&#39;\n&#39;,)</span>
<span class="sd">            sage: p   #indirect doctest</span>
<span class="sd">            a b c</span>
<span class="sd">            c b a</span>
<span class="sd">            sage: p._repr_options = (&#39; / &#39;,)</span>
<span class="sd">            sage: p   #indirect doctest</span>
<span class="sd">            a b c / c b a</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p._repr_type = &#39;_twin&#39;</span>
<span class="sd">            sage: p   #indirect doctest</span>
<span class="sd">            [[2, 1, 0], [2, 1, 0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_type</span> <span class="o">==</span> <span class="s1">&#39;reduced&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_repr_options</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;)</span>
<span class="sd">            sage: q = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=[&#39;a&#39;])</span>
<span class="sd">            sage: r = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, reduced=True)</span>
<span class="sd">            sage: s = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=[&#39;a&#39;], reduced=True)</span>
<span class="sd">            sage: len(set([hash(p), hash(q), hash(r), hash(s)]))</span>
<span class="sd">            4</span>

<span class="sd">            sage: P = [iet.Permutation(t, b, flips=f, reduced=False) \</span>
<span class="sd">            ....:        for t in [&#39;a b&#39;, &#39;b a&#39;] \</span>
<span class="sd">            ....:        for b in [&#39;a b&#39;, &#39;b a&#39;] \</span>
<span class="sd">            ....:        for f in [None, &#39;a&#39;, &#39;b&#39;, &#39;ab&#39;]]</span>
<span class="sd">            sage: P.extend(iet.Permutation(&#39;a b&#39;, b, flips=f, reduced=True) \</span>
<span class="sd">            ....:        for b in [&#39;a b&#39;, &#39;b a&#39;] \</span>
<span class="sd">            ....:        for f in [None, &#39;a&#39;, &#39;b&#39;, &#39;ab&#39;])</span>
<span class="sd">            sage: len(set(hash(x) for x in P))</span>
<span class="sd">            24</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">*=</span> <span class="mi">7461864723258187525</span>
            <span class="n">h</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">h</span> <span class="o">+=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">letters</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">*=</span> <span class="mi">5566797465546889505</span>
            <span class="n">h</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">h</span>

<div class="viewcode-block" id="Permutation.str">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.str">[docs]</a>
    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A string representation of the generalized permutation.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``sep`` - (default: &#39;\n&#39;) a separator for the two intervals</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        string -- the string that represents the permutation</span>


<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        For permutations of iet::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: p.str()</span>
<span class="sd">            &#39;a b c\nc b a&#39;</span>
<span class="sd">            sage: p.str(sep=&#39; | &#39;)</span>
<span class="sd">            &#39;a b c | c b a&#39;</span>

<span class="sd">        The permutation can be rebuilt from the standard string::</span>

<span class="sd">            sage: p == iet.Permutation(p.str())</span>
<span class="sd">            True</span>

<span class="sd">        For permutations of li::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b b&#39;,&#39;c c a&#39;)</span>
<span class="sd">            sage: p.str()</span>
<span class="sd">            &#39;a b b\nc c a&#39;</span>
<span class="sd">            sage: p.str(sep=&#39; | &#39;)</span>
<span class="sd">            &#39;a b b | c c a&#39;</span>

<span class="sd">            sage: iet.GeneralizedPermutation([0,0], [1,2,3,2,1,3])</span>
<span class="sd">            0 0</span>
<span class="sd">            1 2 3 2 1 3</span>
<span class="sd">            sage: iet.GeneralizedPermutation([0,1,2,1,0,2], [3,3])</span>
<span class="sd">            0 1 2 1 0 2</span>
<span class="sd">            3 3</span>

<span class="sd">        Again, the generalized permutation can be rebuilt from the standard string::</span>

<span class="sd">            sage: p == iet.GeneralizedPermutation(p.str())</span>
<span class="sd">            True</span>

<span class="sd">        With flips::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,flips=&#39;a&#39;)</span>
<span class="sd">            sage: print(p.str())</span>
<span class="sd">            -a -a</span>
<span class="sd">             b  b</span>
<span class="sd">             sage: print(p.str(&#39;/&#39;))</span>
<span class="sd">             -a -a/ b  b</span>

<span class="sd">        Alignment with alphabet of different sizes::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;aa b ccc d&#39;, &#39;d b ccc aa&#39;)</span>
<span class="sd">            sage: print(p.str())</span>
<span class="sd">            aa b ccc d</span>
<span class="sd">            d b ccc aa</span>
<span class="sd">            sage: print(p.str(align=&#39;left&#39;))</span>
<span class="sd">            aa b ccc d</span>
<span class="sd">            d  b ccc aa</span>
<span class="sd">            sage: print(p.str(align=&#39;right&#39;))</span>
<span class="sd">            aa b ccc  d</span>
<span class="sd">             d b ccc aa</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;aa fff b ccc b fff d&#39;, &#39;eee d eee ccc aa&#39;)</span>
<span class="sd">            sage: print(p.str())</span>
<span class="sd">            aa fff b ccc b fff d</span>
<span class="sd">            eee d eee ccc aa</span>
<span class="sd">            sage: print(p.str(align=&#39;left&#39;))</span>
<span class="sd">            aa  fff b   ccc b  fff d</span>
<span class="sd">            eee d   eee ccc aa</span>
<span class="sd">            sage: print(p.str(align=&#39;right&#39;))</span>
<span class="sd">             aa fff   b ccc  b fff d</span>
<span class="sd">            eee   d eee ccc aa</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">l0</span><span class="p">,</span> <span class="n">l1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l0</span><span class="p">,</span> <span class="n">l1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">flips</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">labelize_flip</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l0</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">l0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="n">l0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">align</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                    <span class="n">l0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">s0</span><span class="p">))</span> <span class="o">+</span> <span class="n">l0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                    <span class="n">l0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">l0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">s0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                    <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="o">+</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                    <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l0</span><span class="p">)):</span>
            <span class="n">l0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="n">l0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">)):</span>
            <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l0</span><span class="p">),</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l1</span><span class="p">)])</span></div>


<div class="viewcode-block" id="Permutation.flips">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.flips">[docs]</a>
    <span class="k">def</span> <span class="nf">flips</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of flips.</span>

<span class="sd">        If the permutation is not a flipped permutations then ``None`` is returned.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;).flips()</span>
<span class="sd">            []</span>
<span class="sd">            sage: iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;ac&#39;).flips()</span>
<span class="sd">            [&#39;a&#39;, &#39;c&#39;]</span>
<span class="sd">            sage: iet.GeneralizedPermutation(&#39;a a&#39;, &#39;b b&#39;, flips=&#39;a&#39;).flips()</span>
<span class="sd">            [&#39;a&#39;]</span>
<span class="sd">            sage: iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;, flips=&#39;b&#39;, reduced=True).flips()</span>
<span class="sd">            [&#39;b&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">flips</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">letters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="n">letters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="n">letters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">letters</span></div>


    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of self.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, reduced=True)</span>
<span class="sd">            sage: q = copy(p)</span>
<span class="sd">            sage: p == q</span>
<span class="sd">            True</span>
<span class="sd">            sage: p is q</span>
<span class="sd">            False</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b b&#39;,&#39;c c a&#39;, reduced=True)</span>
<span class="sd">            sage: q = copy(p)</span>
<span class="sd">            sage: p == q</span>
<span class="sd">            True</span>
<span class="sd">            sage: p is q</span>
<span class="sd">            False</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: p1 = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, reduced=True)</span>
<span class="sd">            sage: p2 = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, reduced=False)</span>
<span class="sd">            sage: p3 = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;a&#39;, reduced=True)</span>
<span class="sd">            sage: p4 = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;a&#39;, reduced=False)</span>

<span class="sd">            sage: p5 = iet.GeneralizedPermutation(&#39;a a b&#39;, &#39;b c c&#39;, reduced=True)</span>
<span class="sd">            sage: p6 = iet.GeneralizedPermutation(&#39;a a b&#39;, &#39;b c c&#39;, reduced=False)</span>
<span class="sd">            sage: p7 = iet.GeneralizedPermutation(&#39;a a b&#39;, &#39;b c c&#39;, flips=&#39;a&#39;, reduced=True)</span>
<span class="sd">            sage: p8 = iet.GeneralizedPermutation(&#39;a a b&#39;, &#39;b c c&#39;, flips=&#39;a&#39;, reduced=False)</span>

<span class="sd">            sage: for p in (p1,p2,p3,p4,p5,p6,p7,p8):</span>
<span class="sd">            ....:     q = p.__copy__()</span>
<span class="sd">            ....:     assert type(p) is type(q)</span>
<span class="sd">            ....:     assert p == q</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

        <span class="n">q</span><span class="o">.</span><span class="n">_twin</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]]</span>
        <span class="n">q</span><span class="o">.</span><span class="n">_alphabet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alphabet</span>
        <span class="n">q</span><span class="o">.</span><span class="n">_repr_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_type</span>
        <span class="n">q</span><span class="o">.</span><span class="n">_repr_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_options</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">_flips</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">0</span><span class="p">][:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]]</span>

        <span class="k">return</span> <span class="n">q</span>

    <span class="n">_repr_type</span> <span class="o">=</span> <span class="s1">&#39;str&#39;</span>
    <span class="n">_repr_options</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,reduced=True)</span>
<span class="sd">            sage: len(p)</span>
<span class="sd">            2</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,reduced=False)</span>
<span class="sd">            sage: len(p)</span>
<span class="sd">            2</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;,reduced=True)</span>
<span class="sd">            sage: len(p)</span>
<span class="sd">            3</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;,reduced=False)</span>
<span class="sd">            sage: len(p)</span>
<span class="sd">            3</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;,reduced=True)</span>
<span class="sd">            sage: len(p)</span>
<span class="sd">            3</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;,reduced=False)</span>
<span class="sd">            sage: len(p)</span>
<span class="sd">            3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">//</span> <span class="mi">2</span>

<div class="viewcode-block" id="Permutation.length_top">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.length_top">[docs]</a>
    <span class="k">def</span> <span class="nf">length_top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of intervals in the top segment.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        integer -- the length of the top segment</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;, reduced=True)</span>
<span class="sd">            sage: p.length_top()</span>
<span class="sd">            3</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;, reduced=False)</span>
<span class="sd">            sage: p.length_top()</span>
<span class="sd">            3</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;c d c b d&#39;,reduced=True)</span>
<span class="sd">            sage: p.length_top()</span>
<span class="sd">            3</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;c d c d b&#39;,reduced=False)</span>
<span class="sd">            sage: p.length_top()</span>
<span class="sd">            3</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c b d c d&#39;, &#39;e a e&#39;,reduced=True)</span>
<span class="sd">            sage: p.length_top()</span>
<span class="sd">            7</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c d b c d&#39;, &#39;e a e&#39;, reduced=False)</span>
<span class="sd">            sage: p.length_top()</span>
<span class="sd">            7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="Permutation.length_bottom">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.length_bottom">[docs]</a>
    <span class="k">def</span> <span class="nf">length_bottom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of intervals in the bottom segment.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        integer -- the length of the bottom segment</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;,reduced=True)</span>
<span class="sd">            sage: p.length_bottom()</span>
<span class="sd">            3</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;,reduced=False)</span>
<span class="sd">            sage: p.length_bottom()</span>
<span class="sd">            3</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;c d c b d&#39;,reduced=True)</span>
<span class="sd">            sage: p.length_bottom()</span>
<span class="sd">            5</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;c d c b d&#39;,reduced=False)</span>
<span class="sd">            sage: p.length_bottom()</span>
<span class="sd">            5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="Permutation.length">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.length">[docs]</a>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the 2-uple of lengths.</span>

<span class="sd">        p.length() is identical to (p.length_top(), p.length_bottom())</span>
<span class="sd">        If an interval is specified, it returns the length of the specified</span>
<span class="sd">        interval.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``interval`` - None, &#39;top&#39; (or &#39;t&#39; or 0) or &#39;bottom&#39; (or &#39;b&#39; or 1)</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        integer or 2-uple of integers -- the corresponding lengths</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;,reduced=False)</span>
<span class="sd">            sage: p.length()</span>
<span class="sd">            (3, 3)</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;,reduced=True)</span>
<span class="sd">            sage: p.length()</span>
<span class="sd">            (3, 3)</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;c d c b d&#39;,reduced=False)</span>
<span class="sd">            sage: p.length()</span>
<span class="sd">            (3, 5)</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;c d c b d&#39;,reduced=True)</span>
<span class="sd">            sage: p.length()</span>
<span class="sd">            (3, 5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">])</span></div>


    <span class="k">def</span> <span class="nf">_set_alphabet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alphabet</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the alphabet of self.</span>

<span class="sd">        TESTS:</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;)</span>
<span class="sd">            sage: p.alphabet([0,1])   #indirect doctest</span>
<span class="sd">            sage: p.alphabet() == Alphabet([0,1])</span>
<span class="sd">            True</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 0</span>
<span class="sd">            1 1</span>
<span class="sd">            sage: p.alphabet(&quot;cd&quot;)   #indirect doctest</span>
<span class="sd">            sage: p.alphabet() == Alphabet([&#39;c&#39;,&#39;d&#39;])</span>
<span class="sd">            True</span>
<span class="sd">            sage: p</span>
<span class="sd">            c c</span>
<span class="sd">            d d</span>

<span class="sd">        Tests with reduced permutations::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,reduced=True)</span>
<span class="sd">            sage: p.alphabet([0,1])   #indirect doctest</span>
<span class="sd">            sage: p.alphabet() == Alphabet([0,1])</span>
<span class="sd">            True</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1</span>
<span class="sd">            1 0</span>
<span class="sd">            sage: p.alphabet(&quot;cd&quot;)   #indirect doctest</span>
<span class="sd">            sage: p.alphabet() == Alphabet([&#39;c&#39;,&#39;d&#39;])</span>
<span class="sd">            True</span>
<span class="sd">            sage: p</span>
<span class="sd">            c d</span>
<span class="sd">            d c</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,reduced=True)</span>
<span class="sd">            sage: p.alphabet([0,1])   #indirect doctest</span>
<span class="sd">            sage: p.alphabet() == Alphabet([0,1])</span>
<span class="sd">            True</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 0</span>
<span class="sd">            1 1</span>
<span class="sd">            sage: p.alphabet(&quot;cd&quot;)   #indirect doctest</span>
<span class="sd">            sage: p.alphabet() == Alphabet([&#39;c&#39;,&#39;d&#39;])</span>
<span class="sd">            True</span>
<span class="sd">            sage: p</span>
<span class="sd">            c c</span>
<span class="sd">            d d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.combinat.words.alphabet</span> <span class="kn">import</span> <span class="n">build_alphabet</span>
        <span class="n">alphabet</span> <span class="o">=</span> <span class="n">build_alphabet</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alphabet</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not enough letters in alphabet&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alphabet</span> <span class="o">=</span> <span class="n">alphabet</span>

<div class="viewcode-block" id="Permutation.alphabet">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.alphabet">[docs]</a>
    <span class="k">def</span> <span class="nf">alphabet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manages the alphabet of self.</span>

<span class="sd">        If there is no argument, the method returns the alphabet used. If the</span>
<span class="sd">        argument could be converted to an alphabet, this alphabet will be used.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``data`` - None or something that could be converted to an alphabet</span>


<span class="sd">        OUTPUT:</span>

<span class="sd">        - either None or the current alphabet</span>


<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;a b&#39;)</span>
<span class="sd">            sage: p.alphabet([0,1])</span>
<span class="sd">            sage: p.alphabet() == Alphabet([0,1])</span>
<span class="sd">            True</span>
<span class="sd">            sage: p</span>
<span class="sd">            0 1</span>
<span class="sd">            0 1</span>
<span class="sd">            sage: p.alphabet(&quot;cd&quot;)</span>
<span class="sd">            sage: p.alphabet() == Alphabet([&#39;c&#39;,&#39;d&#39;])</span>
<span class="sd">            True</span>
<span class="sd">            sage: p</span>
<span class="sd">            c d</span>
<span class="sd">            c d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alphabet</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_alphabet</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Permutation.left_right_inverse">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.left_right_inverse">[docs]</a>
    <span class="k">def</span> <span class="nf">left_right_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the left-right inverse.</span>

<span class="sd">        The left-right inverse of a permutation, is the permutation obtained by</span>
<span class="sd">        reversing the order of the underlying ordering.</span>

<span class="sd">        You can also use the shorter .lr_inverse()</span>

<span class="sd">        There are two other symmetries of permutation which are accessible via</span>
<span class="sd">        the methods</span>
<span class="sd">        :meth:`Permutation.top_bottom_inverse` and</span>
<span class="sd">        :meth:`Permutation.symmetric`.</span>

<span class="sd">        OUTPUT: a permutation</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        For labelled permutations::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c a b&#39;)</span>
<span class="sd">            sage: p.left_right_inverse()</span>
<span class="sd">            c b a</span>
<span class="sd">            b a c</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;c d a b&#39;)</span>
<span class="sd">            sage: p.left_right_inverse()</span>
<span class="sd">            d c b a</span>
<span class="sd">            b a d c</span>

<span class="sd">        for reduced permutations::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c a b&#39;,reduced=True)</span>
<span class="sd">            sage: p.left_right_inverse()</span>
<span class="sd">            a b c</span>
<span class="sd">            b c a</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;c d a b&#39;,reduced=True)</span>
<span class="sd">            sage: p.left_right_inverse()</span>
<span class="sd">            a b c d</span>
<span class="sd">            c d a b</span>

<span class="sd">        for labelled quadratic permutations::</span>

<span class="sd">             sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;)</span>
<span class="sd">             sage: p.left_right_inverse()</span>
<span class="sd">             a a</span>
<span class="sd">             c c b b</span>

<span class="sd">        for reduced quadratic permutations::</span>

<span class="sd">             sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;,reduced=True)</span>
<span class="sd">             sage: p.left_right_inverse() == p</span>
<span class="sd">             True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_reversed_twin</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">res</span></div>


    <span class="n">lr_inverse</span> <span class="o">=</span> <span class="n">left_right_inverse</span>
    <span class="n">vertical_inverse</span> <span class="o">=</span> <span class="n">left_right_inverse</span>

<div class="viewcode-block" id="Permutation.top_bottom_inverse">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.top_bottom_inverse">[docs]</a>
    <span class="k">def</span> <span class="nf">top_bottom_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the top-bottom inverse.</span>

<span class="sd">        You can use also use the shorter .tb_inverse().</span>

<span class="sd">        There are two other symmetries of permutation which are accessible via</span>
<span class="sd">        the methods</span>
<span class="sd">        :meth:`Permutation.left_right_inverse` and</span>
<span class="sd">        :meth:`Permutation.symmetric`.</span>

<span class="sd">        OUTPUT: a permutation</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: p.top_bottom_inverse()</span>
<span class="sd">            b a</span>
<span class="sd">            a b</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,reduced=True)</span>
<span class="sd">            sage: p.top_bottom_inverse() == p</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;c d a b&#39;)</span>
<span class="sd">            sage: p.top_bottom_inverse()</span>
<span class="sd">            c d a b</span>
<span class="sd">            a b c d</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;a b&#39;)</span>
<span class="sd">            sage: p == p.top_bottom_inverse()</span>
<span class="sd">            True</span>
<span class="sd">            sage: p is p.top_bottom_inverse()</span>
<span class="sd">            False</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,reduced=True)</span>
<span class="sd">            sage: p == p.top_bottom_inverse()</span>
<span class="sd">            True</span>
<span class="sd">            sage: p is p.top_bottom_inverse()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_inversed_twin</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_flips</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">res</span></div>


    <span class="n">tb_inverse</span> <span class="o">=</span> <span class="n">top_bottom_inverse</span>
    <span class="n">horizontal_inverse</span> <span class="o">=</span> <span class="n">top_bottom_inverse</span>

<div class="viewcode-block" id="Permutation.symmetric">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.symmetric">[docs]</a>
    <span class="k">def</span> <span class="nf">symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the symmetric permutation.</span>

<span class="sd">        The symmetric permutation is the composition of the top-bottom</span>
<span class="sd">        inversion and the left-right inversion (which are geometrically</span>
<span class="sd">        orientation reversing).</span>

<span class="sd">        There are two other symmetries of permutation which are accessible via</span>
<span class="sd">        the methods</span>
<span class="sd">        :meth:`Permutation.left_right_inverse` and</span>
<span class="sd">        :meth:`Permutation.top_bottom_inverse`.</span>

<span class="sd">        OUTPUT: a permutation</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;,reduced=True)</span>
<span class="sd">            sage: p.symmetric() == p</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;c a d b&#39;,reduced=True)</span>
<span class="sd">            sage: q = p.symmetric()</span>
<span class="sd">            sage: q</span>
<span class="sd">            a b c d</span>
<span class="sd">            b d a c</span>
<span class="sd">            sage: q1 = p.tb_inverse().lr_inverse()</span>
<span class="sd">            sage: q2 = p.lr_inverse().tb_inverse()</span>
<span class="sd">            sage: q == q1 and q == q2</span>
<span class="sd">            True</span>

<span class="sd">        It works for any type of permutations::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b b&#39;,&#39;c c a&#39;,flips=&#39;ab&#39;)</span>
<span class="sd">            sage: p</span>
<span class="sd">            -a -b -b</span>
<span class="sd">             c  c -a</span>
<span class="sd">            sage: p.symmetric()</span>
<span class="sd">            -a  c  c</span>
<span class="sd">            -b -b -a</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;,reduced=True)</span>
<span class="sd">            sage: q = p.symmetric()</span>
<span class="sd">            sage: q1 = p.tb_inverse().lr_inverse()</span>
<span class="sd">            sage: q2 = p.lr_inverse().tb_inverse()</span>
<span class="sd">            sage: q == q1 and q == q2</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_inversed_twin</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_reversed_twin</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">res</span></div>


    <span class="k">def</span> <span class="nf">_canonical_signs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return label positions and orientation in some compatible way.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a dictionary whose keys are the labels of this permutation and the</span>
<span class="sd">          value associated to a label `a` is a pair `((ip,jp), (im,jm))` made</span>
<span class="sd">          of the two positions of `a`.</span>

<span class="sd">        - a list of two lists that give the signs of each subinterval</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;d a e a b b&#39;,&#39;e c c d&#39;)</span>
<span class="sd">            sage: twins, orientation = p._canonical_signs()</span>
<span class="sd">            sage: twins</span>
<span class="sd">            {&#39;a&#39;: [(0, 1), (0, 3)],</span>
<span class="sd">             &#39;b&#39;: [(0, 4), (0, 5)],</span>
<span class="sd">             &#39;c&#39;: [(1, 2), (1, 1)],</span>
<span class="sd">             &#39;d&#39;: [(0, 0), (1, 3)],</span>
<span class="sd">             &#39;e&#39;: [(0, 2), (1, 0)]}</span>
<span class="sd">            sage: orientation</span>
<span class="sd">            [[1, 1, 1, -1, 1, -1], [-1, -1, 1, -1]]</span>

<span class="sd">            sage: for a, ((ip,jp),(im,jm)) in twins.items():</span>
<span class="sd">            ....:     assert p[ip][jp] == p[im][jm] == a</span>
<span class="sd">            ....:     assert orientation[ip][jp] == +1</span>
<span class="sd">            ....:     assert orientation[im][jm] == -1</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;ac&#39;)</span>
<span class="sd">            sage: twins, orientation = p._canonical_signs()</span>
<span class="sd">            sage: twins</span>
<span class="sd">            {&#39;a&#39;: [(0, 0), (1, 2)],</span>
<span class="sd">             &#39;b&#39;: [(0, 1), (1, 1)],</span>
<span class="sd">             &#39;c&#39;: [(0, 2), (1, 0)]}</span>
<span class="sd">            sage: orientation</span>
<span class="sd">            [[1, 1, 1], [1, -1, 1]]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;, &#39;b b c c&#39;, flips=&#39;b&#39;)</span>
<span class="sd">            sage: twins, orientation = p._canonical_signs()</span>
<span class="sd">            sage: twins</span>
<span class="sd">            {&#39;a&#39;: [(0, 0), (0, 1)],</span>
<span class="sd">             &#39;b&#39;: [(1, 1), (1, 0)],</span>
<span class="sd">             &#39;c&#39;: [(1, 3), (1, 2)]}</span>
<span class="sd">            sage: orientation</span>
<span class="sd">            [[1, -1], [1, 1, -1, 1]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flips</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span>
        <span class="n">letters</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">letters</span><span class="p">())</span>

        <span class="n">label_to_twins</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sign_top</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sign_bot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">:</span>  <span class="c1"># first time seen</span>
                <span class="n">sign_top</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">label_to_twins</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)]</span>
                <span class="n">letters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>             <span class="c1"># already seen</span>
                <span class="k">if</span> <span class="n">flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flips</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">sign_top</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sign_top</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">label_to_twins</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">:</span>  <span class="c1"># first time seen</span>
                <span class="n">sign_bot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">letters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">label_to_twins</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>             <span class="c1"># already seen</span>
                <span class="k">if</span> <span class="n">flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flips</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">sign_bot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sign_bot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">label_to_twins</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
        <span class="n">sign_bot</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">label_to_twins</span><span class="p">,</span> <span class="p">[</span><span class="n">sign_top</span><span class="p">,</span> <span class="n">sign_bot</span><span class="p">])</span>

<div class="viewcode-block" id="Permutation.interval_diagram">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.interval_diagram">[docs]</a>
    <span class="k">def</span> <span class="nf">interval_diagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">glue_ends</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the interval diagram of self.</span>

<span class="sd">        The result is in random order.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``glue_ends`` - bool (default: True)</span>

<span class="sd">        - ``sign`` - bool (default: False)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[&#39;b&#39;, (&#39;c&#39;, &#39;a&#39;)], [&#39;b&#39;, (&#39;c&#39;, &#39;a&#39;)]]</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c a b&#39;)</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[&#39;a&#39;, &#39;b&#39;], [(&#39;c&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;a&#39;)]]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;)</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[&#39;a&#39;], [(&#39;b&#39;, &#39;a&#39;, &#39;c&#39;)], [&#39;b&#39;], [&#39;c&#39;]]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b b&#39;,&#39;c c&#39;)</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[&#39;a&#39;], [(&#39;b&#39;, &#39;c&#39;, &#39;a&#39;)], [&#39;b&#39;], [&#39;c&#39;]]</span>
<span class="sd">            sage: p.interval_diagram(sign=True)</span>
<span class="sd">            [[(&#39;a&#39;, -1)], [((&#39;b&#39;, 1), (&#39;c&#39;, 1), (&#39;a&#39;, 1))], [(&#39;b&#39;, -1)], [(&#39;c&#39;, -1)]]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation((0,1,0,2),(3,2,4,1,4,3))</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[0, 1, 4, 1], [2, 3, 4, (2, 3, 0)]]</span>
<span class="sd">            sage: p.interval_diagram(sign=True)</span>
<span class="sd">            [[(0, -1), (1, 1), (4, -1), (1, -1)],</span>
<span class="sd">             [(2, 1), (3, -1), (4, 1), ((2, -1), (3, 1), (0, 1))]]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c d b&#39;, &#39;e d f e a f c&#39;, flips=&#39;bdf&#39;)</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;c&#39;, (&#39;b&#39;, &#39;c&#39;), &#39;d&#39;, &#39;f&#39;], [(&#39;e&#39;, &#39;a&#39;)]]</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;0 1 2 3 2&#39;,&#39;4 3 4 1 0&#39;)</span>
<span class="sd">            sage: p.interval_diagram(sign=True)</span>
<span class="sd">            [[(&#39;1&#39;, 1), ((&#39;4&#39;, 1), (&#39;0&#39;, 1)), (&#39;1&#39;, -1), ((&#39;2&#39;, 1), (&#39;0&#39;, -1))],</span>
<span class="sd">             [(&#39;2&#39;, -1), (&#39;3&#39;, 1), (&#39;4&#39;, -1), (&#39;3&#39;, -1)]]</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;a&#39;)</span>
<span class="sd">            sage: p.interval_diagram(glue_ends=False, sign=True)</span>
<span class="sd">            [[(&#39;a&#39;, -1), (&#39;b&#39;, -1), (&#39;c&#39;, 1), (&#39;a&#39;, 1), (&#39;c&#39;, -1), (&#39;b&#39;, 1)]]</span>
<span class="sd">            sage: p.interval_diagram(glue_ends=True, sign=False)</span>
<span class="sd">            [[&#39;a&#39;, &#39;b&#39;, (&#39;c&#39;, &#39;a&#39;, &#39;c&#39;), &#39;b&#39;]]</span>

<span class="sd">            sage: iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;b&#39;).interval_diagram(glue_ends=False, sign=True)</span>
<span class="sd">            [[(&#39;a&#39;, -1), (&#39;b&#39;, 1), (&#39;a&#39;, 1), (&#39;c&#39;, 1), (&#39;b&#39;, -1), (&#39;c&#39;, -1)]]</span>
<span class="sd">            sage: iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;c&#39;).interval_diagram(glue_ends=False, sign=True)</span>
<span class="sd">            [[(&#39;a&#39;, -1), (&#39;b&#39;, 1), (&#39;c&#39;, 1), (&#39;b&#39;, -1), (&#39;a&#39;, 1), (&#39;c&#39;, -1)]]</span>

<span class="sd">            sage: iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;bc&#39;).interval_diagram(glue_ends=False, sign=True)</span>
<span class="sd">            [[(&#39;a&#39;, -1), (&#39;b&#39;, 1), (&#39;a&#39;, 1), (&#39;c&#39;, -1)], [(&#39;b&#39;, -1), (&#39;c&#39;, 1)]]</span>

<span class="sd">            sage: iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;ac&#39;).interval_diagram(glue_ends=False, sign=True)</span>
<span class="sd">            [[(&#39;a&#39;, -1), (&#39;b&#39;, -1), (&#39;c&#39;, 1), (&#39;b&#39;, 1)], [(&#39;a&#39;, 1), (&#39;c&#39;, -1)]]</span>

<span class="sd">            sage: iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;ab&#39;).interval_diagram(glue_ends=False, sign=True)</span>
<span class="sd">            [[(&#39;a&#39;, -1), (&#39;b&#39;, 1)], [(&#39;a&#39;, 1), (&#39;c&#39;, -1), (&#39;b&#39;, -1), (&#39;c&#39;, 1)]]</span>

<span class="sd">            sage: iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=&#39;abc&#39;).interval_diagram(glue_ends=False, sign=True)</span>
<span class="sd">            [[(&#39;a&#39;, -1), (&#39;b&#39;, 1)], [(&#39;a&#39;, 1), (&#39;c&#39;, -1)], [(&#39;b&#39;, -1), (&#39;c&#39;, 1)]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: each interval comes with an orientation (obtained from the</span>
        <span class="c1"># method ._canonical_signs(). We label each side of each interval</span>
        <span class="c1"># by either +1 or -1 as follows</span>
        <span class="c1">#</span>
        <span class="c1">#   o----------------&gt;--------------o</span>
        <span class="c1">#  +1 (for source)       -1 (for target)</span>
        <span class="c1">#</span>
        <span class="n">flips</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span>
        <span class="n">twin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twin_list</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
        <span class="n">letters</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">label</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">letters</span><span class="p">()</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">label_to_twins</span><span class="p">,</span> <span class="n">orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canonical_signs</span><span class="p">()</span>
        <span class="n">m0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">singularities</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">just_glued</span> <span class="o">=</span> <span class="kc">False</span>     <span class="c1"># True iff the last elt in singularity is paired</span>
        <span class="n">glued_at_begin</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># True iff the 1st elt in singularity is paired</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">letters</span><span class="p">:</span>
            <span class="c1"># pick a remaining letter</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># try picking the minimum</span>
                <span class="n">t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
                <span class="n">letters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">label</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># pick a random one</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;failure&#39;</span><span class="p">)</span>
                <span class="n">label</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">letters</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="p">(</span><span class="n">i0</span><span class="p">,</span><span class="n">p0</span><span class="p">),(</span><span class="n">i1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span> <span class="o">=</span> <span class="n">label_to_twins</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>  <span class="c1"># its two positions in the interval</span>

            <span class="c1"># try to see if one of (i0, p0) fits for anti-clockwise order</span>
            <span class="c1"># otherwise start with clockwise direction</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">orientation</span><span class="p">[</span><span class="n">i0</span><span class="p">][</span><span class="n">p0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="o">=</span> <span class="n">i0</span><span class="p">,</span><span class="n">p0</span>
                    <span class="n">flip</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">orientation</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="o">=</span> <span class="n">i1</span><span class="p">,</span><span class="n">p1</span>
                    <span class="n">flip</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="o">=</span> <span class="n">i0</span><span class="p">,</span><span class="n">p0</span>
                    <span class="n">flip</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">orientation</span><span class="p">[</span><span class="n">i0</span><span class="p">][</span><span class="n">p0</span><span class="p">]</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="o">=</span> <span class="n">i0</span><span class="p">,</span><span class="n">p0</span>
                    <span class="n">flip</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">orientation</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="o">=</span> <span class="n">i1</span><span class="p">,</span><span class="n">p1</span>
                    <span class="n">flip</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="o">=</span> <span class="n">i0</span><span class="p">,</span><span class="n">p0</span>
                    <span class="n">flip</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>


            <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
                <span class="n">singularity</span> <span class="o">=</span> <span class="p">[(</span><span class="n">label</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">singularity</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="o">=</span> <span class="n">twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flips</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">flip</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>      <span class="c1"># twin on top</span>
                    <span class="n">p</span> <span class="o">+=</span> <span class="n">flip</span>   <span class="c1"># next interval</span>
                    <span class="k">if</span> <span class="n">flip</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="n">m0</span><span class="p">:</span>     <span class="c1"># at the right end?</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">m1</span><span class="o">-</span><span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># at the left end?</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>           <span class="c1"># twin on bot</span>
                    <span class="n">p</span> <span class="o">-=</span> <span class="n">flip</span>   <span class="c1"># next interval</span>
                    <span class="k">if</span> <span class="n">flip</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>     <span class="c1"># at the left end?</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="n">m1</span><span class="p">:</span>  <span class="c1"># at the right end?</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">m0</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="n">label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">flip</span> <span class="o">*</span> <span class="n">orientation</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="p">]</span>


                <span class="k">if</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">glue_ends</span> <span class="ow">and</span>
                        <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="n">m1</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span>
                         <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="n">m1</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))):</span>
                        <span class="n">sg2</span> <span class="o">=</span> <span class="n">singularity</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">sg1</span> <span class="o">=</span> <span class="n">singularity</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">glued_at_begin</span><span class="p">:</span>
                            <span class="n">singularity</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sg1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">sg2</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">just_glued</span><span class="p">:</span>
                            <span class="n">singularity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sg1</span> <span class="o">+</span> <span class="p">(</span><span class="n">sg2</span><span class="p">,))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">singularity</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sg1</span><span class="p">,</span> <span class="n">sg2</span><span class="p">))</span>
                    <span class="k">break</span>
                <span class="n">letters</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">label</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">glue_ends</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="n">m1</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">flip</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="n">m1</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))):</span>
                    <span class="n">sg1</span> <span class="o">=</span> <span class="n">singularity</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
                        <span class="n">sg2</span> <span class="o">=</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sg2</span> <span class="o">=</span> <span class="n">label</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">singularity</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">glued_at_begin</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">just_glued</span><span class="p">:</span>
                        <span class="n">singularity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sg1</span> <span class="o">+</span> <span class="p">(</span><span class="n">sg2</span><span class="p">,))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">singularity</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sg1</span><span class="p">,</span><span class="n">sg2</span><span class="p">))</span>
                    <span class="n">just_glued</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
                        <span class="n">singularity</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">label</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">singularity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                    <span class="n">just_glued</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">singularities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">singularity</span><span class="p">)</span>
            <span class="n">just_glued</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">glued_at_begin</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">singularities</span></div>


    <span class="k">def</span> <span class="nf">_remove_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the letter in the interval ``i`` and position ``pos`` (and its</span>
<span class="sd">        twin).</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d a b c&#39;)</span>
<span class="sd">            sage: p._remove_interval(0, 1); p</span>
<span class="sd">            a c d</span>
<span class="sd">            d a c</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            sage: p.twin_list()</span>
<span class="sd">            [[(1, 1), (1, 2), (1, 0)], [(0, 2), (0, 0), (0, 1)]]</span>
<span class="sd">            sage: p._remove_interval(0, 2); p</span>
<span class="sd">            a c</span>
<span class="sd">            a c</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            sage: p.twin_list()</span>
<span class="sd">            [[(1, 0), (1, 1)], [(0, 0), (0, 1)]]</span>
<span class="sd">            sage: p._remove_interval(0, 0); p</span>
<span class="sd">            c</span>
<span class="sd">            c</span>
<span class="sd">            sage: p.twin_list()</span>
<span class="sd">            [[(1, 0)], [(0, 0)]]</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d c b a&#39;, reduced=True)</span>
<span class="sd">            sage: p._remove_interval(0, 1); p</span>
<span class="sd">            a b c</span>
<span class="sd">            c b a</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            sage: p._remove_interval(1, 0); p</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>
<span class="sd">            sage: p._check()</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d a c b&#39;, flips=[&#39;a&#39;,&#39;b&#39;])</span>
<span class="sd">            sage: p._remove_interval(0, 0); p</span>
<span class="sd">            -b  c  d</span>
<span class="sd">             d  c -b</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            sage: p._remove_interval(1, 0); p</span>
<span class="sd">            -b  c</span>
<span class="sd">             c -b</span>
<span class="sd">            sage: p._check()</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c e d&#39;, &#39;e b d a c&#39;)</span>
<span class="sd">            sage: p._remove_interval(0, 3); p</span>
<span class="sd">            a b c d</span>
<span class="sd">            b d a c</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            sage: p._remove_interval(1, 3); p</span>
<span class="sd">            a b d</span>
<span class="sd">            b d a</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            sage: p._remove_interval(1, 0); p</span>
<span class="sd">            a d</span>
<span class="sd">            d a</span>
<span class="sd">            sage: p._check()</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b c b e d e&#39;, &#39;f c d f g g&#39;)</span>
<span class="sd">            sage: p._remove_interval(0, 0)</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            sage: p._remove_interval(0, 4)</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            sage: p._remove_interval(1, 4)</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            sage: p</span>
<span class="sd">            b c b e e</span>
<span class="sd">            f c f</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">ii</span><span class="p">,</span> <span class="n">ppos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twin</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">ii</span> <span class="ow">and</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">ppos</span><span class="p">:</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">ppos</span> <span class="o">=</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">pos</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">twin_list</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">q</span><span class="p">,(</span><span class="n">jj</span><span class="p">,</span><span class="n">qq</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="p">(</span><span class="n">jj</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">qq</span> <span class="o">&gt;</span> <span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">jj</span> <span class="o">==</span> <span class="n">ii</span> <span class="ow">and</span> <span class="n">qq</span> <span class="o">&gt;</span> <span class="n">ppos</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dec</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_twin</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">qq</span> <span class="o">-</span> <span class="n">dec</span><span class="p">)</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ppos</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ppos</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ppos</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_identify_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify the two intervals on the right (if ``side=-1``) or on the left</span>
<span class="sd">        (if ``side=0``).</span>

<span class="sd">        This is needed for the generalized Rauzy induction when the length on</span>
<span class="sd">        top and bottom are equal.</span>

<span class="sd">        The label of the top interval disappears.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c a b&#39;)</span>
<span class="sd">            sage: p._identify_intervals(-1); p</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>
<span class="sd">            sage: p._check()</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;)</span>
<span class="sd">            sage: p._identify_intervals(0); p</span>
<span class="sd">            b c</span>
<span class="sd">            b c</span>
<span class="sd">            sage: p._check()</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;)</span>
<span class="sd">            sage: p._identify_intervals(0); p</span>
<span class="sd">            b c</span>
<span class="sd">            b c</span>
<span class="sd">            sage: p._check()</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;c a d b&#39;)</span>
<span class="sd">            sage: p._identify_intervals(-1); p</span>
<span class="sd">            a b c</span>
<span class="sd">            c a b</span>
<span class="sd">            sage: p._check()</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d a c b&#39;)</span>
<span class="sd">            sage: p._identify_intervals(-1); p</span>
<span class="sd">            a b c</span>
<span class="sd">            b a c</span>
<span class="sd">            sage: p._check()</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a d e e a b&#39;, &#39;b c c d&#39;)</span>
<span class="sd">            sage: p._identify_intervals(0); p</span>
<span class="sd">            d e e b b</span>
<span class="sd">            c c d</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">            sage: p._identify_intervals(-1); p</span>
<span class="sd">            d e e d</span>
<span class="sd">            c c</span>
<span class="sd">            sage: p._check()</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b b&#39;, &#39;a c c&#39;)</span>
<span class="sd">            sage: p._identify_intervals(0); p</span>
<span class="sd">            b b</span>
<span class="sd">            c c</span>
<span class="sd">            sage: p._check()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not implemented if there is a flip&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos0</span> <span class="o">=</span> <span class="n">pos1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">pos0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_top</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">pos1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_bottom</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">twin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">twin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos0</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos1</span><span class="p">,</span> <span class="n">twin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">twin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos0</span><span class="p">)</span>

<div class="viewcode-block" id="Permutation.cover">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.cover">[docs]</a>
    <span class="k">def</span> <span class="nf">cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a covering of this permutation.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``perms`` - a list of permutations that describe the gluings</span>

<span class="sd">        - ``as_tuple`` - whether permutations need to be considered as `1`-based</span>
<span class="sd">          (default) or `0`-based.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import iet</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;, &#39;b a&#39;)</span>
<span class="sd">            sage: p.cover([&#39;(1,2)&#39;, &#39;(1,3)&#39;])</span>
<span class="sd">            Covering of degree 3 of the permutation:</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>

<span class="sd">            sage: p.cover([[1,0,2], [2,1,0]], as_tuple=True)</span>
<span class="sd">            Covering of degree 3 of the permutation:</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b b&#39;,&#39;c c&#39;)</span>
<span class="sd">            sage: q = p.cover([&#39;(0,1)&#39;, [], [2,1,0]], as_tuple=True)</span>
<span class="sd">            sage: q</span>
<span class="sd">            Covering of degree 3 of the permutation:</span>
<span class="sd">            a a b b</span>
<span class="sd">            c c</span>
<span class="sd">            sage: q.covering_data(&#39;a&#39;)</span>
<span class="sd">            (1,2)</span>
<span class="sd">            sage: q.covering_data(&#39;b&#39;)</span>
<span class="sd">            ()</span>
<span class="sd">            sage: q.covering_data(&#39;c&#39;)</span>
<span class="sd">            (1,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong number of permutations&quot;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">surface_dynamics.misc.permutation</span> <span class="kn">import</span> <span class="n">perm_init</span><span class="p">,</span> <span class="n">equalize_perms</span>
        <span class="k">if</span> <span class="n">as_tuple</span><span class="p">:</span>
            <span class="n">perms</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm_init</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Trac #28652: Rework the constructor of PermutationGroupElement</span>
                <span class="kn">from</span> <span class="nn">sage.groups.perm_gps.constructor</span> <span class="kn">import</span> <span class="n">PermutationGroupElement</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">sage.groups.perm_gps.permgroup_element</span> <span class="kn">import</span> <span class="n">PermutationGroupElement</span>
            <span class="n">perms</span> <span class="o">=</span> <span class="p">[</span><span class="n">PermutationGroupElement</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">]</span>
            <span class="n">perms</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">domain</span><span class="p">()]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">]</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">equalize_perms</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">.cover</span> <span class="kn">import</span> <span class="n">PermutationCover</span>
        <span class="k">return</span> <span class="n">PermutationCover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">perms</span><span class="p">)</span></div>


<div class="viewcode-block" id="Permutation.regular_cover">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.Permutation.regular_cover">[docs]</a>
    <span class="k">def</span> <span class="nf">regular_cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">elts</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a regular (or normal) cover of this permutation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import iet</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d c b a&#39;)</span>
<span class="sd">            sage: G = SymmetricGroup(4)</span>
<span class="sd">            sage: ga = G(&#39;(1,2)&#39;)</span>
<span class="sd">            sage: gb = G(&#39;(1,3,4)&#39;)</span>
<span class="sd">            sage: gc = G(&#39;(1,3)&#39;)</span>
<span class="sd">            sage: gd = G(&#39;()&#39;)</span>
<span class="sd">            sage: pp = p.regular_cover(G, [ga, gb, gc, gd])</span>
<span class="sd">            sage: pp</span>
<span class="sd">            Regular cover of degree 24 with group Symmetric group of order 4! as a permutation group of the permutation:</span>
<span class="sd">            a b c d</span>
<span class="sd">            d c b a</span>
<span class="sd">            sage: pp.genus()</span>
<span class="sd">            33</span>

<span class="sd">        Additive groups are converted to multiplicative groups::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;, &#39;b c c&#39;)</span>
<span class="sd">            sage: G = Zmod(5)</span>
<span class="sd">            sage: p.regular_cover(G, [0, 1, 2])</span>
<span class="sd">            Regular cover of degree 5 with group Multiplicative Abelian group isomorphic to C5 of the permutation:</span>
<span class="sd">            a a b</span>
<span class="sd">            b c c</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.cover</span> <span class="kn">import</span> <span class="n">RegularCover</span>
        <span class="k">return</span> <span class="n">RegularCover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">elts</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="PermutationIET">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationIET">[docs]</a>
<span class="k">class</span> <span class="nc">PermutationIET</span><span class="p">(</span><span class="n">Permutation</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_init_twin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the twin list.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.Permutation(&#39;a b&#39;,&#39;b a&#39;,reduced=True) #indirect doctest</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>
<span class="sd">            sage: iet.Permutation(&#39;a b c&#39;,&#39;c a b&#39;,reduced=True) #indirect doctest</span>
<span class="sd">            a b c</span>
<span class="sd">            c a b</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">=</span> <span class="p">[[],[]]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

<div class="viewcode-block" id="PermutationIET.twin">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationIET.twin">[docs]</a>
    <span class="k">def</span> <span class="nf">twin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the twin of the interval in the interval ``i`` at position</span>
<span class="sd">        ``pos``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c e d&#39;, &#39;e b d a c&#39;)</span>
<span class="sd">            sage: p.twin(0,0)</span>
<span class="sd">            (1, 3)</span>
<span class="sd">            sage: p.twin(0,1)</span>
<span class="sd">            (1, 1)</span>

<span class="sd">            sage: twin_top = [p.twin(0,i) for i in range(p.length_top())]</span>
<span class="sd">            sage: twin_bot = [p.twin(1,i) for i in range(p.length_bottom())]</span>
<span class="sd">            sage: p.twin_list() == [twin_top, twin_bot]</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pos</span><span class="p">])</span></div>


    <span class="k">def</span> <span class="nf">_set_twin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>

<div class="viewcode-block" id="PermutationIET.twin_list">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationIET.twin_list">[docs]</a>
    <span class="k">def</span> <span class="nf">twin_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the twin list of self.</span>

<span class="sd">        The twin list is the involution without fixed point associated to that</span>
<span class="sd">        permutation seen as two lines of symbols. As the domain is two lines,</span>
<span class="sd">        the position are 2-tuples `(i,j)` where `i` specifies the line and `j`</span>
<span class="sd">        the position in the line.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: p.twin_list()[0]</span>
<span class="sd">            [(1, 2), (1, 1), (1, 0)]</span>
<span class="sd">            sage: p.twin_list()[1]</span>
<span class="sd">            [(0, 2), (0, 1), (0, 0)]</span>

<span class="sd">        We may check that it is actually an involution without fixed point::</span>

<span class="sd">            sage: t = p.twin_list()</span>
<span class="sd">            sage: all(t[i][j] != (i,j) for i in range(2) for j in range(len(t[i])))</span>
<span class="sd">            True</span>
<span class="sd">            sage: all(t[t[i][j][0]][t[i][j][1]] == (i,j) for i in range(2) for j in range(len(t[i])))</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">twin0</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">twin1</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">twin0</span><span class="p">,</span><span class="n">twin1</span><span class="p">]</span></div>


    <span class="k">def</span> <span class="nf">_init_alphabet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the alphabet from intervals.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``a`` - the two intervals as lists</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d c a b&#39;)   #indirect doctest</span>
<span class="sd">            sage: p.alphabet() == Alphabet([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = iet.Permutation([0,1,2],[1,0,2],reduced=True)   #indirect doctest</span>
<span class="sd">            sage: p.alphabet() == Alphabet([0,1,2])</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.combinat.words.alphabet</span> <span class="kn">import</span> <span class="n">build_alphabet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alphabet</span> <span class="o">=</span> <span class="n">build_alphabet</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_inversed_twin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverses the twin of the permutation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c a b&#39;,reduced=True)</span>
<span class="sd">            sage: p.left_right_inverse() # indirect doc test</span>
<span class="sd">            a b c</span>
<span class="sd">            b c a</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d a b c&#39;,reduced=True)</span>
<span class="sd">            sage: p.left_right_inverse() # indirect doctest</span>
<span class="sd">            a b c d</span>
<span class="sd">            b c d a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">_reversed_twin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverses the twin of the permutation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c a b&#39;,reduced=True)</span>
<span class="sd">            sage: p.top_bottom_inverse() # indirect doctest</span>
<span class="sd">            a b c</span>
<span class="sd">            b c a</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d a b c&#39;,reduced=True)</span>
<span class="sd">            sage: p.top_bottom_inverse() # indircet doctest</span>
<span class="sd">            a b c d</span>
<span class="sd">            b c d a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]]</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_top</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="k">def</span> <span class="nf">_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">interval_to</span><span class="p">,</span> <span class="n">position_to</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves the element at (interval,position) to (interval, position_to)</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``interval`` - 0 or 1</span>

<span class="sd">        - ``position`` - a position in interval</span>

<span class="sd">        - ``interval_to`` - 0 or 1</span>

<span class="sd">        - ``position_to`` - a position in interval</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d c b a&#39;)</span>
<span class="sd">            sage: p._move(0,0,0,2)</span>
<span class="sd">            sage: p</span>
<span class="sd">            b a c d</span>
<span class="sd">            d c b a</span>
<span class="sd">            sage: p._move(0,1,0,3)</span>
<span class="sd">            sage: p</span>
<span class="sd">            b c a d</span>
<span class="sd">            d c b a</span>
<span class="sd">            sage: p._move(0,2,0,4)</span>
<span class="sd">            sage: p</span>
<span class="sd">            b c d a</span>
<span class="sd">            d c b a</span>
<span class="sd">            sage: p._move(1,3,1,1)</span>
<span class="sd">            sage: p</span>
<span class="sd">            b c d a</span>
<span class="sd">            d a c b</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">interval</span> <span class="o">==</span> <span class="n">interval_to</span>

        <span class="k">if</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="n">position_to</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                        <span class="n">position_to</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                        <span class="n">position_to</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

            <span class="n">elti</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">interval</span>
            <span class="n">eltp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">position</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">position</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">position_to</span><span class="p">]</span>

            <span class="c1"># decrement the twin between position and position to</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">elti</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">position</span><span class="o">+</span><span class="n">j</span>

            <span class="c1"># modify twin of the moved element</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">elti</span><span class="p">][</span><span class="n">eltp</span><span class="p">]</span> <span class="o">=</span> <span class="n">position_to</span><span class="o">-</span><span class="mi">1</span>

            <span class="c1"># move</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">position_to</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">position_to</span> <span class="o">&lt;</span> <span class="n">position</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                        <span class="n">position_to</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                        <span class="n">position_to</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

            <span class="n">elti</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">interval</span>
            <span class="n">eltp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">position</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">position_to</span><span class="p">:</span><span class="n">position</span><span class="p">]</span>

            <span class="c1"># increment the twin between position and position to</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">interval</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">position_to</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span>

            <span class="c1"># modify twin of the moved element</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">elti</span><span class="p">][</span><span class="n">eltp</span><span class="p">]</span> <span class="o">=</span> <span class="n">position_to</span>

            <span class="c1"># move</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">position_to</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

<div class="viewcode-block" id="PermutationIET.has_rauzy_move">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationIET.has_rauzy_move">[docs]</a>
    <span class="k">def</span> <span class="nf">has_rauzy_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if a Rauzy move can be performed on this permutation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        for labelled permutations::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;a c b&#39;,reduced=False)</span>
<span class="sd">            sage: p.has_rauzy_move(0,&#39;right&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.has_rauzy_move(0,&#39;left&#39;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: p.has_rauzy_move(1,&#39;right&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.has_rauzy_move(1,&#39;left&#39;)</span>
<span class="sd">            False</span>

<span class="sd">        for reduced permutations::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;a c b&#39;,reduced=True)</span>
<span class="sd">            sage: p.has_rauzy_move(0,&#39;right&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.has_rauzy_move(0,&#39;left&#39;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: p.has_rauzy_move(1,&#39;right&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.has_rauzy_move(1,&#39;left&#39;)</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="n">side</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="PermutationIET.is_irreducible">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationIET.is_irreducible">[docs]</a>
    <span class="k">def</span> <span class="nf">is_irreducible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_decomposition</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test irreducibility.</span>

<span class="sd">        A permutation p = (p0,p1) is reducible if:</span>
<span class="sd">        set(p0[:i]) = set(p1[:i]) for an i &lt; len(p0)</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a boolean</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;)</span>
<span class="sd">            sage: p.is_irreducible()</span>
<span class="sd">            True</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;b a c&#39;)</span>
<span class="sd">            sage: p.is_irreducible()</span>
<span class="sd">            False</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;, flips=[&#39;a&#39;])</span>
<span class="sd">            sage: p.is_irreducible()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">s0</span> <span class="o">+=</span> <span class="n">i</span>
            <span class="n">s1</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s0</span> <span class="o">==</span> <span class="n">s1</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">return_decomposition</span> <span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">return_decomposition</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],[],</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">],[])</span>
        <span class="k">return</span> <span class="kc">True</span></div>
</div>



<div class="viewcode-block" id="PermutationLI">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI">[docs]</a>
<span class="k">class</span> <span class="nc">PermutationLI</span><span class="p">(</span><span class="n">Permutation</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_init_twin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the _twin attribute</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,reduced=True)   #indirect doctest</span>
<span class="sd">            sage: p._twin</span>
<span class="sd">            [[(0, 1), (0, 0)], [(1, 1), (1, 0)]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">=</span> <span class="p">[[],[]]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">twin</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))],</span>
                <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">twin</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="n">twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="p">:</span>
                            <span class="c1"># two up or two down</span>
                            <span class="n">j2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="n">twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span>
                            <span class="n">twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># one up, one down (here i=0)</span>
                            <span class="n">j2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                            <span class="n">twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j2</span><span class="p">)</span>
                            <span class="n">twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">=</span> <span class="n">twin</span>

    <span class="k">def</span> <span class="nf">_init_alphabet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization procedure of the alphabet of self from intervals list</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;)   #indirect doctest</span>
<span class="sd">            sage: p.alphabet()</span>
<span class="sd">            {&#39;a&#39;, &#39;b&#39;}</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;b b&#39;,&#39;a a&#39;)  #indirect doctest</span>
<span class="sd">            sage: p.alphabet()</span>
<span class="sd">            {&#39;b&#39;, &#39;a&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp_alphabet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span>
            <span class="k">if</span> <span class="n">letter</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tmp_alphabet</span> <span class="p">:</span>
                <span class="n">tmp_alphabet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.combinat.words.alphabet</span> <span class="kn">import</span> <span class="n">build_alphabet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alphabet</span> <span class="o">=</span> <span class="n">build_alphabet</span><span class="p">(</span><span class="n">tmp_alphabet</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_inversed_twin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverses the twin of the permutation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;,reduced=True)</span>
<span class="sd">            sage: p.left_right_inverse() #indirect doctest</span>
<span class="sd">            a a</span>
<span class="sd">            b b</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;,reduced=True)</span>
<span class="sd">            sage: p.left_right_inverse() #indirect doctest</span>
<span class="sd">            a b b</span>
<span class="sd">            c c a</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;,reduced=True)</span>
<span class="sd">            sage: p.left_right_inverse() #indirect doctest</span>
<span class="sd">            a a b b</span>
<span class="sd">            c c</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">interval</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_reversed_twin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverses the twin of the permutation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b b&#39;,&#39;c c a&#39;,reduced=True)</span>
<span class="sd">            sage: p.top_bottom_inverse() #indirect doctest</span>
<span class="sd">            a a b</span>
<span class="sd">            b c c</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;,reduced=True)</span>
<span class="sd">            sage: p.top_bottom_inverse() #indirect doctest</span>
<span class="sd">            a a</span>
<span class="sd">            b b c c</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]]</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">interval</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">interval</span><span class="p">,</span>
                    <span class="n">n</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">position</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="k">def</span> <span class="nf">_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">interval_to</span><span class="p">,</span> <span class="n">position_to</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        _move the element at (interval,position) to (interval_to, position_to)</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``interval`` - 0 or 1</span>

<span class="sd">        - ``position`` - a position in the corresponding interval</span>

<span class="sd">        - ``interval_to`` - 0 or 1</span>

<span class="sd">        - ``position_to`` - a position in the corresponding interval</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c c&#39;,&#39;d b d a&#39;,flips=&#39;a&#39;)</span>
<span class="sd">            sage: p._move(0,0,0,2)</span>
<span class="sd">            sage: p</span>
<span class="sd">             b -a  c  c</span>
<span class="sd">             d  b  d -a</span>
<span class="sd">            sage: p._move(0,1,0,0)</span>
<span class="sd">            sage: p</span>
<span class="sd">            -a  b  c  c</span>
<span class="sd">             d  b  d -a</span>
<span class="sd">            sage: p._move(1,1,1,4)</span>
<span class="sd">            sage: p</span>
<span class="sd">            -a  b  c  c</span>
<span class="sd">             d  d -a  b</span>
<span class="sd">            sage: p._move(1,3,1,1)</span>
<span class="sd">            sage: p</span>
<span class="sd">            -a  b  c  c</span>
<span class="sd">             d  b  d -a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">!=</span> <span class="n">interval_to</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval_to</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                        <span class="n">position_to</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">interval_to</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">position_to</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

            <span class="n">elti</span><span class="p">,</span><span class="n">eltp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">position</span><span class="p">]</span> <span class="c1"># the element to move</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval_to</span><span class="p">][</span><span class="n">position_to</span><span class="p">:]</span> <span class="c1"># interval to shift</span>
            <span class="n">k2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">position</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># interval to unshift</span>

            <span class="c1"># increment the twin after the position_to</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">tw</span><span class="p">,</span><span class="n">pos</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">tw</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval_to</span><span class="p">,</span> <span class="n">position_to</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># decrement the twin after the position</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">tw</span><span class="p">,</span><span class="n">pos</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">tw</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">position</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>

            <span class="c1"># modify twin of the moved interval</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">elti</span><span class="p">][</span><span class="n">eltp</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval_to</span><span class="p">,</span> <span class="n">position_to</span><span class="p">)</span>

            <span class="c1"># move</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval_to</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">position_to</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># interval == interval_to (just one operation !)</span>
            <span class="k">if</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="n">position_to</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                            <span class="n">position_to</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                            <span class="n">position_to</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

                <span class="n">elti</span><span class="p">,</span> <span class="n">eltp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">position</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">position</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">position_to</span><span class="p">]</span>

                <span class="c1"># decrement the twin between position and position to</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">tw</span><span class="p">,</span><span class="n">pos</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">tw</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span><span class="n">position</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>

                <span class="c1"># modify twin of the moved element</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">elti</span><span class="p">][</span><span class="n">eltp</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval_to</span><span class="p">,</span> <span class="n">position_to</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># move</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                        <span class="n">position_to</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">position_to</span> <span class="o">&lt;</span> <span class="n">position</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                            <span class="n">position_to</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                            <span class="n">position_to</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

                <span class="n">elti</span><span class="p">,</span> <span class="n">eltp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">position</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">][</span><span class="n">position_to</span><span class="p">:</span><span class="n">position</span><span class="p">]</span>

                <span class="c1"># increment the twin between position and position to</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">tw</span><span class="p">,</span><span class="n">pos</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">tw</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span><span class="n">position_to</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># modify twin of the moved element</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">elti</span><span class="p">][</span><span class="n">eltp</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval_to</span><span class="p">,</span><span class="n">position_to</span><span class="p">)</span>

                <span class="c1"># move</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                        <span class="n">position_to</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_set_twin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>

<div class="viewcode-block" id="PermutationLI.twin">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.twin">[docs]</a>
    <span class="k">def</span> <span class="nf">twin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the twin of the letter in interval ``i`` at position ``pos``</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b c&#39;, &#39;c e b e&#39;)</span>
<span class="sd">            sage: p.twin(0,0)</span>
<span class="sd">            (0, 1)</span>
<span class="sd">            sage: p.twin(0,1)</span>
<span class="sd">            (0, 0)</span>

<span class="sd">            sage: twin_top = [p.twin(0,i) for i in range(p.length_top())]</span>
<span class="sd">            sage: twin_bot = [p.twin(1,i) for i in range(p.length_bottom())]</span>
<span class="sd">            sage: p.twin_list() == [twin_top, twin_bot]</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span></div>


<div class="viewcode-block" id="PermutationLI.twin_list">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.twin_list">[docs]</a>
    <span class="k">def</span> <span class="nf">twin_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the twin list of self.</span>

<span class="sd">        The twin list is the involution without fixed point which defines it. As the</span>
<span class="sd">        domain is naturally split into two lines we use a 2-tuple (i,j) to</span>
<span class="sd">        specify the element at position j in line i.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;)</span>
<span class="sd">            sage: p.twin_list()[0]</span>
<span class="sd">            [(0, 1), (0, 0), (1, 0)]</span>
<span class="sd">            sage: p.twin_list()[1]</span>
<span class="sd">            [(0, 2), (1, 2), (1, 1)]</span>

<span class="sd">        And we may check that it is actually an involution without fixed point::</span>

<span class="sd">            sage: t = p.twin_list()</span>
<span class="sd">            sage: all(t[i][j] != (i,j) for i in range(2) for j in range(len(t[i])))</span>
<span class="sd">            True</span>
<span class="sd">            sage: all(t[t[i][j][0]][t[i][j][1]] == (i,j) for i in range(2) for j in range(len(t[i])))</span>
<span class="sd">            True</span>

<span class="sd">        A slightly more complicated example::</span>

<span class="sd">            sage: q = iet.GeneralizedPermutation(&#39;a b c a&#39;,&#39;d e f e g c b g d f&#39;)</span>
<span class="sd">            sage: q.twin_list()[0]</span>
<span class="sd">            [(0, 3), (1, 6), (1, 5), (0, 0)]</span>
<span class="sd">            sage: q.twin_list()[1]</span>
<span class="sd">            [(1, 8), (1, 3), (1, 9), (1, 1), (1, 7), (0, 2), (0, 1), (1, 4), (1, 0), (1, 2)]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: t = q.twin_list()</span>
<span class="sd">            sage: all(t[t[i][j][0]][t[i][j][1]] == (i,j) for i in range(2) for j in range(len(t[i])))</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][:],</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]]</span></div>


<div class="viewcode-block" id="PermutationLI.is_irreducible">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.is_irreducible">[docs]</a>
    <span class="k">def</span> <span class="nf">is_irreducible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_decomposition</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test of reducibility</span>

<span class="sd">        A quadratic (or generalized) permutation is *reducible* if there exists</span>
<span class="sd">        a decomposition</span>

<span class="sd">        .. math::</span>

<span class="sd">           A1 u B1 | ... | B1 u A2</span>

<span class="sd">           A1 u B2 | ... | B2 u A2</span>

<span class="sd">        where no corners is empty, or exactly one corner is empty</span>
<span class="sd">        and it is on the left, or two and they are both on the</span>
<span class="sd">        right or on the left. The definition is due to [BoiLan09]_ where they prove</span>
<span class="sd">        that the property of being irreducible is stable under Rauzy induction.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        -  ``return_decomposition`` - boolean (default: False) - if True, and</span>
<span class="sd">           the permutation is reducible, returns also the blocks A1 u B1, B1 u</span>
<span class="sd">           A2, A1 u B2 and B2 u A2 of a decomposition as above.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        If return_decomposition is True, returns a 2-uple</span>
<span class="sd">        (test,decomposition) where test is the preceding test and</span>
<span class="sd">        decomposition is a 4-uple (A11,A12,A21,A22) where:</span>

<span class="sd">        A11 = A1 u B1</span>
<span class="sd">        A12 = B1 u A2</span>
<span class="sd">        A21 = A1 u B2</span>
<span class="sd">        A22 = B2 u A2</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: GP = iet.GeneralizedPermutation</span>

<span class="sd">            sage: GP(&#39;a a&#39;,&#39;b b&#39;).is_irreducible()</span>
<span class="sd">            False</span>
<span class="sd">            sage: GP(&#39;a a b&#39;,&#39;b c c&#39;).is_irreducible()</span>
<span class="sd">            True</span>
<span class="sd">            sage: GP(&#39;1 2 3 4 5 1&#39;,&#39;5 6 6 4 3 2&#39;).is_irreducible()</span>
<span class="sd">            True</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        Test reducible permutations with no empty corner::</span>

<span class="sd">            sage: GP(&#39;1 4 1 3&#39;,&#39;4 2 3 2&#39;).is_irreducible(True)</span>
<span class="sd">            (False, ([&#39;1&#39;, &#39;4&#39;], [&#39;1&#39;, &#39;3&#39;], [&#39;4&#39;, &#39;2&#39;], [&#39;3&#39;, &#39;2&#39;]))</span>

<span class="sd">        Test reducible permutations with one left corner empty::</span>

<span class="sd">            sage: GP(&#39;1 2 2 3 1&#39;,&#39;4 4 3&#39;).is_irreducible(True)</span>
<span class="sd">            (False, ([&#39;1&#39;], [&#39;3&#39;, &#39;1&#39;], [], [&#39;3&#39;]))</span>
<span class="sd">            sage: GP(&#39;4 4 3&#39;,&#39;1 2 2 3 1&#39;).is_irreducible(True)</span>
<span class="sd">            (False, ([], [&#39;3&#39;], [&#39;1&#39;], [&#39;3&#39;, &#39;1&#39;]))</span>

<span class="sd">        Test reducible permutations with two left corner empty::</span>

<span class="sd">            sage: GP(&#39;1 1 2 3&#39;,&#39;4 2 4 3&#39;).is_irreducible(True)</span>
<span class="sd">            (False, ([], [&#39;3&#39;], [], [&#39;3&#39;]))</span>

<span class="sd">        Test reducible permutations with two right corner empty::</span>

<span class="sd">            sage: GP(&#39;1 2 2 3 3&#39;,&#39;1 4 4&#39;).is_irreducible(True)</span>
<span class="sd">            (False, ([&#39;1&#39;], [], [&#39;1&#39;], []))</span>
<span class="sd">            sage: GP(&#39;1 2 2&#39;,&#39;1 3 3&#39;).is_irreducible(True)</span>
<span class="sd">            (False, ([&#39;1&#39;], [], [&#39;1&#39;], []))</span>
<span class="sd">            sage: GP(&#39;1 2 3 3&#39;,&#39;2 1 4 4 5 5&#39;).is_irreducible(True)</span>
<span class="sd">            (False, ([&#39;1&#39;, &#39;2&#39;], [], [&#39;2&#39;, &#39;1&#39;], []))</span>

<span class="sd">        A ``NotImplementedError`` is raised when there are flips::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c e b&#39;,&#39;d c d a e&#39;, flips=&#39;abcd&#39;, reduced=True)</span>
<span class="sd">            sage: p.is_irreducible()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: irreducibility test not implemented for generalized permutations with flips</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c e b&#39;,&#39;d c d a e&#39;, flips=&#39;abcd&#39;, reduced=False)</span>
<span class="sd">            sage: p.is_irreducible()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: irreducibility test not implemented for generalized permutations with flips</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;irreducibility test not implemented for generalized permutations with flips&#39;</span><span class="p">)</span>

        <span class="n">l0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_top</span><span class="p">()</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_bottom</span><span class="p">()</span>
        <span class="n">s0</span><span class="p">,</span><span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>

        <span class="c1"># testing two corners empty on the right (i12 = i22 = 0)</span>
        <span class="n">A11</span><span class="p">,</span> <span class="n">A21</span><span class="p">,</span> <span class="n">A12</span><span class="p">,</span> <span class="n">A22</span> <span class="o">=</span> <span class="p">[],[],[],[]</span>

        <span class="k">for</span> <span class="n">i11</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s0</span><span class="p">[</span><span class="n">i11</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A11</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">A11</span> <span class="o">=</span> <span class="n">s0</span><span class="p">[:</span><span class="n">i11</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i21</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">i21</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A21</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">A21</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[:</span><span class="n">i21</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">A11</span><span class="p">)</span>  <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">A21</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">return_decomposition</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span><span class="p">,(</span><span class="n">A11</span><span class="p">,</span><span class="n">A12</span><span class="p">,</span><span class="n">A21</span><span class="p">,</span><span class="n">A22</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="n">A21</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># testing no corner empty but one or two on the left</span>
        <span class="n">t11</span> <span class="o">=</span> <span class="n">t21</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">A11</span><span class="p">,</span> <span class="n">A12</span><span class="p">,</span> <span class="n">A21</span><span class="p">,</span> <span class="n">A22</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i11</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i11</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s0</span><span class="p">[</span><span class="n">i11</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A11</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">A11</span> <span class="o">=</span> <span class="n">s0</span><span class="p">[:</span><span class="n">i11</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i21</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l1</span><span class="p">)</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">i21</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s1</span><span class="p">[</span><span class="n">i21</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A21</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">A21</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[:</span><span class="n">i21</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">i12</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i11</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="n">s0</span><span class="p">[</span><span class="n">i12</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A12</span> <span class="ow">or</span> <span class="n">s0</span><span class="p">[</span><span class="n">i12</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A21</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">A12</span> <span class="o">=</span> <span class="n">s0</span><span class="p">[</span><span class="n">i12</span><span class="p">:]</span>

                    <span class="k">for</span> <span class="n">i22</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i21</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span>
                        <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">i22</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A22</span> <span class="ow">or</span> <span class="n">s1</span><span class="p">[</span><span class="n">i22</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A11</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">A22</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">i22</span><span class="p">:]</span>

                        <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">A11</span> <span class="o">+</span> <span class="n">A22</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">A12</span> <span class="o">+</span> <span class="n">A21</span><span class="p">)</span> <span class="p">:</span>
                            <span class="k">if</span> <span class="n">return_decomposition</span> <span class="p">:</span>
                                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="n">A11</span><span class="p">,</span><span class="n">A12</span><span class="p">,</span><span class="n">A21</span><span class="p">,</span><span class="n">A22</span><span class="p">)</span>
                            <span class="k">return</span> <span class="kc">False</span>
                    <span class="n">A22</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">A12</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">A21</span> <span class="o">=</span> <span class="p">[]</span>


        <span class="k">if</span> <span class="n">return_decomposition</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="PermutationLI.to_cylindric">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.to_cylindric">[docs]</a>
    <span class="k">def</span> <span class="nf">to_cylindric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a cylindric permutation in the same extended Rauzy class</span>

<span class="sd">        A generalized permutation is *cylindric* if the first letter in the top</span>
<span class="sd">        interval is the same as the last letter in the bottom interval or if the</span>
<span class="sd">        laster letter of the top interval is the same as the fist letter of the</span>
<span class="sd">        bottom interval.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import iet</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b d a c&#39;,&#39;c e b e d&#39;)</span>
<span class="sd">            sage: p.is_irreducible()</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.to_cylindric().is_cylindric()</span>
<span class="sd">            True</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation([0,1,2,1,2,3,4,5,6], [6,0,5,4,7,3,7], reduced=True)</span>
<span class="sd">            sage: p.to_cylindric()</span>
<span class="sd">            0 1 2 1 2 3 4 5 6</span>
<span class="sd">            6 0 5 4 7 3 7</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation([[0,1,1],[2,2,0]], reduced=True)</span>
<span class="sd">            sage: p.to_cylindric()</span>
<span class="sd">            0 1 1</span>
<span class="sd">            2 2 0</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        The algorithm is naive. It computes the extended Rauzy class until it</span>
<span class="sd">        finds a cylindric permutation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cylindric</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">wait</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">rauzy_class</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">wait</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">wait</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">has_rauzy_move</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">):</span> <span class="c1"># top rauzy move</span>
                <span class="n">qq</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">rauzy_move</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">qq</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rauzy_class</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">qq</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">qq</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">qq</span>
                    <span class="n">wait</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qq</span><span class="p">)</span>
                    <span class="n">rauzy_class</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">qq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">has_rauzy_move</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="c1"># bot rauzy move</span>
                <span class="n">qq</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">rauzy_move</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">qq</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rauzy_class</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">qq</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">qq</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">qq</span>
                    <span class="n">wait</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qq</span><span class="p">)</span>
                    <span class="n">rauzy_class</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">qq</span><span class="p">)</span>
            <span class="n">qq</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">symmetric</span><span class="p">()</span> <span class="c1"># symmetric</span>
            <span class="k">if</span> <span class="n">qq</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rauzy_class</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">qq</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">qq</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">qq</span>
                <span class="n">wait</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qq</span><span class="p">)</span>
                <span class="n">rauzy_class</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">qq</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;no cylindric permutation in the extended Rauzy class&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PermutationLI.is_cylindric">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.is_cylindric">[docs]</a>
    <span class="k">def</span> <span class="nf">is_cylindric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if the permutation is cylindric</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: q = iet.GeneralizedPermutation(&#39;a b b&#39;,&#39;c c a&#39;)</span>
<span class="sd">            sage: q.is_cylindric()</span>
<span class="sd">            True</span>
<span class="sd">            sage: q = iet.GeneralizedPermutation(&#39;a a b b&#39;,&#39;c c&#39;)</span>
<span class="sd">            sage: q.is_cylindric()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="PermutationLI.profile">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.profile">[docs]</a>
    <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the ``profile`` of self.</span>

<span class="sd">        The *profile* of a generalized permutation is the list `(d_1, \ldots,</span>
<span class="sd">        d_k)` where `(d_1 \pi, \ldots, d_k \pi)` is the list of angles of any</span>
<span class="sd">        suspension of that generalized permutation.</span>

<span class="sd">        See also :meth:`marked_profile`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p1 = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;)</span>
<span class="sd">            sage: p1.profile()</span>
<span class="sd">            [1, 1, 1, 1]</span>
<span class="sd">            sage: all(p.profile() == [1, 1, 1, 1] for p in p1.rauzy_diagram())</span>
<span class="sd">            True</span>

<span class="sd">            sage: p2 = iet.GeneralizedPermutation(&#39;0 1 2 1 3&#39;,&#39;4 3 4 2 0&#39;)</span>
<span class="sd">            sage: p2.profile()</span>
<span class="sd">            [4, 4]</span>
<span class="sd">            sage: all(p.profile() == [4,4] for p in p2.rauzy_diagram())</span>
<span class="sd">            True</span>

<span class="sd">            sage: p3 = iet.GeneralizedPermutation(&#39;0 1 2 3 3&#39;,&#39;2 1 4 4 0&#39;)</span>
<span class="sd">            sage: p3.profile()</span>
<span class="sd">            [3, 3, 1, 1]</span>
<span class="sd">            sage: all(p.profile() == [3, 3, 1, 1] for p in p3.rauzy_diagram())</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.combinat.partition</span> <span class="kn">import</span> <span class="n">Partition</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_diagram</span><span class="p">(</span><span class="n">sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">glue_ends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Partition</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">),</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="PermutationLI.genus">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.genus">[docs]</a>
    <span class="k">def</span> <span class="nf">genus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the genus of any suspension of self.</span>

<span class="sd">        The genus `g` can be deduced from the profile (see :meth:`profile`)</span>
<span class="sd">        `p=(p_1,\ldots,p_k)` of self by the formula:</span>
<span class="sd">        `4g-4 = \sum_{i=1}^k (p_i - 2)`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;).genus()</span>
<span class="sd">            0</span>
<span class="sd">            sage: iet.GeneralizedPermutation((0,1,2,1,3),(4,3,4,2,0)).genus()</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">//</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="PermutationLI.marking">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.marking">[docs]</a>
    <span class="k">def</span> <span class="nf">marking</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the marking induced by the two sides of the interval</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;0 1 2 3 4 3 5 6 7&#39;,&#39;1 6 8 4 2 7 5 8 0&#39;)</span>
<span class="sd">            sage: p.marking()</span>
<span class="sd">            8|7</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;0 1 2 3 4 3 5 6 7&#39;,&#39;1 6 8 4 2 7 8 0 5&#39;)</span>
<span class="sd">            sage: p.marking()</span>
<span class="sd">            8o8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">marked_profile</span><span class="p">()</span><span class="o">.</span><span class="n">marking</span><span class="p">()</span></div>


<div class="viewcode-block" id="PermutationLI.marked_profile">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.marked_profile">[docs]</a>
    <span class="k">def</span> <span class="nf">marked_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the marked profile of self.</span>

<span class="sd">        The *marked profile* of a generalized permutation is an integer</span>
<span class="sd">        partition and some additional data associated to the angles of conical</span>
<span class="sd">        singularities in the suspension. The partition, called the</span>
<span class="sd">        *profile*, is the list of angles divided by `2\pi` (see</span>
<span class="sd">        :meth:`profile`). The additional is called the *marking* and may be of</span>
<span class="sd">        two different types.</span>

<span class="sd">        If the left endpoint and the right endpoint of the interval associated</span>
<span class="sd">        to the permutation coincides, then the marking is of *type 1* and the</span>
<span class="sd">        additional data consists of a couple `(m,a)` such that `m` is the</span>
<span class="sd">        angle of the conical singularity and `a` is the angle between the</span>
<span class="sd">        outgoing separatrix associated to the left endpoint and the incoming</span>
<span class="sd">        separatrix associated to the right endpoint. A marking of type one is</span>
<span class="sd">        denoted `m | a`.</span>

<span class="sd">        If the left endpoint and the right endpoint are two different conical</span>
<span class="sd">        singularities in the suspension, then the marking is of *type 2* and the</span>
<span class="sd">        data consists in a couple `(m_l,m_r)` where `m_l` (resp. `m_r`) is</span>
<span class="sd">        the conical angle of the singularity at the left endpoint (resp. right</span>
<span class="sd">        endpoint). A marking of type two is denoted `m_l \circ m_r`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        All possible markings for the profile [1, 1, 1, 1]::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;)</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            1o1 [1, 1, 1, 1]</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;)</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            1|0 [1, 1, 1, 1]</span>

<span class="sd">        All possible markings for the profile [4, 4]::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;0 1 2 1 3&#39;,&#39;3 4 0 4 2&#39;)</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            4o4 [4, 4]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;0 1 2 1 3&#39;,&#39;4 3 2 0 4&#39;)</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            4|0 [4, 4]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;0 1 0 2 3 2&#39;,&#39;4 3 4 1&#39;)</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            4|1 [4, 4]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;0 1 2 3 2&#39;,&#39;4 3 4 1 0&#39;)</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            4|2 [4, 4]</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;0 1 0 1&#39;,&#39;2 3 2 4 3 4&#39;)</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            4|3 [4, 4]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;not available on permutations with flips&#39;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">.marked_partition</span> <span class="kn">import</span> <span class="n">MarkedPartition</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MarkedPartition</span><span class="p">([],</span><span class="mi">2</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_diagram</span><span class="p">(</span><span class="n">glue_ends</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">signs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canonical_signs</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">),</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">left1</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">signs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">signs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">left2</span> <span class="o">=</span> <span class="p">(</span><span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">right1</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">signs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">signs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">right2</span> <span class="o">=</span> <span class="p">(</span><span class="n">right1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">right1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">left1</span><span class="o">+</span><span class="n">right1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">right1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">lr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">right1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">lr2</span> <span class="o">=</span> <span class="p">(</span><span class="n">right1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">right1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">lr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">lr2</span> <span class="o">=</span> <span class="p">(</span><span class="n">right1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">right1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">lr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">right1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">lr2</span> <span class="o">=</span> <span class="p">(</span><span class="n">right1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">right1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">lr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">right1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">lr2</span> <span class="o">=</span> <span class="p">(</span><span class="n">right1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">left1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lr1</span> <span class="ow">in</span> <span class="n">c</span> <span class="ow">or</span> <span class="n">lr2</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">return</span> <span class="n">MarkedPartition</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_left</span> <span class="o">=</span> <span class="n">c_right</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">left1</span> <span class="ow">in</span> <span class="n">c</span> <span class="ow">or</span> <span class="n">left2</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span> <span class="n">c_left</span> <span class="o">=</span> <span class="n">c</span>
                <span class="k">if</span> <span class="n">right1</span> <span class="ow">in</span> <span class="n">c</span> <span class="ow">or</span> <span class="n">right2</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span> <span class="n">c_right</span> <span class="o">=</span> <span class="n">c</span>

        <span class="k">if</span> <span class="n">c_left</span> <span class="o">==</span> <span class="n">c_right</span><span class="p">:</span>
            <span class="n">mm</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">right1</span> <span class="ow">in</span> <span class="n">c_right</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">c_right</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">right1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">c_right</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">right2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">left1</span> <span class="ow">in</span> <span class="n">c_left</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">c_left</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">left1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">c_left</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">left2</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">)</span><span class="o">%</span><span class="n">mm</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">MarkedPartition</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">m_l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_left</span><span class="p">)</span>
            <span class="n">m_r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">MarkedPartition</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">m_l</span><span class="p">,</span><span class="n">m_r</span><span class="p">))</span></div>


<div class="viewcode-block" id="PermutationLI.erase_marked_points">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.erase_marked_points">[docs]</a>
    <span class="k">def</span> <span class="nf">erase_marked_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a permutation without marked points.</span>

<span class="sd">        This method is not implemented for generalized permutations.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;)</span>
<span class="sd">            sage: p.stratum()</span>
<span class="sd">            Q_0(-1^4)</span>
<span class="sd">            sage: p.erase_marked_points()</span>
<span class="sd">            a a b</span>
<span class="sd">            b c c</span>
<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a d d a b&#39;,&#39;b c c&#39;)</span>
<span class="sd">            sage: p.stratum()</span>
<span class="sd">            Q_0(0, -1^4)</span>
<span class="sd">            sage: p.erase_marked_points()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError: not yet implemented! Do it!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span><span class="o">.</span><span class="n">nb_fake_zeros</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;not yet implemented! Do it!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="PermutationLI.is_hyperelliptic">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.is_hyperelliptic">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hyperelliptic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if this permutation is in an hyperelliptic connected component.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        An example of hyperelliptic permutation::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation([0,1,2,0,6,5,3,1,2,3],[4,5,6,4])</span>
<span class="sd">            sage: p.is_hyperelliptic()</span>
<span class="sd">            True</span>

<span class="sd">        Check for the correspondence::</span>

<span class="sd">            sage: q = QuadraticStratum(6,6)</span>
<span class="sd">            sage: c_hyp, c_reg, c_irr = q.components()</span>

<span class="sd">            sage: p_hyp = c_hyp.permutation_representative()</span>
<span class="sd">            sage: p_hyp</span>
<span class="sd">            0 1 2 3 4 1 5 6 7</span>
<span class="sd">            7 6 5 8 4 3 2 8 0</span>
<span class="sd">            sage: p_hyp.is_hyperelliptic()</span>
<span class="sd">            True</span>

<span class="sd">            sage: p_reg = c_reg.permutation_representative()</span>
<span class="sd">            sage: p_reg</span>
<span class="sd">            0 1 2 3 4 5 2 6 7 5</span>
<span class="sd">            1 4 6 8 7 8 3 0</span>
<span class="sd">            sage: p_reg.is_hyperelliptic()</span>
<span class="sd">            False</span>

<span class="sd">            sage: p_irr = c_irr.permutation_representative()</span>
<span class="sd">            sage: p_irr</span>
<span class="sd">            0 1 2 3 4 3 5 6 7</span>
<span class="sd">            1 6 8 4 2 7 5 8 0</span>
<span class="sd">            sage: p_irr.is_hyperelliptic()</span>
<span class="sd">            False</span>

<span class="sd">            sage: q = QuadraticStratum(3,3,2)</span>
<span class="sd">            sage: c_hyp, c_non_hyp = q.components()</span>
<span class="sd">            sage: p_hyp = c_hyp.permutation_representative()</span>
<span class="sd">            sage: p_hyp.is_hyperelliptic()</span>
<span class="sd">            True</span>
<span class="sd">            sage: p_non_hyp = c_non_hyp.permutation_representative()</span>
<span class="sd">            sage: p_non_hyp.is_hyperelliptic()</span>
<span class="sd">            False</span>
<span class="sd">            sage: q = QuadraticStratum(5,5,2)</span>
<span class="sd">            sage: c_hyp, c_non_hyp = q.components()</span>
<span class="sd">            sage: p_hyp = c_hyp.permutation_representative()</span>
<span class="sd">            sage: p_hyp.is_hyperelliptic()</span>
<span class="sd">            True</span>
<span class="sd">            sage: p_non_hyp = c_non_hyp.permutation_representative()</span>
<span class="sd">            sage: p_non_hyp.is_hyperelliptic()</span>
<span class="sd">            False</span>
<span class="sd">            sage: q = QuadraticStratum(3,3,1,1)</span>
<span class="sd">            sage: c_hyp, c_non_hyp = q.components()</span>
<span class="sd">            sage: p_hyp = c_hyp.permutation_representative()</span>
<span class="sd">            sage: p_hyp.is_hyperelliptic()</span>
<span class="sd">            True</span>
<span class="sd">            sage: p_non_hyp = c_non_hyp.permutation_representative()</span>
<span class="sd">            sage: p_non_hyp.is_hyperelliptic()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">erase_marked_points</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">has_hyperelliptic_component</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">to_cylindric</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">l0</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">q0</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">q1</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">l0</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">l0</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">l1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">l1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l0</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">q0</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">q1</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">l0</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">l0</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">q</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">l1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">l1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;found Jenkins-Strebel&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;potential form 1&quot;</span><span class="p">)</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l0</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">l0</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">i1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no repetition twice in intervals&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">q0_0</span> <span class="o">=</span> <span class="n">q0</span><span class="p">[</span><span class="n">i0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i0</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">q0_1</span> <span class="o">=</span> <span class="n">q0</span><span class="p">[</span><span class="n">i0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">q0</span><span class="p">[:</span><span class="n">i0</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">q0_0</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">q0_1</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

            <span class="n">q1_0</span> <span class="o">=</span> <span class="n">q1</span><span class="p">[</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">q1_1</span> <span class="o">=</span> <span class="n">q1</span><span class="p">[</span><span class="n">i1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">q1</span><span class="p">[:</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">q0_0</span><span class="p">,</span> <span class="n">q0_1</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">q1_0</span><span class="p">,</span> <span class="n">q1_1</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">q0_0</span> <span class="o">==</span> <span class="n">q1_0</span> <span class="ow">and</span> <span class="n">q0_1</span> <span class="o">==</span> <span class="n">q1_1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">q0_0</span> <span class="o">==</span> <span class="n">q1_1</span> <span class="ow">and</span> <span class="n">q0_1</span> <span class="o">==</span> <span class="n">q1_0</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;potential form 2&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">l0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">l1</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">l0</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="PermutationLI.stratum_component">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.stratum_component">[docs]</a>
    <span class="k">def</span> <span class="nf">stratum_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the connected component of stratum in which self belongs to.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b b&#39;,&#39;c c a&#39;)</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_0(-1^4)^c</span>

<span class="sd">        Test the exceptional strata in genus 3::</span>

<span class="sd">            sage: Q = QuadraticStratum(9,-1)</span>
<span class="sd">            sage: p = Q.regular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_3(9, -1)^reg</span>
<span class="sd">            sage: p = Q.irregular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_3(9, -1)^irr</span>

<span class="sd">            sage: Q = QuadraticStratum(6,3,-1)</span>
<span class="sd">            sage: p = Q.regular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_3(6, 3, -1)^reg</span>
<span class="sd">            sage: p = Q.irregular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_3(6, 3, -1)^irr</span>

<span class="sd">            sage: Q = QuadraticStratum(3,3,3,-1)</span>
<span class="sd">            sage: p = Q.regular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_3(3^3, -1)^reg</span>
<span class="sd">            sage: p = Q.irregular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_3(3^3, -1)^irr</span>

<span class="sd">        Test the exceptional strata in genus 4::</span>

<span class="sd">            sage: Q = QuadraticStratum(12)</span>
<span class="sd">            sage: p = Q.regular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(12)^reg</span>
<span class="sd">            sage: p = Q.irregular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(12)^irr</span>

<span class="sd">            sage: Q = QuadraticStratum(9,3)</span>
<span class="sd">            sage: p = Q.regular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(9, 3)^reg</span>
<span class="sd">            sage: p = Q.irregular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(9, 3)^irr</span>

<span class="sd">            sage: Q = QuadraticStratum(6,6)</span>
<span class="sd">            sage: p = Q.hyperelliptic_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(6^2)^hyp</span>
<span class="sd">            sage: p = Q.regular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(6^2)^reg</span>
<span class="sd">            sage: p = Q.irregular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(6^2)^irr</span>

<span class="sd">            sage: Q = QuadraticStratum(6,3,3)</span>
<span class="sd">            sage: p = Q.regular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(6, 3^2)^reg</span>
<span class="sd">            sage: p = Q.irregular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(6, 3^2)^irr</span>

<span class="sd">            sage: Q = QuadraticStratum(3,3,3,3)</span>
<span class="sd">            sage: p = Q.hyperelliptic_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(3^4)^hyp</span>
<span class="sd">            sage: p = Q.regular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(3^4)^reg</span>
<span class="sd">            sage: p = Q.irregular_component().permutation_representative()</span>
<span class="sd">            sage: p.stratum_component()</span>
<span class="sd">            Q_4(3^4)^irr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stratum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">components</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># connected</span>
            <span class="k">return</span> <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">stratum</span><span class="o">.</span><span class="n">has_hyperelliptic_component</span><span class="p">():</span> <span class="c1"># hyp / nonhyp</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hyperelliptic</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">stratum</span><span class="o">.</span><span class="n">hyperelliptic_component</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">stratum</span><span class="o">.</span><span class="n">non_hyperelliptic_component</span><span class="p">()</span>

        <span class="c1"># reg / irr</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.databases.flat_surfaces</span> <span class="kn">import</span> <span class="n">IrregularComponentTwins</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">IrregularComponentTwins</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">list_strata</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;database of irregular twins not available&quot;</span><span class="p">)</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">erase_marked_points</span><span class="p">()</span><span class="o">.</span><span class="n">to_cylindric</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cylindric_canonical</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">stratum</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">stratum</span><span class="o">.</span><span class="n">irregular_component</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">stratum</span><span class="o">.</span><span class="n">regular_component</span><span class="p">()</span></div>


<div class="viewcode-block" id="PermutationLI.has_rauzy_move">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.has_rauzy_move">[docs]</a>
    <span class="k">def</span> <span class="nf">has_rauzy_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test of Rauzy movability (with an eventual specified choice of winner)</span>

<span class="sd">        A quadratic (or generalized) permutation is rauzy_movable type</span>
<span class="sd">        depending on the possible length of the last interval. It&#39;s</span>
<span class="sd">        dependent of the length equation.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``winner`` - the integer &#39;top&#39; or &#39;bottom&#39;</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b&#39;)</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;top&#39;,&#39;right&#39;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;top&#39;,&#39;left&#39;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;bottom&#39;,&#39;right&#39;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;bottom&#39;,&#39;left&#39;)</span>
<span class="sd">            False</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;)</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;top&#39;,&#39;right&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;bottom&#39;,&#39;right&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;top&#39;,&#39;left&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;bottom&#39;,&#39;left&#39;)</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;)</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;top&#39;,&#39;right&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;bottom&#39;,&#39;right&#39;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;top&#39;,&#39;left&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;bottom&#39;,&#39;left&#39;)</span>
<span class="sd">            False</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b b&#39;,&#39;c c&#39;)</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;top&#39;,&#39;right&#39;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;bottom&#39;,&#39;right&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;top&#39;,&#39;left&#39;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: p.has_rauzy_move(&#39;bottom&#39;,&#39;left&#39;)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>

        <span class="n">loser</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">winner</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># the same letter at the right-end (False)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_bottom</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># winner or loser letter is repeated on the other interval (True)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># the loser letter is the only letter repeated in</span>
            <span class="c1"># the loser interval (False)</span>
            <span class="k">if</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">]]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">loser</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># the same letter at the left-end (False)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># winner or loser repeated on the other interval (True)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># the loser letter is the only letter repeated in</span>
            <span class="c1"># the loser interval (False)</span>
            <span class="k">if</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">]]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">loser</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="PermutationLI.orientation_cover">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.PermutationLI.orientation_cover">[docs]</a>
    <span class="k">def</span> <span class="nf">orientation_cover</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the orientation cover of this permutation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;, &#39;b c c&#39;)</span>
<span class="sd">            sage: c = p.orientation_cover()</span>
<span class="sd">            sage: c</span>
<span class="sd">            Covering of degree 2 of the permutation:</span>
<span class="sd">            a a b</span>
<span class="sd">            b c c</span>
<span class="sd">            sage: c.stratum()</span>
<span class="sd">            H_1(0^4)</span>

<span class="sd">            sage: C = QuadraticStratum(3,2,2,1).unique_component()</span>
<span class="sd">            sage: p = C.permutation_representative()</span>
<span class="sd">            sage: c = p.orientation_cover()</span>
<span class="sd">            sage: c.stratum()</span>
<span class="sd">            H_6(4, 2, 1^4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alphabet</span><span class="p">()</span><span class="o">.</span><span class="n">rank</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">inv_letters</span> <span class="o">=</span> <span class="n">p0</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">permut_cover</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inv_letters</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">permut_cover</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="OrientablePermutationIET">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET">[docs]</a>
<span class="k">class</span> <span class="nc">OrientablePermutationIET</span><span class="p">(</span><span class="n">PermutationIET</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Template for permutation of Interval Exchange Transformation.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Internal class! Do not use directly!</span>

<span class="sd">    AUTHOR:</span>

<span class="sd">    - Vincent Delecroix (2008-12-20): initial version</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="OrientablePermutationIET.is_identity">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.is_identity">[docs]</a>
    <span class="k">def</span> <span class="nf">is_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if self is the identity.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.Permutation(&quot;a b&quot;,&quot;a b&quot;,reduced=False).is_identity()</span>
<span class="sd">            True</span>
<span class="sd">            sage: iet.Permutation(&quot;a b&quot;,&quot;a b&quot;,reduced=True).is_identity()</span>
<span class="sd">            True</span>
<span class="sd">            sage: iet.Permutation(&quot;a b&quot;,&quot;b a&quot;,reduced=False).is_identity()</span>
<span class="sd">            False</span>
<span class="sd">            sage: iet.Permutation(&quot;a b&quot;,&quot;b a&quot;,reduced=True).is_identity()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span></div>


    <span class="c1">#TODO: change the name</span>
<div class="viewcode-block" id="OrientablePermutationIET.decompose">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.decompose">[docs]</a>
    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the decomposition as a concatenation of irreducible permutations.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        a list of permutations</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;).decompose()[0]</span>
<span class="sd">            sage: p</span>
<span class="sd">            a b c</span>
<span class="sd">            c b a</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p1,p2,p3 = iet.Permutation(&#39;a b c d e&#39;,&#39;b a c e d&#39;).decompose()</span>
<span class="sd">            sage: p1</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>
<span class="sd">            sage: p2</span>
<span class="sd">            c</span>
<span class="sd">            c</span>
<span class="sd">            sage: p3</span>
<span class="sd">            d e</span>
<span class="sd">            e d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">test</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_irreducible</span><span class="p">(</span><span class="n">return_decomposition</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">test</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="n">test</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">is_irreducible</span><span class="p">(</span><span class="n">return_decomposition</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>

        <span class="k">return</span> <span class="n">l</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.intersection_matrix">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.intersection_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">intersection_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the intersection matrix.</span>

<span class="sd">        This `d*d` antisymmetric matrix is given by the rule :</span>

<span class="sd">        .. math::</span>

<span class="sd">            m_{ij} = \begin{cases}</span>
<span class="sd">                1 &amp; \text{$i &lt; j$ and $\pi(i) &gt; \pi(j)$} \\</span>
<span class="sd">                -1 &amp; \text{$i &gt; j$ and $\pi(i) &lt; \pi(j)$} \\</span>
<span class="sd">                0 &amp; \text{else}</span>
<span class="sd">                \end{cases}</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a matrix</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d c b a&#39;)</span>
<span class="sd">            sage: p.intersection_matrix()</span>
<span class="sd">            [ 0  1  1  1]</span>
<span class="sd">            [-1  0  1  1]</span>
<span class="sd">            [-1 -1  0  1]</span>
<span class="sd">            [-1 -1 -1  0]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;1 2 3 4 5&#39;,&#39;5 3 2 4 1&#39;)</span>
<span class="sd">            sage: p.intersection_matrix()</span>
<span class="sd">            [ 0  1  1  1  1]</span>
<span class="sd">            [-1  0  1  0  1]</span>
<span class="sd">            [-1 -1  0  0  1]</span>
<span class="sd">            [-1  0  0  0  1]</span>
<span class="sd">            [-1 -1 -1 -1  0]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d c b a&#39;)</span>
<span class="sd">            sage: R = p.rauzy_diagram()</span>
<span class="sd">            sage: g = R.path(p, *&#39;tbt&#39;)</span>
<span class="sd">            sage: m = g.matrix()</span>
<span class="sd">            sage: q = g.end()</span>
<span class="sd">            sage: q.intersection_matrix() == m.transpose() * p.intersection_matrix() * m</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="n">ZZ</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_top</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># NOTE: because of the extended Rauzy inductions, the labels are just a subset of</span>
        <span class="c1"># {0, 1, ...} not necessarily the first n integers.</span>
        <span class="n">use_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                     <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> \
                     <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">use_labels</span> <span class="k">else</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
                <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">if</span> <span class="n">use_labels</span> <span class="k">else</span> <span class="n">j</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.attached_out_degree">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.attached_out_degree">[docs]</a>
    <span class="k">def</span> <span class="nf">attached_out_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the degree of the singularity at the left of the interval.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a positive integer</span>


<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p1 = iet.Permutation(&#39;a b c d e f g&#39;,&#39;d c g f e b a&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(&#39;a b c d e f g&#39;,&#39;e d c g f b a&#39;)</span>
<span class="sd">            sage: p1.attached_out_degree()</span>
<span class="sd">            3</span>
<span class="sd">            sage: p2.attached_out_degree()</span>
<span class="sd">            1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_corner</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_diagram</span><span class="p">(</span><span class="n">glue_ends</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left_corner</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.attached_in_degree">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.attached_in_degree">[docs]</a>
    <span class="k">def</span> <span class="nf">attached_in_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the degree of the singularity at the right of the interval.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a positive integer</span>


<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p1 = iet.Permutation(&#39;a b c d e f g&#39;,&#39;d c g f e b a&#39;)</span>
<span class="sd">            sage: p2 = iet.Permutation(&#39;a b c d e f g&#39;,&#39;e d c g f b a&#39;)</span>
<span class="sd">            sage: p1.attached_in_degree()</span>
<span class="sd">            1</span>
<span class="sd">            sage: p2.attached_in_degree()</span>
<span class="sd">            3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">right_corner</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_diagram</span><span class="p">(</span><span class="n">glue_ends</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">right_corner</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.profile">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.profile">[docs]</a>
    <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the profile of the permutation</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.Permutation(&#39;a b c d&#39;,&#39;d c b a&#39;).profile()</span>
<span class="sd">            [3]</span>
<span class="sd">            sage: iet.Permutation(&#39;a b c d e&#39;,&#39;e d c b a&#39;).profile()</span>
<span class="sd">            [2, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.combinat.partition</span> <span class="kn">import</span> <span class="n">Partition</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_diagram</span><span class="p">(</span><span class="n">glue_ends</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Partition</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">),</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.marking">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.marking">[docs]</a>
    <span class="k">def</span> <span class="nf">marking</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the marking induced by the two sides of the interval</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d e f&#39;,&#39;f a e b d c&#39;)</span>
<span class="sd">            sage: p.marking()</span>
<span class="sd">            5|0</span>
<span class="sd">            sage: p = iet.Permutation(&#39;0 1 2 3 4 5 6&#39;,&#39;3 2 4 6 5 1 0&#39;)</span>
<span class="sd">            sage: p.marking()</span>
<span class="sd">            3o3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">marked_profile</span><span class="p">()</span><span class="o">.</span><span class="n">marking</span><span class="p">()</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.marked_profile">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.marked_profile">[docs]</a>
    <span class="k">def</span> <span class="nf">marked_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the marked profile of the permutation</span>

<span class="sd">        The marked profile of a permutation corresponds to the integer partition</span>
<span class="sd">        associated to the angles of conical singularities in the suspension</span>
<span class="sd">        together with a data associated to the endpoint called marking.</span>

<span class="sd">        If the left endpoint and the right endpoint of the interval associated</span>
<span class="sd">        to the permutation, then the marking is of type one and consists in a</span>
<span class="sd">        couple ``(m,a)`` such that ``m`` is the angle of the conical singularity</span>
<span class="sd">        and ``a`` is the angle between the outgoing separatrix associated to the</span>
<span class="sd">        left endpoint and the incoming separatrix associated to the right</span>
<span class="sd">        endpoint. A marking of type one is denoted ``(m|a)``.</span>

<span class="sd">        If the left endpoint and the right endpoint are two different conical</span>
<span class="sd">        singularities in the suspension the marking is of type two and</span>
<span class="sd">        consists in a couple ``(m_l,m_r)`` where ``m_l`` (resp. ``m_r``) is the</span>
<span class="sd">        conical angle of the singularity at the left endpoint (resp. right</span>
<span class="sd">        endpoint). A marking of type two is denoted ``m_l o m_r``</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        The irreducible permutation on 1 interval has marked profile of type 2</span>
<span class="sd">        with data `(0,0)`::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a&#39;,&#39;a&#39;)</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            0o0 []</span>

<span class="sd">        Permutations in H(3,1) with all possible profiles::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d e f g&#39;,&#39;b g a c f e d&#39;)</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[&#39;a&#39;, (&#39;b&#39;, &#39;a&#39;), (&#39;g&#39;, &#39;d&#39;), &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]]</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            4|0 [4, 2]</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d e f g&#39;,&#39;c a g d f b e&#39;)</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[&#39;a&#39;, &#39;b&#39;, &#39;f&#39;, &#39;g&#39;], [&#39;c&#39;, &#39;d&#39;, (&#39;g&#39;, &#39;e&#39;), &#39;f&#39;, &#39;d&#39;, &#39;e&#39;, &#39;b&#39;, (&#39;c&#39;, &#39;a&#39;)]]</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            4|1 [4, 2]</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d e f g&#39;,&#39;e b d g c a f&#39;)</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[&#39;a&#39;, &#39;b&#39;, &#39;e&#39;, &#39;f&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, (&#39;g&#39;, &#39;f&#39;), &#39;g&#39;, &#39;d&#39;, (&#39;e&#39;, &#39;a&#39;)]]</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            4|2 [4, 2]</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d e f g&#39;, &#39;e c g b a f d&#39;)</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[&#39;a&#39;, &#39;b&#39;, (&#39;g&#39;, &#39;d&#39;), (&#39;e&#39;, &#39;a&#39;), &#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;f&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;f&#39;, &#39;g&#39;]]</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            4|3 [4, 2]</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d e f g&#39;, &#39;f d c a g e b&#39;)</span>
<span class="sd">            sage: p.interval_diagram()</span>
<span class="sd">            [[&#39;a&#39;, &#39;b&#39;, &#39;e&#39;, (&#39;f&#39;, &#39;a&#39;), &#39;c&#39;, &#39;d&#39;, &#39;f&#39;, &#39;g&#39;], [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;, (&#39;g&#39;, &#39;b&#39;)]]</span>
<span class="sd">            sage: p.marked_profile()</span>
<span class="sd">            4o2 [4, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.marked_partition</span> <span class="kn">import</span> <span class="n">MarkedPartition</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MarkedPartition</span><span class="p">([],</span><span class="mi">2</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_diagram</span><span class="p">(</span><span class="n">glue_ends</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">right</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span> <span class="n">c_left</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">if</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span> <span class="n">c_right</span> <span class="o">=</span> <span class="n">c</span>

        <span class="k">if</span> <span class="n">c_left</span> <span class="o">==</span> <span class="n">c_right</span><span class="p">:</span>
            <span class="n">mm</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_left</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="n">c_right</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="o">-</span><span class="n">c_left</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span><span class="n">mm</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">MarkedPartition</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">mm</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">m_l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_left</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">m_r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">MarkedPartition</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">m_l</span><span class="p">,</span><span class="n">m_r</span><span class="p">))</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.stratum">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.stratum">[docs]</a>
    <span class="k">def</span> <span class="nf">stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the strata in which any suspension of this permutation lives.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a stratum of Abelian differentials</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;)</span>
<span class="sd">            sage: p.stratum()</span>
<span class="sd">            H_1(0^2)</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d a b c&#39;)</span>
<span class="sd">            sage: p.stratum()</span>
<span class="sd">            H_1(0^3)</span>

<span class="sd">            sage: p = iet.Permutation(list(range(9)), [8,5,2,7,4,1,6,3,0])</span>
<span class="sd">            sage: p.stratum()</span>
<span class="sd">            H_3(1^4)</span>

<span class="sd">            sage: a = &#39;a b c d e f g h i j&#39;</span>
<span class="sd">            sage: b3 = &#39;d c g f e j i h b a&#39;</span>
<span class="sd">            sage: b2 = &#39;d c e g f j i h b a&#39;</span>
<span class="sd">            sage: b1 = &#39;e d c g f h j i b a&#39;</span>
<span class="sd">            sage: p3 = iet.Permutation(a, b3)</span>
<span class="sd">            sage: p3.stratum()</span>
<span class="sd">            H_4(3, 2, 1)</span>
<span class="sd">            sage: p2 = iet.Permutation(a, b2)</span>
<span class="sd">            sage: p2.stratum()</span>
<span class="sd">            H_4(3, 2, 1)</span>
<span class="sd">            sage: p1 = iet.Permutation(a, b1)</span>
<span class="sd">            sage: p1.stratum()</span>
<span class="sd">            H_4(3, 2, 1)</span>

<span class="sd">        AUTHORS:</span>

<span class="sd">        - Vincent Delecroix (2008-12-20)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.abelian_strata</span> <span class="kn">import</span> <span class="n">AbelianStratum</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_irreducible</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">stratum</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose</span><span class="p">()))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">([])</span>

        <span class="n">singularities</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">()]</span>

        <span class="k">return</span> <span class="n">AbelianStratum</span><span class="p">(</span><span class="n">singularities</span><span class="p">)</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.genus">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.genus">[docs]</a>
    <span class="k">def</span> <span class="nf">genus</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the genus corresponding to any suspension of self.</span>

<span class="sd">        The genus can be deduced from the profile (see :meth:`profile`)</span>
<span class="sd">        `p = (p_1,\ldots,p_k)` of self by the formula:</span>
<span class="sd">        `2g-2 = \sum_{i=1}^k (p_i-1)`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;)</span>
<span class="sd">            sage: p.genus()</span>
<span class="sd">            1</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d c b a&#39;)</span>
<span class="sd">            sage: p.genus()</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.arf_invariant">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.arf_invariant">[docs]</a>
    <span class="k">def</span> <span class="nf">arf_invariant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Arf invariant of the permutation.</span>

<span class="sd">        To a permutation `\pi` is associated a quadratic form on the field with</span>
<span class="sd">        2 elements. The *Arf invariant* is the total invariant of linear</span>
<span class="sd">        equivalence class of quadratic form of given rank.</span>

<span class="sd">        Let `V` be a vector space on the field with two elements `\FF_2`.  `V`</span>
<span class="sd">        there are two equivalence classes of non degenerate quadratic forms.  A</span>
<span class="sd">        complete invariant for quadratic forms is the *Arf invariant*.</span>

<span class="sd">        For non zero degenerate quadratic forms there are three equivalence</span>
<span class="sd">        classes. If `B` denotes the bilinear form associated to `q` then the</span>
<span class="sd">        three classes are as follows</span>

<span class="sd">        - the restriction of `q` to `ker(B)` is non zero</span>

<span class="sd">        - the restriction of `q` to `ker(B)` is zero and the spin parity of `q`</span>
<span class="sd">          on the quotient `V/ker(B)` is 0</span>

<span class="sd">        - the restriction of `q` to `ker(B)` is zero and the spin parity of `q`</span>
<span class="sd">          on the quotient `V/ker(B)` is 1</span>

<span class="sd">        The function returns respectively `None`, `0` or `1` depending on the</span>
<span class="sd">        three alternatives above.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        Permutations from the odd and even component of H(2,2,2)::</span>

<span class="sd">            sage: a = list(range(10))</span>
<span class="sd">            sage: b1 = [3,2,4,6,5,7,9,8,1,0]</span>
<span class="sd">            sage: b0 = [6,5,4,3,2,7,9,8,1,0]</span>
<span class="sd">            sage: p1 = iet.Permutation(a,b1)</span>
<span class="sd">            sage: p1.arf_invariant()</span>
<span class="sd">            1</span>
<span class="sd">            sage: p0 = iet.Permutation(a,b0)</span>
<span class="sd">            sage: p0.arf_invariant()</span>
<span class="sd">            0</span>

<span class="sd">        Permutations from the odd and even component of H(4,4)::</span>

<span class="sd">            sage: a = list(range(11))</span>
<span class="sd">            sage: b1 = [3,2,5,4,6,8,7,10,9,1,0]</span>
<span class="sd">            sage: b0 = [5,4,3,2,6,8,7,10,9,1,0]</span>
<span class="sd">            sage: p1 = iet.Permutation(a,b1)</span>
<span class="sd">            sage: p1.arf_invariant()</span>
<span class="sd">            1</span>
<span class="sd">            sage: p0 = iet.Permutation(a,b0)</span>
<span class="sd">            sage: p0.arf_invariant()</span>
<span class="sd">            0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="kn">from</span> <span class="nn">sage.rings.finite_rings.finite_field_constructor</span> <span class="kn">import</span> <span class="n">GF</span>
        <span class="n">GF2</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection_matrix</span><span class="p">(</span><span class="n">GF2</span><span class="p">)</span>
        <span class="n">F</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">symplectic_form</span><span class="p">()</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ncols</span><span class="p">()</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">GF2</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="n">a_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
            <span class="n">t_a</span> <span class="o">=</span> <span class="n">GF2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_indices</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_indices</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">a_indices</span><span class="p">)):</span>
                    <span class="n">t_a</span> <span class="o">+=</span> <span class="n">M</span><span class="p">[</span><span class="n">a_indices</span><span class="p">[</span><span class="n">j1</span><span class="p">],</span> <span class="n">a_indices</span><span class="p">[</span><span class="n">j2</span><span class="p">]]</span>

            <span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">g</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
            <span class="n">b_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
            <span class="n">t_b</span> <span class="o">=</span> <span class="n">GF2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b_indices</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b_indices</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">b_indices</span><span class="p">)):</span>
                    <span class="n">t_b</span> <span class="o">+=</span> <span class="n">M</span><span class="p">[</span><span class="n">b_indices</span><span class="p">[</span><span class="n">j1</span><span class="p">],</span><span class="n">b_indices</span><span class="p">[</span><span class="n">j2</span><span class="p">]]</span>

            <span class="n">s</span> <span class="o">+=</span> <span class="n">t_a</span> <span class="o">*</span> <span class="n">t_b</span>

        <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.stratum_component">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.stratum_component">[docs]</a>
    <span class="k">def</span> <span class="nf">stratum_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a connected components of a stratum.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        Permutations from the stratum H(6)::</span>

<span class="sd">            sage: a = list(range(8))</span>
<span class="sd">            sage: b_hyp = [7,6,5,4,3,2,1,0]</span>
<span class="sd">            sage: b_odd = [3,2,5,4,7,6,1,0]</span>
<span class="sd">            sage: b_even = [5,4,3,2,7,6,1,0]</span>
<span class="sd">            sage: p_hyp = iet.Permutation(a, b_hyp)</span>
<span class="sd">            sage: p_odd = iet.Permutation(a, b_odd)</span>
<span class="sd">            sage: p_even = iet.Permutation(a, b_even)</span>
<span class="sd">            sage: p_hyp.stratum_component()</span>
<span class="sd">            H_4(6)^hyp</span>
<span class="sd">            sage: p_odd.stratum_component()</span>
<span class="sd">            H_4(6)^odd</span>
<span class="sd">            sage: p_even.stratum_component()</span>
<span class="sd">            H_4(6)^even</span>

<span class="sd">        Permutations from the stratum H(4,4)::</span>

<span class="sd">            sage: a = list(range(11))</span>
<span class="sd">            sage: b_hyp = [10,9,8,7,6,5,4,3,2,1,0]</span>
<span class="sd">            sage: b_odd = [3,2,5,4,6,8,7,10,9,1,0]</span>
<span class="sd">            sage: b_even = [5,4,3,2,6,8,7,10,9,1,0]</span>
<span class="sd">            sage: p_hyp = iet.Permutation(a,b_hyp)</span>
<span class="sd">            sage: p_odd = iet.Permutation(a,b_odd)</span>
<span class="sd">            sage: p_even = iet.Permutation(a,b_even)</span>
<span class="sd">            sage: p_hyp.stratum() == AbelianStratum(4,4)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p_hyp.stratum_component()</span>
<span class="sd">            H_5(4^2)^hyp</span>
<span class="sd">            sage: p_odd.stratum() == AbelianStratum(4,4)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p_odd.stratum_component()</span>
<span class="sd">            H_5(4^2)^odd</span>
<span class="sd">            sage: p_even.stratum() == AbelianStratum(4,4)</span>
<span class="sd">            True</span>
<span class="sd">            sage: p_even.stratum_component()</span>
<span class="sd">            H_5(4^2)^even</span>

<span class="sd">        As for stratum you can specify that you want to attach the singularity</span>
<span class="sd">        on the left of the interval using the option marked_separatrix::</span>

<span class="sd">            sage: a = list(range(1,10))</span>
<span class="sd">            sage: b_odd = [4,3,6,5,7,9,8,2,1]</span>
<span class="sd">            sage: b_even = [6,5,4,3,7,9,8,2,1]</span>
<span class="sd">            sage: p_odd = iet.Permutation(a,b_odd)</span>
<span class="sd">            sage: p_even = iet.Permutation(a,b_even)</span>
<span class="sd">            sage: p_odd.stratum_component()</span>
<span class="sd">            H_4(4, 2)^odd</span>
<span class="sd">            sage: p_even.stratum_component()</span>
<span class="sd">            H_4(4, 2)^even</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.abelian_strata</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ASC</span><span class="p">,</span> <span class="n">HypASC</span><span class="p">,</span> <span class="n">NonHypASC</span><span class="p">,</span> <span class="n">OddASC</span><span class="p">,</span> <span class="n">EvenASC</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_irreducible</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">stratum_component</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose</span><span class="p">()))</span>

        <span class="n">stratum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratum</span><span class="p">()</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">stratum</span><span class="o">.</span><span class="n">_cc</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stratum</span><span class="o">.</span><span class="n">components</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">HypASC</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hyperelliptic</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">HypASC</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cc</span> <span class="o">=</span> <span class="n">cc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">stratum</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">spin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arf_invariant</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">spin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">EvenASC</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">OddASC</span><span class="p">(</span><span class="n">stratum</span><span class="p">)</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.order_of_rauzy_action">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.order_of_rauzy_action">[docs]</a>
    <span class="k">def</span> <span class="nf">order_of_rauzy_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the order of the action of a Rauzy move.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``winner`` - string ``&#39;top&#39;`` or ``&#39;bottom&#39;``</span>

<span class="sd">        - ``side`` - string ``&#39;left&#39;`` or ``&#39;right&#39;``</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        An integer corresponding to the order of the Rauzy action.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d a c b&#39;)</span>
<span class="sd">            sage: p.order_of_rauzy_action(&#39;top&#39;, &#39;right&#39;)</span>
<span class="sd">            3</span>
<span class="sd">            sage: p.order_of_rauzy_action(&#39;bottom&#39;, &#39;right&#39;)</span>
<span class="sd">            2</span>
<span class="sd">            sage: p.order_of_rauzy_action(&#39;top&#39;, &#39;left&#39;)</span>
<span class="sd">            1</span>
<span class="sd">            sage: p.order_of_rauzy_action(&#39;bottom&#39;, &#39;left&#39;)</span>
<span class="sd">            3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.rauzy_move">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.rauzy_move">[docs]</a>
    <span class="k">def</span> <span class="nf">rauzy_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the permutation after a Rauzy move.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``winner`` - &#39;top&#39; or &#39;bottom&#39; interval</span>

<span class="sd">        - ``side`` - &#39;right&#39; or &#39;left&#39; (default: &#39;right&#39;) corresponding</span>
<span class="sd">          to the side on which the Rauzy move must be performed.</span>

<span class="sd">        - ``inplace`` - (default ``False``) whether the Rauzy move is</span>
<span class="sd">          performed inplace (to be used with care since permutations</span>
<span class="sd">          are hashable, set to ``True`` if you are sure to know what</span>
<span class="sd">          you are doing)</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a permutation</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: p.rauzy_move(winner=&#39;top&#39;, side=&#39;right&#39;) == p</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.rauzy_move(winner=&#39;bottom&#39;, side=&#39;right&#39;) == p</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.rauzy_move(winner=&#39;top&#39;, side=&#39;left&#39;) == p</span>
<span class="sd">            True</span>
<span class="sd">            sage: p.rauzy_move(winner=&#39;bottom&#39;, side=&#39;left&#39;) == p</span>
<span class="sd">            True</span>

<span class="sd">        The options winner can be shortened to &#39;t&#39;, &#39;b&#39; and  &#39;r&#39;, &#39;l&#39;. As you</span>
<span class="sd">        can see in the following example::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: p.rauzy_move(winner=&#39;t&#39;, side=&#39;r&#39;)</span>
<span class="sd">            a b c</span>
<span class="sd">            c a b</span>
<span class="sd">            sage: p.rauzy_move(winner=&#39;b&#39;, side=&#39;r&#39;)</span>
<span class="sd">            a c b</span>
<span class="sd">            c b a</span>
<span class="sd">            sage: p.rauzy_move(winner=&#39;t&#39;, side=&#39;l&#39;)</span>
<span class="sd">            a b c</span>
<span class="sd">            b c a</span>
<span class="sd">            sage: p.rauzy_move(winner=&#39;b&#39;, side=&#39;l&#39;)</span>
<span class="sd">            b a c</span>
<span class="sd">            c b a</span>

<span class="sd">        This works as well for reduced permutations::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d b c a&#39;,reduced=True)</span>
<span class="sd">            sage: p.rauzy_move(&#39;t&#39;)</span>
<span class="sd">            a b c d</span>
<span class="sd">            d a b c</span>

<span class="sd">        If Rauzy induction is not well defined, an error is raised::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;, &#39;a b&#39;)</span>
<span class="sd">            sage: p.rauzy_move(&#39;t&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: Rauzy induction is not well defined</span>


<span class="sd">        Test the inplace option::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d c b a&#39;)</span>
<span class="sd">            sage: q = p.rauzy_move(&#39;t&#39;, inplace=True)</span>
<span class="sd">            sage: assert q is p</span>
<span class="sd">            sage: p</span>
<span class="sd">            a b c d</span>
<span class="sd">            d a c b</span>
<span class="sd">            sage: q = p.rauzy_move(&#39;b&#39;, inplace=True)</span>
<span class="sd">            sage: assert q is p</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
        <span class="n">loser</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">winner</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">side</span><span class="p">]</span> <span class="o">==</span> <span class="n">side</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">side</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">+</span><span class="n">side</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Rauzy induction is not well defined&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>

        <span class="n">wtp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.backward_rauzy_move">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.backward_rauzy_move">[docs]</a>
    <span class="k">def</span> <span class="nf">backward_rauzy_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the permutation before a Rauzy move.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``winner`` - &#39;top&#39; or &#39;bottom&#39; interval</span>

<span class="sd">        - ``side`` - &#39;right&#39; or &#39;left&#39; (default: &#39;right&#39;) corresponding</span>
<span class="sd">          to the side on which the Rauzy move must be performed.</span>

<span class="sd">        - ``inplace`` - (default ``False``) whether the Rauzy move is</span>
<span class="sd">          performed inplace (to be used with care since permutations</span>
<span class="sd">          are hashable, set to ``True`` if you are sure to know what</span>
<span class="sd">          you are doing)</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - a permutation</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        Testing the inversion on labelled permutations::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d c b a&#39;)</span>
<span class="sd">            sage: for pos,side in [(&#39;t&#39;,&#39;r&#39;),(&#39;b&#39;,&#39;r&#39;),(&#39;t&#39;,&#39;l&#39;),(&#39;b&#39;,&#39;l&#39;)]:</span>
<span class="sd">            ....:     q = p.rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.backward_rauzy_move(pos,side) == p)</span>
<span class="sd">            ....:     q = p.backward_rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.rauzy_move(pos,side) == p)</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>

<span class="sd">        Testing the inversion on reduced permutations::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d c b a&#39;,reduced=True)</span>
<span class="sd">            sage: for pos,side in [(&#39;t&#39;,&#39;r&#39;),(&#39;b&#39;,&#39;r&#39;),(&#39;t&#39;,&#39;l&#39;),(&#39;b&#39;,&#39;l&#39;)]:</span>
<span class="sd">            ....:     q = p.rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.backward_rauzy_move(pos,side) == p)</span>
<span class="sd">            ....:     q = p.backward_rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.rauzy_move(pos,side) == p)</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>

<span class="sd">        Test the inplace option::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d c b a&#39;)</span>
<span class="sd">            sage: q = p.backward_rauzy_move(&#39;t&#39;, inplace=True)</span>
<span class="sd">            sage: assert q is p</span>
<span class="sd">            sage: p</span>
<span class="sd">            a b c d</span>
<span class="sd">            d b a c</span>
<span class="sd">            sage: q = p.backward_rauzy_move(&#39;t&#39;, inplace=True)</span>
<span class="sd">            sage: q = p.backward_rauzy_move(&#39;b&#39;, inplace=True)</span>
<span class="sd">            sage: assert q is p</span>
<span class="sd">            sage: q = p.rauzy_move(&#39;b&#39;, inplace=True)</span>
<span class="sd">            sage: q = p.rauzy_move(&#39;t&#39;, inplace=True)</span>
<span class="sd">            sage: q = p.rauzy_move(&#39;t&#39;, inplace=True)</span>
<span class="sd">            sage: p</span>
<span class="sd">            a b c d</span>
<span class="sd">            d c b a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>

        <span class="n">loser</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">winner</span>
        <span class="n">winner_twin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">loser</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">loser</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">winner_twin</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># move the element</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">winner_twin</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># correction for the moved element</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">d</span>

            <span class="c1"># shift twins that are after the moved element</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">winner_twin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">loser</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">loser</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">winner_twin</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># move the element</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">winner_twin</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># correction for the moved element</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># unshift elements before the moved element</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">winner_twin</span><span class="p">):</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.erase_marked_points">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.erase_marked_points">[docs]</a>
    <span class="k">def</span> <span class="nf">erase_marked_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a permutation equivalent to self but without marked points.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: p.erase_marked_points()</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b1 b2 c d&#39;, &#39;d c b1 b2 a&#39;)</span>
<span class="sd">            sage: p.erase_marked_points()</span>
<span class="sd">            a b1 c d</span>
<span class="sd">            d c b1 a</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a0 a1 b0 b1 c0 c1 d0 d1&#39;,&#39;d0 d1 c0 c1 b0 b1 a0 a1&#39;)</span>
<span class="sd">            sage: p.erase_marked_points()</span>
<span class="sd">            a0 b0 c0 d0</span>
<span class="sd">            d0 c0 b0 a0</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b y0 y1 x0 x1 c d&#39;,&#39;c x0 x1 a d y0 y1 b&#39;)</span>
<span class="sd">            sage: p.erase_marked_points()</span>
<span class="sd">            a b c d</span>
<span class="sd">            c a d b</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a x y z b&#39;,&#39;b x y z a&#39;)</span>
<span class="sd">            sage: p.erase_marked_points()</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>
<span class="sd">            sage: p = iet.Permutation(&quot;0 1 2 3 4 5 6&quot;,&quot;6 0 3 2 4 1 5&quot;)</span>
<span class="sd">            sage: p.stratum()</span>
<span class="sd">            H_3(4, 0)</span>
<span class="sd">            sage: p.erase_marked_points().stratum()</span>
<span class="sd">            H_3(4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_irreducible</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the permutation must be irreducible&quot;</span><span class="p">)</span>

        <span class="n">tops</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># true if we keep and false if not</span>
        <span class="n">bots</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># remove the zeros which are not at the endpoints</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">tops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">bots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># remove the fake zero on the left</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">i0</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i1</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i1</span><span class="p">:</span>
            <span class="n">tops</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">bots</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">i0</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">i1</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># remove the fake zero on the right</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i0</span><span class="o">&lt;</span><span class="n">n</span> <span class="ow">and</span> <span class="n">i1</span><span class="o">&lt;</span><span class="n">n</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i1</span><span class="p">:</span>
            <span class="n">tops</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">bots</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">i0</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span>


        <span class="n">top_labs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bot_labs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">top</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">tops</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">top</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_labs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">bots</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">bot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bot_labs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># remove the fake zero on the left-right</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">bot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">bot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">bot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">bot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">elif</span> <span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">top</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bot</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="k">del</span> <span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">del</span> <span class="n">top</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">del</span> <span class="n">bot</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">top</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bot</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">bot</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">bot</span><span class="p">[</span><span class="n">i1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">top</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bot</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">top</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">bot</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">bot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">bot</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">((</span><span class="n">top</span><span class="p">,</span><span class="n">bot</span><span class="p">))</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.is_hyperelliptic">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.is_hyperelliptic">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hyperelliptic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the permutation is in the class of the symmetric</span>
<span class="sd">        permutations (with eventual marked points).</span>

<span class="sd">        This is equivalent to say that the suspension lives in an hyperelliptic</span>
<span class="sd">        stratum of Abelian differentials H_hyp(2g-2) or H_hyp(g-1, g-1) with</span>
<span class="sd">        some marked points.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.Permutation(&#39;a b c d&#39;,&#39;d c b a&#39;).is_hyperelliptic()</span>
<span class="sd">            True</span>
<span class="sd">            sage: iet.Permutation(&#39;0 1 2 3 4 5&#39;,&#39;5 2 1 4 3 0&#39;).is_hyperelliptic()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">erase_marked_points</span><span class="p">()</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">length_top</span><span class="p">()</span>
        <span class="n">cylindric</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">to_standard</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cylindric</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.to_cylindric">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.to_cylindric">[docs]</a>
    <span class="k">def</span> <span class="nf">to_cylindric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a cylindric permutation in the same Rauzy class.</span>

<span class="sd">        A permutation is *cylindric* if the first letter in the top interval is</span>
<span class="sd">        also the last letter of the bottom interval or if the last letter of the</span>
<span class="sd">        top interval is the first letter of the bottom interval.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: p.to_cylindric() == p</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;b d a c&#39;)</span>
<span class="sd">            sage: q = p.to_cylindric()</span>
<span class="sd">            sage: q[0][0] == q[1][-1] or q[1][0] == q[1][0]</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">a0</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span><span class="n">a1</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">p_min</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p_min</span> <span class="o">==</span> <span class="n">a0</span><span class="p">:</span>
                <span class="n">k_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">a0</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k_min</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">rauzy_move</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">k_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">a1</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k_min</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">rauzy_move</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">a0</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">p_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span><span class="n">a1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tmp</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.is_cylindric">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.is_cylindric">[docs]</a>
    <span class="k">def</span> <span class="nf">is_cylindric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the permutation is cylindric</span>

<span class="sd">        A permutation `\pi` is cylindric if `\pi(1) = n` or `\pi(n) = 1`. The</span>
<span class="sd">        name cylindric comes from geometry. A cylindric permutation has a</span>
<span class="sd">        suspension which is a flat surface with a completely periodic horizontal</span>
<span class="sd">        direction which is made of only one cylinder.</span>


<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.Permutation(&#39;1 2 3&#39;,&#39;3 2 1&#39;).is_cylindric()</span>
<span class="sd">            True</span>
<span class="sd">            sage: iet.Permutation(&#39;1 2 3&#39;,&#39;3 1 2&#39;).is_cylindric()</span>
<span class="sd">            True</span>
<span class="sd">            sage: iet.Permutation(&#39;1 2 3 4&#39;,&#39;3 1 2 4&#39;).is_cylindric()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.to_standard">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.to_standard">[docs]</a>
    <span class="k">def</span> <span class="nf">to_standard</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a standard permutation in the same Rauzy class.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: p.to_standard() == p</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;b d a c&#39;)</span>
<span class="sd">            sage: q = p.to_standard()</span>
<span class="sd">            sage: q[0][0] == q[1][-1]</span>
<span class="sd">            True</span>
<span class="sd">            sage: q[1][0] == q[1][0]</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cylindric</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">a0</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span><span class="n">a1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">rauzy_move</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">rauzy_move</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tmp</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.is_standard">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.is_standard">[docs]</a>
    <span class="k">def</span> <span class="nf">is_standard</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if the permutation is standard</span>

<span class="sd">        A permutation `\pi` is standard if &#39;\pi(n) = 1` and `\pi(1) = n`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d c b a&#39;)</span>
<span class="sd">            sage: p.is_standard()</span>
<span class="sd">            True</span>
<span class="sd">            sage: p = p.rauzy_move(&#39;top&#39;)</span>
<span class="sd">            sage: p.is_standard()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.to_permutation">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.to_permutation">[docs]</a>
    <span class="k">def</span> <span class="nf">to_permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the permutation as an element of the symmetric group.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: p.to_permutation()</span>
<span class="sd">            [3, 2, 1]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = Permutation([2,4,1,3])</span>
<span class="sd">            sage: q = iet.Permutation(p)</span>
<span class="sd">            sage: q.to_permutation() == p</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.combinat.permutation</span> <span class="kn">import</span> <span class="n">Permutation</span>
        <span class="k">return</span> <span class="n">Permutation</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.suspension_cone">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.suspension_cone">[docs]</a>
    <span class="k">def</span> <span class="nf">suspension_cone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cone of suspension data.</span>

<span class="sd">        A suspension data `\tau` for a permutation `(\pi_{top}, \pi_{bot})`</span>
<span class="sd">        on the alphabet `\mathcal{A}` is a real vector in `RR^\mathcal{A}`</span>
<span class="sd">        so that</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \forall 1 \leq k &lt; d,\,</span>
<span class="sd">            \sum_{\beta: \pi_{top}(\beta) \leq k} \tau_\beta &gt; 0</span>
<span class="sd">            \quad \text{and} \quad</span>
<span class="sd">            \sum_{\beta: \pi_{bot}(\beta) \leq k} \tau_\beta &lt; 0.</span>

<span class="sd">        A suspension data determines half of a zippered rectangle construction.</span>
<span class="sd">        The other half is the length data that is a positive vector in</span>
<span class="sd">        `\RR^\mathcal{A}`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``winner`` - (optional) either ``None``, ``&quot;top&quot;`` or ``&quot;bottom&quot;``. If</span>
<span class="sd">          not ``None`` , then return only half of the suspension cone corresponding</span>
<span class="sd">          to data that either comes from a top or bottom Rauzy induction.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`heights_cone`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c d e f&#39;, &#39;e c b f d a&#39;)</span>
<span class="sd">            sage: H = p.suspension_cone()</span>
<span class="sd">            sage: H.dimension()</span>
<span class="sd">            6</span>
<span class="sd">            sage: rays = [r.vector() for r in H.rays()]</span>
<span class="sd">            sage: r = sum(randint(1,5)*ray for ray in rays)</span>
<span class="sd">            sage: r[0]&gt;0 and r[0]+r[1] &gt; 0 and r[0]+r[1]+r[2] &gt; 0</span>
<span class="sd">            True</span>
<span class="sd">            sage: r[0]+r[1]+r[2]+r[3]&gt;0</span>
<span class="sd">            True</span>
<span class="sd">            sage: r[0]+r[1]+r[2]+r[3]+r[4]&gt;0</span>
<span class="sd">            True</span>
<span class="sd">            sage: r[4]&lt;0 and r[4]+r[2]&lt;0 and r[4]+r[2]+r[1] &lt; 0</span>
<span class="sd">            True</span>
<span class="sd">            sage: r[4]+r[2]+r[1]+r[5]&lt;0</span>
<span class="sd">            True</span>
<span class="sd">            sage: r[4]+r[2]+r[1]+r[5]+r[3]&lt;0</span>
<span class="sd">            True</span>

<span class="sd">        The construction also works with reduced permutations (ie not carrying</span>
<span class="sd">        labels)::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d c b a&#39;, reduced=True)</span>
<span class="sd">            sage: H = p.suspension_cone()</span>
<span class="sd">            sage: r = sum(r.vector() for r in H.rays())</span>
<span class="sd">            sage: r[0] &gt; 0 and r[0]+r[1] &gt; 0 and r[0]+r[1]+r[2] &gt; 0</span>
<span class="sd">            True</span>
<span class="sd">            sage: r[3] &lt; 0 and r[3]+r[2] &lt; 0 and r[3]+r[2]+r[1] &lt; 0</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ieqs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">ieq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">ieq</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">ieqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ieq</span><span class="p">)</span>

            <span class="n">ieq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">ieq</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">ieqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ieq</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">winner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">winner</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># sum of heights is &lt;= 0</span>
                <span class="n">ieqs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">winner</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># sum of heights is &gt;= 0</span>
                <span class="n">ieqs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="kn">from</span> <span class="nn">sage.geometry.polyhedron.constructor</span> <span class="kn">import</span> <span class="n">Polyhedron</span>
        <span class="k">return</span> <span class="n">Polyhedron</span><span class="p">(</span><span class="n">ieqs</span><span class="o">=</span><span class="n">ieqs</span><span class="p">)</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.heights_cone">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.heights_cone">[docs]</a>
    <span class="k">def</span> <span class="nf">heights_cone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cone of heights data.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            :meth:`suspension_cone`</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;, &#39;d c b a&#39;)</span>
<span class="sd">            sage: C = p.heights_cone()</span>
<span class="sd">            sage: C</span>
<span class="sd">            A 4-dimensional polyhedron in QQ^4 defined as the convex hull of 1 vertex and 5 rays</span>
<span class="sd">            sage: C.rays_list()</span>
<span class="sd">            [[0, 0, 1, 1], [0, 1, 1, 0], [0, 1, 1, 1], [1, 1, 0, 0], [1, 1, 1, 0]]</span>

<span class="sd">            sage: p.heights_cone(&#39;top&#39;).rays_list()</span>
<span class="sd">            [[0, 0, 1, 1], [0, 1, 1, 0], [1, 1, 0, 0], [1, 1, 1, 0]]</span>
<span class="sd">            sage: p.heights_cone(&#39;bot&#39;).rays_list()</span>
<span class="sd">            [[0, 0, 1, 1], [0, 1, 1, 0], [0, 1, 1, 1], [1, 1, 0, 0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection_matrix</span><span class="p">()</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">suspension_cone</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.geometry.polyhedron.constructor</span> <span class="kn">import</span> <span class="n">Polyhedron</span>
        <span class="k">return</span> <span class="n">Polyhedron</span><span class="p">(</span><span class="n">rays</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">c</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">rays</span><span class="p">()])</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.invariant_density_rauzy">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.invariant_density_rauzy">[docs]</a>
    <span class="k">def</span> <span class="nf">invariant_density_rauzy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the invariant density for the Rauzy induction.</span>

<span class="sd">        Goes via the zippered rectangle construction of [Vee1982]_.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import iet</span>
<span class="sd">            sage: f = iet.Permutation(&#39;a b c d&#39;, &#39;d c b a&#39;).invariant_density_rauzy()</span>
<span class="sd">            sage: f</span>
<span class="sd">            (1)/((x2 + x3)*(x1 + x2)*(x1 + x2 + x3)*(x0 + x1)) + (1)/((x2 + x3)*(x1 + x2)*(x0 + x1)*(x0 + x1 + x2))</span>

<span class="sd">            sage: f_top = iet.Permutation(&#39;a b c d&#39;, &#39;d c b a&#39;).invariant_density_rauzy(&#39;top&#39;)</span>
<span class="sd">            sage: f_top</span>
<span class="sd">            (1)/((x2 + x3)*(x1 + x2)*(x0 + x1)*(x0 + x1 + x2))</span>
<span class="sd">            sage: f_bot = iet.Permutation(&#39;a b c d&#39;, &#39;d c b a&#39;).invariant_density_rauzy(&#39;bot&#39;)</span>
<span class="sd">            sage: f_bot</span>
<span class="sd">            (1)/((x2 + x3)*(x1 + x2)*(x1 + x2 + x3)*(x0 + x1))</span>

<span class="sd">            sage: f == f_bot + f_top</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.misc.additive_multivariate_generating_series</span> <span class="kn">import</span> <span class="n">AdditiveMultivariateGeneratingSeriesRing</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.misc.linalg</span> <span class="kn">import</span> <span class="n">cone_triangulate</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">suspension_cone</span><span class="p">(</span><span class="n">winner</span><span class="o">=</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">Omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection_matrix</span><span class="p">()</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">AdditiveMultivariateGeneratingSeriesRing</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="n">hyperplane</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Omega</span><span class="o">.</span><span class="n">columns</span><span class="p">())</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ZZ</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">factorial</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">cone_triangulate</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">hyperplane</span><span class="p">):</span>
            <span class="n">heights</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="o">*</span> <span class="n">Omega</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">t</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heights</span><span class="p">:</span> <span class="n">h</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heights</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">h</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">M</span><span class="o">.</span><span class="n">term</span><span class="p">(</span><span class="n">ZZ</span><span class="o">.</span><span class="n">one</span><span class="p">(),</span> <span class="n">d</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ans</span></div>


<div class="viewcode-block" id="OrientablePermutationIET.to_origami">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.to_origami">[docs]</a>
    <span class="k">def</span> <span class="nf">to_origami</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the origami associated to a cylindric permutation.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import iet</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;, &#39;b a&#39;)</span>
<span class="sd">            sage: p.to_origami()</span>
<span class="sd">            (1)</span>
<span class="sd">            (1)</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c e d f g&#39;, &#39;f e b g d c a&#39;)</span>
<span class="sd">            sage: p.to_origami()</span>
<span class="sd">            (1,2,3,4,5,6)</span>
<span class="sd">            (1,3,2,6,4,5)</span>
<span class="sd">            sage: assert p.stratum_component() == p.to_origami().stratum_component()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;to_origami is only valid for cylindric permutation&quot;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">surface_dynamics.misc.permutation</span> <span class="kn">import</span> <span class="n">perm_invert</span>
        <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.origamis.origami</span> <span class="kn">import</span> <span class="n">Origami</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">perm_invert</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">Origami</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_masur_polygon_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">heights</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.structure.sequence</span> <span class="kn">import</span> <span class="n">Sequence</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">heights</span><span class="p">))</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)]</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">):]</span>
        <span class="n">base_ring</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">universe</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">lengths</span><span class="p">[:</span><span class="n">n</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twins</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">heights</span> <span class="o">=</span> <span class="p">[</span><span class="n">heights</span><span class="p">[:</span><span class="n">n</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">heights</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_twins</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="p">[[</span><span class="n">lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">heights</span> <span class="o">=</span> <span class="p">[[</span><span class="n">heights</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">zero</span> <span class="o">=</span> <span class="n">base_ring</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">zero</span> <span class="o">=</span> <span class="n">base_ring</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># build the polygon in counter-clockwise order</span>
        <span class="n">Ltop</span> <span class="o">=</span> <span class="p">[(</span><span class="n">zero</span><span class="p">,</span><span class="n">zero</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">heights</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Ltop</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dx</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid suspension data dx=</span><span class="si">{}</span><span class="s1"> y=</span><span class="si">{}</span><span class="s1"> at i=</span><span class="si">{}</span><span class="s1"> on top&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
            <span class="n">Ltop</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">))</span>
        <span class="n">Lbot</span> <span class="o">=</span> <span class="p">[(</span><span class="n">zero</span><span class="p">,</span><span class="n">zero</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">heights</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Lbot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dx</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid suspension data dx=</span><span class="si">{}</span><span class="s1"> y=</span><span class="si">{}</span><span class="s1"> at i=</span><span class="si">{}</span><span class="s1"> on bot&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
            <span class="n">Lbot</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">Ltop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Lbot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">Ltop</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">Lbot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">Ltop</span><span class="p">,</span> <span class="n">Lbot</span><span class="p">)</span>
        <span class="n">Ltop</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Lbot</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">endpoint</span> <span class="o">=</span> <span class="n">Ltop</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Lbot</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">flatsurf.geometry.polygon</span> <span class="kn">import</span> <span class="n">Polygon</span>

        <span class="n">ptop</span> <span class="o">=</span> <span class="n">Ltop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pbot</span> <span class="o">=</span> <span class="n">Lbot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="p">[</span><span class="n">Polygon</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="n">zero</span><span class="p">,</span><span class="n">zero</span><span class="p">),</span> <span class="n">pbot</span><span class="p">,</span> <span class="n">ptop</span><span class="p">])]</span>
        <span class="n">tops</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
        <span class="n">bots</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
        <span class="n">mids</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">itop</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">ibot</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">itop</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ltop</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ibot</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">Lbot</span><span class="p">):</span>
            <span class="n">xtop</span> <span class="o">=</span> <span class="n">Ltop</span><span class="p">[</span><span class="n">itop</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">itop</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ltop</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">xbot</span> <span class="o">=</span> <span class="n">Lbot</span><span class="p">[</span><span class="n">ibot</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">ibot</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">Lbot</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">xbot</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xtop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xtop</span> <span class="o">&lt;=</span> <span class="n">xbot</span><span class="p">):</span>
                <span class="c1"># add a triangle with a new vertex on top</span>
                <span class="n">pptop</span> <span class="o">=</span> <span class="n">Ltop</span><span class="p">[</span><span class="n">itop</span><span class="p">]</span>
                <span class="n">itop</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">triangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="n">ptop</span><span class="p">,</span><span class="n">pbot</span><span class="p">,</span><span class="n">pptop</span><span class="p">]))</span>
                <span class="n">tops</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">mids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">mids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">ptop</span> <span class="o">=</span> <span class="n">pptop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ppbot</span> <span class="o">=</span> <span class="n">Lbot</span><span class="p">[</span><span class="n">ibot</span><span class="p">]</span>
                <span class="n">ibot</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">triangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="n">ptop</span><span class="p">,</span><span class="n">pbot</span><span class="p">,</span><span class="n">ppbot</span><span class="p">]))</span>
                <span class="n">bots</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">mids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">mids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">pbot</span> <span class="o">=</span> <span class="n">ppbot</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">triangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="n">ptop</span><span class="p">,</span> <span class="n">pbot</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">]))</span>
        <span class="n">tops</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">bots</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">mids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bots</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">tops</span><span class="p">,</span> <span class="n">bots</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">base_ring</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">tops</span><span class="p">,</span> <span class="n">bots</span><span class="p">,</span> <span class="n">mids</span>

<div class="viewcode-block" id="OrientablePermutationIET.masur_polygon">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationIET.masur_polygon">[docs]</a>
    <span class="k">def</span> <span class="nf">masur_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">heights</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Masur polygon for the given ``lengths`` and ``heights``</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import iet</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;)</span>
<span class="sd">            sage: S = p.masur_polygon([1,4,2], [2,0,-1])  # optional: sage_flatsurf</span>
<span class="sd">            sage: S                                       # optional: sage_flatsurf</span>
<span class="sd">            Translation Surface in H_1(0^2) built from 2 isosceles triangles and 2 triangles</span>
<span class="sd">            sage: S.stratum()                             # optional: sage_flatsurf</span>
<span class="sd">            H_1(0^2)</span>

<span class="sd">        Generic construction using suspension cone::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d e f g h i&#39;, &#39;b g f c a d i e h&#39;)</span>
<span class="sd">            sage: x = polygen(QQ)</span>
<span class="sd">            sage: poly = x^3 - x - 1</span>
<span class="sd">            sage: emb = AA.polynomial_root(poly, RIF(1.3,1.4))</span>
<span class="sd">            sage: K = NumberField(poly, &#39;a&#39;, embedding=emb)</span>
<span class="sd">            sage: a = K.gen()</span>
<span class="sd">            sage: R = [r.vector() for r in p.suspension_cone().rays()]</span>
<span class="sd">            sage: C = [1, a, a+1, 2-a, 2, 1, a, a, 1, a-1, 1]</span>
<span class="sd">            sage: H = sum(c*r for c,r in zip(C,R))</span>
<span class="sd">            sage: H</span>
<span class="sd">            (a + 2, -2, 2, -2*a + 2, 3*a, -a - 4, 0, -a + 1, -2*a - 1)</span>
<span class="sd">            sage: L = [1+a**2, 2*a**2-1, 1, 1, 1+a, a**2, a-1, a-1, 2]</span>
<span class="sd">            sage: S = p.masur_polygon(L, H)   # optional: sage_flatsurf</span>
<span class="sd">            sage: S                           # optional: sage_flatsurf</span>
<span class="sd">            Translation Surface in H_3(1^4) built from 15 triangles and a right triangle</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;)</span>
<span class="sd">            sage: for L in [[1,4,2],[2,4,1],[5,1,1],[1,5,1],[1,1,5]]:  # optional: sage_flatsurf</span>
<span class="sd">            ....:     S = p.masur_polygon(L, [2,0,-1])</span>
<span class="sd">            ....:     assert S.stratum() == p.stratum()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_ring</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">tops</span><span class="p">,</span> <span class="n">bots</span><span class="p">,</span> <span class="n">mids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_masur_polygon_helper</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">heights</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">flatsurf</span> <span class="kn">import</span> <span class="n">MutableOrientedSimilaritySurface</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">MutableOrientedSimilaritySurface</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
            <span class="n">S</span><span class="o">.</span><span class="n">add_polygon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">p1</span><span class="p">,</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">tops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p2</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">bots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">S</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">e1</span><span class="p">),</span> <span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">e2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mids</span><span class="p">),</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">p1</span><span class="p">,</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">mids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p2</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">mids</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">S</span><span class="o">.</span><span class="n">glue</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">e1</span><span class="p">),</span> <span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">e2</span><span class="p">))</span>
        <span class="n">S</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">S</span></div>
</div>



<div class="viewcode-block" id="OrientablePermutationLI">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationLI">[docs]</a>
<span class="k">class</span> <span class="nc">OrientablePermutationLI</span><span class="p">(</span><span class="n">PermutationLI</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Template for quadratic permutation.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Internal class! Do not use directly!</span>

<span class="sd">    AUTHOR:</span>

<span class="sd">    - Vincent Delecroix (2008-12-20): initial version</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="OrientablePermutationLI.rauzy_move">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationLI.rauzy_move">[docs]</a>
    <span class="k">def</span> <span class="nf">rauzy_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the permutation after a Rauzy move.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;,reduced=True)</span>
<span class="sd">            sage: p.rauzy_move(0)</span>
<span class="sd">            a a b</span>
<span class="sd">            b c c</span>
<span class="sd">            sage: p.rauzy_move(1)</span>
<span class="sd">            a a</span>
<span class="sd">            b b c c</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;,reduced=True)</span>
<span class="sd">            sage: p.rauzy_move(0)</span>
<span class="sd">            a a b</span>
<span class="sd">            b c c</span>
<span class="sd">            sage: p.rauzy_move(1)</span>
<span class="sd">            a a</span>
<span class="sd">            b b c c</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b&#39;,&#39;b c c&#39;,reduced=True)</span>
<span class="sd">            sage: pp = p.rauzy_move(0, inplace=True)</span>
<span class="sd">            sage: p</span>
<span class="sd">            a a b</span>
<span class="sd">            b c c</span>
<span class="sd">            sage: pp is p</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
        <span class="n">loser</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">winner</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>

        <span class="n">wti</span><span class="p">,</span> <span class="n">wtp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">wti</span> <span class="o">==</span> <span class="n">loser</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">wtp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wti</span> <span class="o">==</span> <span class="n">loser</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="OrientablePermutationLI.backward_rauzy_move">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationLI.backward_rauzy_move">[docs]</a>
    <span class="k">def</span> <span class="nf">backward_rauzy_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the permutation before the Rauzy move.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        Tests the inversion on labelled generalized permutations::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b b&#39;,&#39;c c d d&#39;)</span>
<span class="sd">            sage: for pos,side in [(&#39;t&#39;,&#39;r&#39;),(&#39;b&#39;,&#39;r&#39;),(&#39;t&#39;,&#39;l&#39;),(&#39;b&#39;,&#39;l&#39;)]:</span>
<span class="sd">            ....:     q = p.rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.backward_rauzy_move(pos,side) == p)</span>
<span class="sd">            ....:     q = p.backward_rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.rauzy_move(pos,side) == p)</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>

<span class="sd">        Tests the inversion on reduced generalized permutations::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a b b&#39;,&#39;c c d d&#39;,reduced=True)</span>
<span class="sd">            sage: for pos,side in [(&#39;t&#39;,&#39;r&#39;),(&#39;b&#39;,&#39;r&#39;),(&#39;t&#39;,&#39;l&#39;),(&#39;b&#39;,&#39;l&#39;)]:</span>
<span class="sd">            ....:     q = p.rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.backward_rauzy_move(pos,side) == p)</span>
<span class="sd">            ....:     q = p.backward_rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.rauzy_move(pos,side) == p)</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
        <span class="n">loser</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">winner</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">wti</span><span class="p">,</span> <span class="n">wtp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>


        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">wti</span> <span class="o">==</span> <span class="n">loser</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">winner</span><span class="p">,</span> <span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wti</span> <span class="o">==</span> <span class="n">loser</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">winner</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="OrientablePermutationLI.stratum">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.OrientablePermutationLI.stratum">[docs]</a>
    <span class="k">def</span> <span class="nf">stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the stratum associated to self</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b b&#39;,&#39;c c a&#39;)</span>
<span class="sd">            sage: p.stratum()</span>
<span class="sd">            Q_0(-1^4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_irreducible</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">surface_dynamics.flat_surfaces.quadratic_strata</span> <span class="kn">import</span> <span class="n">QuadraticStratum</span>
            <span class="k">return</span> <span class="n">QuadraticStratum</span><span class="p">([</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">()])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stratum is well defined only for irreducible permutations&quot;</span><span class="p">)</span></div>
</div>



<span class="n">FlippedPermutation</span> <span class="o">=</span> <span class="n">Permutation</span>


<div class="viewcode-block" id="FlippedPermutationIET">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.FlippedPermutationIET">[docs]</a>
<span class="k">class</span> <span class="nc">FlippedPermutationIET</span><span class="p">(</span><span class="n">PermutationIET</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Template for flipped Abelian permutations.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Internal class! Do not use directly!</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FlippedPermutationIET.rauzy_move">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.FlippedPermutationIET.rauzy_move">[docs]</a>
    <span class="k">def</span> <span class="nf">rauzy_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the permutation after a Rauzy move.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import iet</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c a b&#39;, flips=[&#39;b&#39;], reduced=True)</span>
<span class="sd">            sage: p.rauzy_move(&#39;t&#39;,&#39;r&#39;)</span>
<span class="sd">             a -b  c</span>
<span class="sd">             c -b  a</span>
<span class="sd">            sage: p.rauzy_move(&#39;b&#39;,&#39;r&#39;)</span>
<span class="sd">             a -b -c</span>
<span class="sd">            -b  a -c</span>
<span class="sd">            sage: p.rauzy_move(&#39;t&#39;,&#39;l&#39;)</span>
<span class="sd">             a -b  c</span>
<span class="sd">             c  a -b</span>
<span class="sd">            sage: p.rauzy_move(&#39;b&#39;,&#39;l&#39;)</span>
<span class="sd">            -a  b  c</span>
<span class="sd">             c  b -a</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c d&#39;,&#39;d a b c&#39;,flips=&#39;abcd&#39;)</span>
<span class="sd">            sage: p</span>
<span class="sd">            -a -b -c -d</span>
<span class="sd">            -d -a -b -c</span>
<span class="sd">            sage: p.rauzy_move(&#39;top&#39;,&#39;right&#39;)</span>
<span class="sd">            -a -b  c -d</span>
<span class="sd">             c -d -a -b</span>
<span class="sd">            sage: p.rauzy_move(&#39;bottom&#39;,&#39;right&#39;)</span>
<span class="sd">            -a -b  d -c</span>
<span class="sd">             d -a -b -c</span>
<span class="sd">            sage: p.rauzy_move(&#39;top&#39;,&#39;left&#39;)</span>
<span class="sd">            -a -b -c  d</span>
<span class="sd">            -a  d -b -c</span>
<span class="sd">            sage: p.rauzy_move(&#39;bottom&#39;,&#39;left&#39;)</span>
<span class="sd">            -b -c -d  a</span>
<span class="sd">            -d  a -b -c</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c d&#39;,&#39;d a b c&#39;,flips=&#39;abcd&#39;)</span>
<span class="sd">            sage: pp = p.rauzy_move(&#39;top&#39;, &#39;right&#39;, inplace=True)</span>
<span class="sd">            sage: pp is p</span>
<span class="sd">            True</span>
<span class="sd">            sage: p</span>
<span class="sd">            -a -b  c -d</span>
<span class="sd">             c -d -a -b</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
        <span class="n">loser</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">winner</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>

        <span class="n">wtp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">side</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">side</span><span class="p">]]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">])</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">flip</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="n">flip</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="FlippedPermutationIET.backward_rauzy_move">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.FlippedPermutationIET.backward_rauzy_move">[docs]</a>
    <span class="k">def</span> <span class="nf">backward_rauzy_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the permutation before a Rauzy move.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c d e&#39;,&#39;d a b e c&#39;, flips=&#39;abcd&#39;)</span>
<span class="sd">            sage: for pos,side in [(&#39;t&#39;,&#39;r&#39;),(&#39;b&#39;,&#39;r&#39;),(&#39;t&#39;,&#39;l&#39;),(&#39;b&#39;,&#39;l&#39;)]:</span>
<span class="sd">            ....:     q = p.rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.backward_rauzy_move(pos,side) == p)</span>
<span class="sd">            ....:     q = p.backward_rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.rauzy_move(pos,side) == p)</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>

<span class="sd">        Testing the inversion on reduced permutations::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;f a b c d e&#39;,&#39;d f c b e a&#39;, flips=&#39;abcd&#39;, reduced=True)</span>
<span class="sd">            sage: for pos,side in [(&#39;t&#39;,&#39;r&#39;),(&#39;b&#39;,&#39;r&#39;),(&#39;t&#39;,&#39;l&#39;),(&#39;b&#39;,&#39;l&#39;)]:</span>
<span class="sd">            ....:     q = p.rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.backward_rauzy_move(pos,side) == p)</span>
<span class="sd">            ....:     q = p.backward_rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.rauzy_move(pos,side) == p)</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
        <span class="n">loser</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">winner</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">wtp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>
</div>



<div class="viewcode-block" id="FlippedPermutationLI">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.FlippedPermutationLI">[docs]</a>
<span class="k">class</span> <span class="nc">FlippedPermutationLI</span><span class="p">(</span><span class="n">PermutationLI</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Template for flipped quadratic permutations.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Internal class! Do not use directly!</span>

<span class="sd">    AUTHORS:</span>

<span class="sd">    - Vincent Delecroix (2008-12-20): initial version</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FlippedPermutationLI.rauzy_move">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.FlippedPermutationLI.rauzy_move">[docs]</a>
    <span class="k">def</span> <span class="nf">rauzy_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rauzy move</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import iet</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c b&#39;,&#39;d c d a&#39;,flips=&#39;abcd&#39;)</span>
<span class="sd">            sage: p</span>
<span class="sd">            -a -b -c -b</span>
<span class="sd">            -d -c -d -a</span>
<span class="sd">            sage: p.rauzy_move(&#39;top&#39;,&#39;right&#39;)</span>
<span class="sd">             a -b  a -c -b</span>
<span class="sd">            -d -c -d</span>
<span class="sd">            sage: p.rauzy_move(&#39;bottom&#39;,&#39;right&#39;)</span>
<span class="sd">             b -a  b -c</span>
<span class="sd">            -d -c -d -a</span>
<span class="sd">            sage: p.rauzy_move(&#39;top&#39;,&#39;left&#39;)</span>
<span class="sd">            -a -b -c -b</span>
<span class="sd">            -c  d -a  d</span>
<span class="sd">            sage: p.rauzy_move(&#39;bottom&#39;,&#39;left&#39;)</span>
<span class="sd">            -b -c -b</span>
<span class="sd">            -d -c  a -d  a</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c b&#39;,&#39;d c d a&#39;,flips=&#39;abcd&#39;)</span>
<span class="sd">            sage: pp = p.rauzy_move(&#39;top&#39;, &#39;right&#39;, inplace=True)</span>
<span class="sd">            sage: p</span>
<span class="sd">             a -b  a -c -b</span>
<span class="sd">            -d -c -d</span>
<span class="sd">            sage: pp is p</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
        <span class="n">loser</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">winner</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>

        <span class="n">wti</span><span class="p">,</span> <span class="n">wtp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">side</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">lti</span><span class="p">,</span><span class="n">ltp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">lti</span><span class="p">][</span><span class="n">ltp</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">wti</span> <span class="o">==</span> <span class="n">loser</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">flip</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="n">flip</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wti</span> <span class="o">==</span> <span class="n">loser</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="n">flip</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">flip</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="FlippedPermutationLI.backward_rauzy_move">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.FlippedPermutationLI.backward_rauzy_move">[docs]</a>
    <span class="k">def</span> <span class="nf">backward_rauzy_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="n">side</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rauzy move</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c e b&#39;,&#39;d c d a e&#39;,flips=&#39;abcd&#39;)</span>
<span class="sd">            sage: for pos,side in [(&#39;t&#39;,&#39;r&#39;),(&#39;b&#39;,&#39;r&#39;),(&#39;t&#39;,&#39;l&#39;),(&#39;b&#39;,&#39;l&#39;)]:</span>
<span class="sd">            ....:     q = p.rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.backward_rauzy_move(pos,side) == p)</span>
<span class="sd">            ....:     q = p.backward_rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.rauzy_move(pos,side) == p)</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>

<span class="sd">        Testing the inversion on reduced permutations::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a b c e b&#39;,&#39;d c d a e&#39;,flips=&#39;abcd&#39;,reduced=True)</span>
<span class="sd">            sage: for pos,side in [(&#39;t&#39;,&#39;r&#39;),(&#39;b&#39;,&#39;r&#39;),(&#39;t&#39;,&#39;l&#39;),(&#39;b&#39;,&#39;l&#39;)]:</span>
<span class="sd">            ....:     q = p.rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.backward_rauzy_move(pos,side) == p)</span>
<span class="sd">            ....:     q = p.backward_rauzy_move(pos,side)</span>
<span class="sd">            ....:     print(q.rauzy_move(pos,side) == p)</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="n">interval_conversion</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side_conversion</span><span class="p">(</span><span class="n">side</span><span class="p">)</span>
        <span class="n">loser</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">winner</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">wti</span><span class="p">,</span> <span class="n">wtp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">wti</span> <span class="o">==</span> <span class="n">loser</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">lti</span><span class="p">,</span><span class="n">ltp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">lti</span><span class="p">][</span><span class="n">ltp</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">lti</span><span class="p">,</span><span class="n">ltp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">lti</span><span class="p">][</span><span class="n">ltp</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">winner</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">winner</span><span class="p">,</span> <span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wti</span> <span class="o">==</span> <span class="n">loser</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">lti</span><span class="p">,</span><span class="n">ltp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">loser</span><span class="p">][</span><span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">lti</span><span class="p">][</span><span class="n">ltp</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">loser</span><span class="p">,</span> <span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">lti</span><span class="p">,</span><span class="n">ltp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_twin</span><span class="p">[</span><span class="n">winner</span><span class="p">][</span><span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_flips</span><span class="p">[</span><span class="n">lti</span><span class="p">][</span><span class="n">ltp</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">winner</span><span class="p">,</span> <span class="n">wtp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">winner</span><span class="p">,</span> <span class="n">wtp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">loser</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>
</div>


<div class="viewcode-block" id="RauzyDiagram">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram">[docs]</a>
<span class="k">class</span> <span class="nc">RauzyDiagram</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Template for Rauzy diagrams.</span>

<span class="sd">    .. warning:</span>

<span class="sd">        Internal class! Do not use directly!</span>

<span class="sd">    AUTHORS:</span>

<span class="sd">    - Vincent Delecroix (2008-12-20): initial version</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: pickle problem of Path (it does not understand what is its parent)</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">NestedClassMetaclass</span>

<div class="viewcode-block" id="RauzyDiagram.Path">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path">[docs]</a>
    <span class="k">class</span> <span class="nc">Path</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Path in Rauzy diagram.</span>

<span class="sd">            A path in a Rauzy diagram corresponds to a subsimplex of the simplex of</span>
<span class="sd">            lengths. This correspondence is obtained via the Rauzy induction. To a</span>
<span class="sd">            idoc IET we can associate a unique path in a Rauzy diagram. This</span>
<span class="sd">            establishes a correspondence between infinite full path in Rauzy diagram</span>
<span class="sd">            and equivalence topologic class of IET.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Constructor of the path.</span>

<span class="sd">            TESTS::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;, &#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g = r.path(p, 0, 1, 0); g</span>
<span class="sd">                Path of length 3 in a Rauzy diagram</span>

<span class="sd">            Check for trac ticket 8388::</span>

<span class="sd">                sage: loads(dumps(g)) == g</span>
<span class="sd">                True</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">parent</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No empty data&quot;</span><span class="p">)</span>

            <span class="n">start</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">start</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Starting point not in this Rauzy diagram&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_permutation_to_vertex</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

            <span class="n">cur_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)):</span> <span class="c1"># try parent method</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">edge_types_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indices must be integer between 0 and </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="n">neighbours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">cur_vertex</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">neighbours</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid path&quot;</span><span class="p">)</span>

                <span class="n">cur_vertex</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="n">cur_vertex</span>

        <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a representation of the path.</span>

<span class="sd">            TESTS::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: r.path(p)   #indirect doctest</span>
<span class="sd">                Path of length 0 in a Rauzy diagram</span>
<span class="sd">                sage: r.path(p,&#39;top&#39;)   #indirect doctest</span>
<span class="sd">                Path of length 1 in a Rauzy diagram</span>
<span class="sd">                sage: r.path(p,&#39;bottom&#39;)   #indirect doctest</span>
<span class="sd">                Path of length 1 in a Rauzy diagram</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="s2">&quot;Path of length </span><span class="si">%d</span><span class="s2"> in a Rauzy diagram&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="RauzyDiagram.Path.start">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.start">[docs]</a>
        <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the first vertex of the path.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g = r.path(p, &#39;t&#39;, &#39;b&#39;)</span>
<span class="sd">                sage: g.start() == p</span>
<span class="sd">                True</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">)</span></div>


<div class="viewcode-block" id="RauzyDiagram.Path.end">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.end">[docs]</a>
        <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the last vertex of the path.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g1 = r.path(p, &#39;t&#39;, &#39;b&#39;, &#39;t&#39;)</span>
<span class="sd">                sage: g1.end() == p</span>
<span class="sd">                True</span>
<span class="sd">                sage: g2 = r.path(p, &#39;b&#39;, &#39;t&#39;, &#39;b&#39;)</span>
<span class="sd">                sage: g2.end() == p</span>
<span class="sd">                True</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">)</span></div>


<div class="viewcode-block" id="RauzyDiagram.Path.edge_types">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.edge_types">[docs]</a>
        <span class="k">def</span> <span class="nf">edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the edge types of the path.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g = r.path(p, 0, 1)</span>
<span class="sd">                sage: g.edge_types()</span>
<span class="sd">                [0, 1]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span></div>


        <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Tests equality</span>

<span class="sd">            TESTS::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p1 = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">                sage: r1 = p1.rauzy_diagram()</span>
<span class="sd">                sage: p2 = p1.reduced()</span>
<span class="sd">                sage: r2 = p2.rauzy_diagram()</span>
<span class="sd">                sage: r1.path(p1,0,1) == r2.path(p2,0,1)</span>
<span class="sd">                False</span>
<span class="sd">                sage: r1.path(p1,0) == r1.path(p1,0)</span>
<span class="sd">                True</span>
<span class="sd">                sage: r1.path(p1,1) == r1.path(p1,0)</span>
<span class="sd">                False</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_start</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Tests inequality</span>

<span class="sd">            TESTS::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p1 = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">                sage: r1 = p1.rauzy_diagram()</span>
<span class="sd">                sage: p2 = p1.reduced()</span>
<span class="sd">                sage: r2 = p2.rauzy_diagram()</span>
<span class="sd">                sage: r1.path(p1,0,1) != r2.path(p2,0,1)</span>
<span class="sd">                True</span>
<span class="sd">                sage: r1.path(p1,0) != r1.path(p1,0)</span>
<span class="sd">                False</span>
<span class="sd">                sage: r1.path(p1,1) != r1.path(p1,0)</span>
<span class="sd">                True</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

        <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a copy of the path.</span>

<span class="sd">            TESTS::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g1 = r.path(p,0,1,0,0)</span>
<span class="sd">                sage: g2 = copy(g1)</span>
<span class="sd">                sage: g1 is g2</span>
<span class="sd">                False</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_edge_types</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="RauzyDiagram.Path.pop">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.pop">[docs]</a>
        <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pops the queue of the path</span>

<span class="sd">            OUTPUT:</span>

<span class="sd">            a path corresponding to the last edge</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g = r.path(p,0,1,0)</span>
<span class="sd">                sage: g0,g1,g2,g3 = g[0], g[1], g[2], g[3]</span>
<span class="sd">                sage: g.pop() == r.path(g2,0)</span>
<span class="sd">                True</span>
<span class="sd">                sage: g == r.path(g0,0,1)</span>
<span class="sd">                True</span>
<span class="sd">                sage: g.pop() == r.path(g1,1)</span>
<span class="sd">                True</span>
<span class="sd">                sage: g == r.path(g0,0)</span>
<span class="sd">                True</span>
<span class="sd">                sage: g.pop() == r.path(g0,0)</span>
<span class="sd">                True</span>
<span class="sd">                sage: g == r.path(g0)</span>
<span class="sd">                True</span>
<span class="sd">                sage: g.pop() == r.path(g0)</span>
<span class="sd">                True</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_pred</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">][</span><span class="n">e</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span><span class="n">e</span><span class="p">)</span></div>


<div class="viewcode-block" id="RauzyDiagram.Path.append">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.append">[docs]</a>
        <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Append an edge to the path.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g = r.path(p)</span>
<span class="sd">                sage: g.append(&#39;top&#39;)</span>
<span class="sd">                sage: g</span>
<span class="sd">                Path of length 1 in a Rauzy diagram</span>
<span class="sd">                sage: g.append(&#39;bottom&#39;)</span>
<span class="sd">                sage: g</span>
<span class="sd">                Path of length 2 in a Rauzy diagram</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_type</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">Integer</span><span class="p">)):</span>
                <span class="n">edge_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">edge_types_index</span><span class="p">(</span><span class="n">edge_type</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">edge_type</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">edge_type</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid edge type&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">][</span><span class="n">edge_type</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> is not a valid edge&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">edge_type</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_type</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">][</span><span class="n">edge_type</span><span class="p">]</span></div>


        <span class="k">def</span> <span class="nf">_fast_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Append an edge to the path without verification.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>

<span class="sd">            .. try to add 1 with append::</span>

<span class="sd">                sage: g = r.path(p)</span>
<span class="sd">                sage: r[p][1] is None</span>
<span class="sd">                True</span>
<span class="sd">                sage: g.append(1)</span>
<span class="sd">                Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">                ValueError: 1 is not a valid edge</span>

<span class="sd">            .. the same with fast append::</span>

<span class="sd">                sage: g = r.path(p)</span>
<span class="sd">                sage: r[p][1] is None</span>
<span class="sd">                True</span>
<span class="sd">                sage: g._fast_append(1)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_type</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_end</span><span class="p">][</span><span class="n">edge_type</span><span class="p">]</span>

<div class="viewcode-block" id="RauzyDiagram.Path.extend">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.extend">[docs]</a>
        <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Extends self with another path.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g1 = r.path(p,&#39;t&#39;,&#39;t&#39;)</span>
<span class="sd">                sage: g2 = r.path(p.rauzy_move(&#39;t&#39;).rauzy_move(&#39;t&#39;),&#39;b&#39;,&#39;b&#39;)</span>
<span class="sd">                sage: g = r.path(p,&#39;t&#39;,&#39;t&#39;,&#39;b&#39;,&#39;b&#39;)</span>
<span class="sd">                sage: g == g1 + g2</span>
<span class="sd">                True</span>
<span class="sd">                sage: g = copy(g1)</span>
<span class="sd">                sage: g.extend(g2)</span>
<span class="sd">                sage: g == g1 + g2</span>
<span class="sd">                True</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">!=</span> <span class="n">path</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not on the same Rauzy diagram&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">!=</span> <span class="n">path</span><span class="o">.</span><span class="n">_start</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the end of the first path must the start of the second&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">_end</span></div>


        <span class="k">def</span> <span class="nf">_fast_extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Extension with no verification.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: p0, p1 = r[p]</span>
<span class="sd">                sage: g = r.path(p)</span>
<span class="sd">                sage: g._fast_extend(r.path(p0))</span>
<span class="sd">                sage: g</span>
<span class="sd">                Path of length 0 in a Rauzy diagram</span>
<span class="sd">                sage: g._fast_extend(r.path(p1))</span>
<span class="sd">                sage: g</span>
<span class="sd">                Path of length 0 in a Rauzy diagram</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">_end</span>

        <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the length of the path.</span>

<span class="sd">            TESTS::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: len(r.path(p))</span>
<span class="sd">                0</span>
<span class="sd">                sage: len(r.path(p,0))</span>
<span class="sd">                1</span>
<span class="sd">                sage: len(r.path(p,1))</span>
<span class="sd">                1</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            TESTS::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g = r.path(p,&#39;t&#39;,&#39;b&#39;)</span>
<span class="sd">                sage: g[0] == p</span>
<span class="sd">                True</span>
<span class="sd">                sage: g[1] == p.rauzy_move(&#39;t&#39;)</span>
<span class="sd">                True</span>
<span class="sd">                sage: g[2] == p.rauzy_move(&#39;t&#39;).rauzy_move(&#39;b&#39;)</span>
<span class="sd">                True</span>
<span class="sd">                sage: g[-1] == g[2]</span>
<span class="sd">                True</span>
<span class="sd">                sage: g[-2] == g[1]</span>
<span class="sd">                True</span>
<span class="sd">                sage: g[-3] == g[0]</span>
<span class="sd">                True</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;path index out of range&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Concatenation of paths.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: r.path(p) + r.path(p,&#39;b&#39;) == r.path(p,&#39;b&#39;)</span>
<span class="sd">                True</span>
<span class="sd">                sage: r.path(p,&#39;b&#39;) + r.path(p) == r.path(p,&#39;b&#39;)</span>
<span class="sd">                True</span>
<span class="sd">                sage: r.path(p,&#39;t&#39;) + r.path(p,&#39;b&#39;) == r.path(p,&#39;t&#39;,&#39;b&#39;)</span>
<span class="sd">                True</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_start</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the end of the first path is not the start of the second&quot;</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_fast_extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Multiple of a loop.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: l = r.path(p,&#39;b&#39;)</span>
<span class="sd">                sage: l * 2 == r.path(p,&#39;b&#39;,&#39;b&#39;)</span>
<span class="sd">                True</span>
<span class="sd">                sage: l * 3 == r.path(p,&#39;b&#39;,&#39;b&#39;,&#39;b&#39;)</span>
<span class="sd">                True</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_loop</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must be a loop to have multiple&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">Integer</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The multiplier must be an integer&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The multiplier must be non negative&quot;</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="RauzyDiagram.Path.is_loop">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.is_loop">[docs]</a>
        <span class="k">def</span> <span class="nf">is_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Tests whether the path is a loop (start point = end point).</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: r.path(p).is_loop()</span>
<span class="sd">                True</span>
<span class="sd">                sage: r.path(p,0,1,0,0).is_loop()</span>
<span class="sd">                True</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span></div>


<div class="viewcode-block" id="RauzyDiagram.Path.winners">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.winners">[docs]</a>
        <span class="k">def</span> <span class="nf">winners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the winner list associated to the edge of the path.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: r.path(p).winners()</span>
<span class="sd">                []</span>
<span class="sd">                sage: r.path(p,0).winners()</span>
<span class="sd">                [&#39;b&#39;]</span>
<span class="sd">                sage: r.path(p,1).winners()</span>
<span class="sd">                [&#39;a&#39;]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">edge_to_winner</span><span class="p">,</span>
                <span class="nb">list</span><span class="o">.</span><span class="fm">__add__</span><span class="p">)</span></div>


<div class="viewcode-block" id="RauzyDiagram.Path.losers">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.losers">[docs]</a>
        <span class="k">def</span> <span class="nf">losers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a list of the loosers on the path.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g0 = r.path(p,&#39;t&#39;,&#39;b&#39;,&#39;t&#39;)</span>
<span class="sd">                sage: g0.losers()</span>
<span class="sd">                [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;]</span>
<span class="sd">                sage: g1 = r.path(p,&#39;b&#39;,&#39;t&#39;,&#39;b&#39;)</span>
<span class="sd">                sage: g1.losers()</span>
<span class="sd">                [&#39;c&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">edge_to_loser</span><span class="p">,</span>
                <span class="nb">list</span><span class="o">.</span><span class="fm">__add__</span><span class="p">)</span></div>


        <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Iterator over the permutations of the path.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: g = r.path(p)</span>
<span class="sd">                sage: for q in g:</span>
<span class="sd">                ....:     print(p)</span>
<span class="sd">                a b c</span>
<span class="sd">                c b a</span>
<span class="sd">                sage: g = r.path(p, &#39;t&#39;, &#39;t&#39;)</span>
<span class="sd">                sage: for q in g:</span>
<span class="sd">                ....:     print(&quot;%s\n*****&quot; % q)</span>
<span class="sd">                a b c</span>
<span class="sd">                c b a</span>
<span class="sd">                *****</span>
<span class="sd">                a b c</span>
<span class="sd">                c a b</span>
<span class="sd">                *****</span>
<span class="sd">                a b c</span>
<span class="sd">                c b a</span>
<span class="sd">                *****</span>
<span class="sd">                sage: g = r.path(p,&#39;b&#39;,&#39;t&#39;)</span>
<span class="sd">                sage: for q in g:</span>
<span class="sd">                ....:     print(&quot;%s\n*****&quot; % q)</span>
<span class="sd">                a b c</span>
<span class="sd">                c b a</span>
<span class="sd">                *****</span>
<span class="sd">                a c b</span>
<span class="sd">                c b a</span>
<span class="sd">                *****</span>
<span class="sd">                a c b</span>
<span class="sd">                c b a</span>
<span class="sd">                *****</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>

            <span class="k">for</span> <span class="n">edge_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">edge_type</span><span class="p">]</span>

            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

<div class="viewcode-block" id="RauzyDiagram.Path.composition">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.composition">[docs]</a>
        <span class="k">def</span> <span class="nf">composition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">composition</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compose an edges function on a path</span>

<span class="sd">            INPUT:</span>

<span class="sd">            - ``path`` - either a Path or a tuple describing a path</span>

<span class="sd">            - ``function`` - function must be of the form</span>

<span class="sd">            - ``composition`` - the composition function</span>

<span class="sd">            AUTHOR:</span>

<span class="sd">            - Vincent Delecroix (2009-09-29)</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: def f(i,t):</span>
<span class="sd">                ....:     if t is None: return []</span>
<span class="sd">                ....:     return [t]</span>
<span class="sd">                sage: g = r.path(p)</span>
<span class="sd">                sage: g.composition(f,list.__add__)</span>
<span class="sd">                []</span>
<span class="sd">                sage: g = r.path(p,0,1)</span>
<span class="sd">                sage: g.composition(f, list.__add__)</span>
<span class="sd">                [0, 1]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">cur_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_element</span>

            <span class="k">if</span> <span class="n">composition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">composition</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__mul__</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_set_element</span><span class="p">(</span><span class="n">cur_vertex</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">composition</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">function</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
                <span class="n">cur_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">cur_vertex</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="RauzyDiagram.Path.right_composition">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.Path.right_composition">[docs]</a>
        <span class="k">def</span> <span class="nf">right_composition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">composition</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compose an edges function on a path</span>

<span class="sd">            INPUT:</span>

<span class="sd">            - ``function`` - function must be of the form (indice,type) -&gt;</span>
<span class="sd">              element. Moreover function(None,None) must be an identity element</span>
<span class="sd">              for initialization.</span>

<span class="sd">            - ``composition`` - the composition function for the function. * if None (default: None)</span>

<span class="sd">            TESTS::</span>

<span class="sd">                sage: from surface_dynamics import *</span>

<span class="sd">                sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">                sage: r = p.rauzy_diagram()</span>
<span class="sd">                sage: def f(i,t):</span>
<span class="sd">                ....:     if t is None: return []</span>
<span class="sd">                ....:     return [t]</span>
<span class="sd">                sage: g = r.path(p)</span>
<span class="sd">                sage: g.right_composition(f,list.__add__)</span>
<span class="sd">                []</span>
<span class="sd">                sage: g = r.path(p,0,1)</span>
<span class="sd">                sage: g.right_composition(f, list.__add__)</span>
<span class="sd">                [1, 0]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_element</span>
            <span class="n">cur_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>

            <span class="k">if</span> <span class="n">composition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">composition</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__mul__</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_set_element</span><span class="p">(</span><span class="n">cur_vertex</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">composition</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="n">result</span><span class="p">)</span>
                <span class="n">cur_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">cur_vertex</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">result</span></div>
</div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
        <span class="n">right_induction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">left_induction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">left_right_inversion</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">top_bottom_inversion</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        self._succ contains successors</span>
<span class="sd">        self._pred contains predecessors</span>

<span class="sd">        self._element_class is the class of elements of self</span>
<span class="sd">        self._element is an instance of this class (hence contains the alphabet,</span>
<span class="sd">        the representation mode, ...). It is used to store data about property</span>
<span class="sd">        of permutations and also as a fast iterator.</span>

<span class="sd">         INPUT:</span>

<span class="sd">         - ``right_induction`` - boolean or &#39;top&#39; or &#39;bottom&#39;: consider the</span>
<span class="sd">           right induction</span>

<span class="sd">         - ``left_induction`` - boolean or &#39;top&#39; or &#39;bottom&#39;: consider the</span>
<span class="sd">           left induction</span>

<span class="sd">         - ``left_right_inversion`` - consider the left right inversion</span>

<span class="sd">         - ``top_bottom_inversion`` - consider the top bottom inversion</span>

<span class="sd">         - ``symmetric`` - consider the symmetric</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r1 = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: r2 = loads(dumps(r1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">right_induction</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;rt_rauzy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;rauzy_move&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;rb_rauzy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;rauzy_move&#39;</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_induction</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">right_induction</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;right_induction can not be empty string&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="s1">&#39;top&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">right_induction</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;rt_rauzy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;rauzy_move&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

            <span class="k">elif</span> <span class="s1">&#39;bottom&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">right_induction</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;rb_rauzy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;rauzy_move&#39;</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not valid for right_induction&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">right_induction</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">left_induction</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lt_rauzy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;rauzy_move&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lb_rauzy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;rauzy_move&#39;</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_induction</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left_induction</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left_induction can not be empty string&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="s1">&#39;top&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">left_induction</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lt_rauzy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;rauzy_move&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>

            <span class="k">elif</span> <span class="s1">&#39;bottom&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">left_induction</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lb_rauzy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;rauzy_move&#39;</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not valid for left_induction&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">right_induction</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">left_right_inversion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lr_inverse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;left_right_inverse&#39;</span><span class="p">,()))</span>

        <span class="k">if</span> <span class="n">top_bottom_inversion</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;tb_inverse&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;top_bottom_inverse&#39;</span><span class="p">,()))</span>

        <span class="k">if</span> <span class="n">symmetric</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;symmetric&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,()))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_element_class</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_element</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alphabet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">_alphabet</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pred</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">complete</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests equality.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;) == iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: r1 = iet.RauzyDiagram(&#39;a c b&#39;,&#39;c b a&#39;, alphabet=&#39;abc&#39;)</span>
<span class="sd">            sage: r2 = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c a b&#39;, alphabet=&#39;abc&#39;)</span>
<span class="sd">            sage: r == r1</span>
<span class="sd">            True</span>
<span class="sd">            sage: r == r2</span>
<span class="sd">            True</span>
<span class="sd">            sage: r1 == r2</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c d&#39;,&#39;d c b a&#39;)</span>
<span class="sd">            sage: for p in r:</span>
<span class="sd">            ....:     p.rauzy_diagram() == r</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_edge_types</span> <span class="ow">and</span> \
               <span class="nb">next</span><span class="p">(</span><span class="n">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">))</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_succ</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests difference.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;) != iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: r1 = iet.RauzyDiagram(&#39;a c b&#39;,&#39;c b a&#39;, alphabet=&#39;abc&#39;)</span>
<span class="sd">            sage: r2 = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c a b&#39;, alphabet=&#39;abc&#39;)</span>
<span class="sd">            sage: r != r1</span>
<span class="sd">            False</span>
<span class="sd">            sage: r != r2</span>
<span class="sd">            False</span>
<span class="sd">            sage: r1 != r2</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<div class="viewcode-block" id="RauzyDiagram.vertices">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.vertices">[docs]</a>
    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the vertices.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: for p in r.vertices(): print(p)</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span></div>


<div class="viewcode-block" id="RauzyDiagram.vertex_iterator">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.vertex_iterator">[docs]</a>
    <span class="k">def</span> <span class="nf">vertex_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the vertices</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: for p in r.vertex_iterator(): print(p)</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>

<span class="sd">        ::</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c d&#39;,&#39;d c b a&#39;)</span>
<span class="sd">            sage: r_1n = filter(lambda x: x.is_standard(), r)</span>
<span class="sd">            sage: for p in r_1n: print(p)</span>
<span class="sd">            a b c d</span>
<span class="sd">            d c b a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="RauzyDiagram.edges">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.edges">[docs]</a>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the edges.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: len(r.edges())</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_iterator</span><span class="p">())</span></div>


<div class="viewcode-block" id="RauzyDiagram.edge_iterator">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.edge_iterator">[docs]</a>
    <span class="k">def</span> <span class="nf">edge_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the edges of the graph.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: r = p.rauzy_diagram()</span>
<span class="sd">            sage: for e in r.edge_iterator():</span>
<span class="sd">            ....:     print(&#39;%s --&gt; %s&#39; %(e[0].str(sep=&#39;/&#39;), e[1].str(sep=&#39;/&#39;)))</span>
<span class="sd">            a b/b a --&gt; a b/b a</span>
<span class="sd">            a b/b a --&gt; a b/b a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">x</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">yield</span><span class="p">(</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">y</span><span class="p">),</span>
                         <span class="n">i</span><span class="p">))</span></div>


<div class="viewcode-block" id="RauzyDiagram.edge_types_index">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.edge_types_index">[docs]</a>
    <span class="k">def</span> <span class="nf">edge_types_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Try to convert the data as an edge type.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``data`` - a string</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        integer</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">        For a standard Rauzy diagram (only right induction) the 0 index</span>
<span class="sd">        corresponds to the &#39;top&#39; induction and the index 1 corresponds to the</span>
<span class="sd">        &#39;bottom&#39; one::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: r = p.rauzy_diagram()</span>
<span class="sd">            sage: r.edge_types_index(&#39;top&#39;)</span>
<span class="sd">            0</span>
<span class="sd">            sage: r[p][0] == p.rauzy_move(&#39;top&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: r.edge_types_index(&#39;bottom&#39;)</span>
<span class="sd">            1</span>
<span class="sd">            sage: r[p][1] == p.rauzy_move(&#39;bottom&#39;)</span>
<span class="sd">            True</span>

<span class="sd">        The special operations (inversion and symmetry) always appears after the</span>
<span class="sd">        different Rauzy inductions::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: r = p.rauzy_diagram(symmetric=True)</span>
<span class="sd">            sage: r.edge_types_index(&#39;symmetric&#39;)</span>
<span class="sd">            2</span>
<span class="sd">            sage: r[p][2] == p.symmetric()</span>
<span class="sd">            True</span>

<span class="sd">        This function always try to resolve conflictuous name. If it&#39;s</span>
<span class="sd">        impossible a ValueError is raised::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: r = p.rauzy_diagram(left_induction=True)</span>
<span class="sd">            sage: r.edge_types_index(&#39;top&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: left and right inductions must be differentiated</span>
<span class="sd">            sage: r.edge_types_index(&#39;top_right&#39;)</span>
<span class="sd">            0</span>
<span class="sd">            sage: r[p][0] == p.rauzy_move(0)</span>
<span class="sd">            True</span>
<span class="sd">            sage: r.edge_types_index(&#39;bottom_left&#39;)</span>
<span class="sd">            3</span>
<span class="sd">            sage: r[p][3] == p.rauzy_move(&#39;bottom&#39;, &#39;left&#39;)</span>
<span class="sd">            True</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: r = p.rauzy_diagram(left_right_inversion=True,top_bottom_inversion=True)</span>
<span class="sd">            sage: r.edge_types_index(&#39;inversion&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: left-right and top-bottom inversions must be differentiated</span>
<span class="sd">            sage: r.edge_types_index(&#39;lr_inverse&#39;)</span>
<span class="sd">            2</span>
<span class="sd">            sage: p.lr_inverse() == r[p][2]</span>
<span class="sd">            True</span>
<span class="sd">            sage: r.edge_types_index(&#39;tb_inverse&#39;)</span>
<span class="sd">            3</span>
<span class="sd">            sage: p.tb_inverse() == r[p][3]</span>
<span class="sd">            True</span>

<span class="sd">        Short names are accepted::</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: r = p.rauzy_diagram(right_induction=&#39;top&#39;,top_bottom_inversion=True)</span>
<span class="sd">            sage: r.edge_types_index(&#39;top_rauzy_move&#39;)</span>
<span class="sd">            0</span>
<span class="sd">            sage: r.edge_types_index(&#39;t&#39;)</span>
<span class="sd">            0</span>
<span class="sd">            sage: r.edge_types_index(&#39;tb&#39;)</span>
<span class="sd">            1</span>
<span class="sd">            sage: r.edge_types_index(&#39;inversion&#39;)</span>
<span class="sd">            1</span>
<span class="sd">            sage: r.edge_types_index(&#39;inverse&#39;)</span>
<span class="sd">            1</span>
<span class="sd">            sage: r.edge_types_index(&#39;i&#39;)</span>
<span class="sd">            1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the edge type must be a string&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;top_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;t_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s1">&#39;lt_rauzy&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;rt_rauzy&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left and right inductions must be differentiated&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lt_rauzy&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="s1">&#39;rt_rauzy&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;rt_rauzy&#39;</span><span class="p">]</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no top induction in this Rauzy diagram&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;bottom_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;b_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s1">&#39;lb_rauzy&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;rb_rauzy&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left and right inductions must be differentiated&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lb_rauzy&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="s1">&#39;rb_rauzy&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;rb_rauzy&#39;</span><span class="p">]</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no bottom Rauzy induction in this diagram&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;left_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;l_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s1">&#39;lt_rauzy&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;lb_rauzy&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;top and bottom inductions must be differentiated&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lt_rauzy&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="s1">&#39;lb_rauzy&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">(</span><span class="s1">&#39;lb_rauzy&#39;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no left Rauzy induction in this diagram&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;lt_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;tl_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;left_top_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;top_left_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s1">&#39;lt_rauzy&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no top-left Rauzy induction in this diagram&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lt_rauzy&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;lb_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;bl_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;left_bottom_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;bottom_left_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s1">&#39;lb_rauzy&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no bottom-left Rauzy induction in this diagram&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lb_rauzy&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;right&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ambiguity with your edge name: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;rt_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;tr_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;right_top_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;top_right_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s1">&#39;rt_rauzy&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no top-right Rauzy induction in this diagram&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;rt_rauzy&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;rb_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;br_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;right_bottom_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="s1">&#39;bottom_right_rauzy_move&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s1">&#39;rb_rauzy&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no bottom-right Rauzy induction in this diagram&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;rb_rauzy&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;symmetric&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;symmetric&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no symmetric in this diagram&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;symmetric&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;inversion&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span> <span class="n">data</span> <span class="o">==</span> <span class="s1">&#39;inverse&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;lr_inverse&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;tb_inverse&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;left-right and top-bottom inversions must be differentiated&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lr_inverse&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="s1">&#39;tb_inverse&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;tb_inverse&#39;</span><span class="p">]</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no inversion in this diagram&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;lr_inversion&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="n">data</span> <span class="o">==</span> <span class="s1">&#39;lr_inverse&#39;</span> <span class="ow">or</span>
            <span class="s1">&#39;left_right_inversion&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="n">data</span> <span class="o">==</span> <span class="s1">&#39;left_right_inverse&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;lr_inverse&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no left-right inversion in this diagram&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;lr_inverse&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;tb_inversion&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
            <span class="n">data</span> <span class="o">==</span> <span class="s1">&#39;tb_inverse&#39;</span> <span class="ow">or</span>
            <span class="s1">&#39;top_bottom_inversion&#39;</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">data</span> <span class="o">==</span> <span class="s1">&#39;top_bottom_inverse&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;tb_inverse&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no top-bottom inversion in this diagram&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="s1">&#39;tb_inverse&#39;</span><span class="p">]</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;this edge type does not exist: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">data</span><span class="p">))</span></div>


<div class="viewcode-block" id="RauzyDiagram.edge_types">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.edge_types">[docs]</a>
    <span class="k">def</span> <span class="nf">edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print information about edges.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;, &#39;b a&#39;)</span>
<span class="sd">            sage: r.edge_types()</span>
<span class="sd">            0: rauzy_move(0, -1)</span>
<span class="sd">            1: rauzy_move(1, -1)</span>

<span class="sd">        ::</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;, &#39;b a&#39;, left_induction=True)</span>
<span class="sd">            sage: r.edge_types()</span>
<span class="sd">            0: rauzy_move(0, -1)</span>
<span class="sd">            1: rauzy_move(1, -1)</span>
<span class="sd">            2: rauzy_move(0, 0)</span>
<span class="sd">            3: rauzy_move(1, 0)</span>

<span class="sd">        ::</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39; b a&#39;,symmetric=True)</span>
<span class="sd">            sage: r.edge_types()</span>
<span class="sd">            0: rauzy_move(0, -1)</span>
<span class="sd">            1: rauzy_move(1, -1)</span>
<span class="sd">            2: symmetric()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">edge_type</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="n">edge_type</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">))</span></div>


<div class="viewcode-block" id="RauzyDiagram.alphabet">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.alphabet">[docs]</a>
    <span class="k">def</span> <span class="nf">alphabet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: r.alphabet() == Alphabet([&#39;a&#39;,&#39;b&#39;])</span>
<span class="sd">            True</span>
<span class="sd">            sage: r = iet.RauzyDiagram([0,1],[1,0])</span>
<span class="sd">            sage: r.alphabet() == Alphabet([0,1])</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">_alphabet</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">_set_alphabet</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="RauzyDiagram.letters">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.letters">[docs]</a>
    <span class="k">def</span> <span class="nf">letters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the letters used by the RauzyDiagram.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: r.alphabet()</span>
<span class="sd">            {&#39;a&#39;, &#39;b&#39;}</span>
<span class="sd">            sage: r.letters()</span>
<span class="sd">            [&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">            sage: r.alphabet(&#39;ABCDEF&#39;)</span>
<span class="sd">            sage: r.alphabet()</span>
<span class="sd">            {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;}</span>
<span class="sd">            sage: r.letters()</span>
<span class="sd">            [&#39;A&#39;, &#39;B&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">letters</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_vertex_to_permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the (vertex) data to a permutation.</span>

<span class="sd">        TESTS:</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)   #indirect doctest</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_element</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="p">)</span>

<div class="viewcode-block" id="RauzyDiagram.edge_to_matrix">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.edge_to_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">edge_to_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the corresponding matrix</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``p`` - a permutation</span>

<span class="sd">        - ``edge_type`` - 0 or 1 corresponding to the type of the edge</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A matrix</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: d = p.rauzy_diagram()</span>
<span class="sd">            sage: print(d.edge_to_matrix(p,1))</span>
<span class="sd">            [1 0 1]</span>
<span class="sd">            [0 1 0]</span>
<span class="sd">            [0 0 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">identity_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span>

        <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">[</span><span class="n">edge_type</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_matrix&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element_class</span><span class="p">,</span><span class="n">function_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">identity_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span>

        <span class="n">arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">[</span><span class="n">edge_type</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">function_name</span><span class="p">)(</span><span class="o">*</span><span class="n">arguments</span><span class="p">)</span></div>


<div class="viewcode-block" id="RauzyDiagram.edge_to_winner">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.edge_to_winner">[docs]</a>
    <span class="k">def</span> <span class="nf">edge_to_winner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the corresponding winner</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: r.edge_to_winner(None,None)</span>
<span class="sd">            []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">[</span><span class="n">edge_type</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_winner&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element_class</span><span class="p">,</span> <span class="n">function_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">[</span><span class="n">edge_type</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">function_name</span><span class="p">)(</span><span class="o">*</span><span class="n">arguments</span><span class="p">)]</span></div>


<div class="viewcode-block" id="RauzyDiagram.edge_to_loser">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.edge_to_loser">[docs]</a>
    <span class="k">def</span> <span class="nf">edge_to_loser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the corresponding loser</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: r.edge_to_loser(None,None)</span>
<span class="sd">            []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">[</span><span class="n">edge_type</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_loser&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element_class</span><span class="p">,</span> <span class="n">function_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">[</span><span class="n">edge_type</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">function_name</span><span class="p">)(</span><span class="o">*</span><span class="n">arguments</span><span class="p">)]</span></div>


    <span class="k">def</span> <span class="nf">_all_npath_extension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all extension of fixed length of p.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``p`` - a path</span>

<span class="sd">        - ``length`` - a non-negative integer</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: r = p.rauzy_diagram()</span>
<span class="sd">            sage: g0 = r.path(p)</span>
<span class="sd">            sage: for g in r._all_npath_extension(g0,0):</span>
<span class="sd">            ....:     print(g)</span>
<span class="sd">            Path of length 0 in a Rauzy diagram</span>
<span class="sd">            sage: for g in r._all_npath_extension(g0,1):</span>
<span class="sd">            ....:     print(g)</span>
<span class="sd">            Path of length 1 in a Rauzy diagram</span>
<span class="sd">            Path of length 1 in a Rauzy diagram</span>
<span class="sd">            sage: for g in r._all_npath_extension(g0,2):</span>
<span class="sd">            ....:     print(g)</span>
<span class="sd">            Path of length 2 in a Rauzy diagram</span>
<span class="sd">            Path of length 2 in a Rauzy diagram</span>
<span class="sd">            Path of length 2 in a Rauzy diagram</span>
<span class="sd">            Path of length 2 in a Rauzy diagram</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;,reduced=True)</span>
<span class="sd">            sage: r = p.rauzy_diagram()</span>
<span class="sd">            sage: g0 = r.path(p)</span>
<span class="sd">            sage: len(list(r._all_npath_extension(g0,0)))</span>
<span class="sd">            1</span>
<span class="sd">            sage: len(list(r._all_npath_extension(g0,1)))</span>
<span class="sd">            1</span>
<span class="sd">            sage: len(list(r._all_npath_extension(g0,2)))</span>
<span class="sd">            2</span>
<span class="sd">            sage: len(list(r._all_npath_extension(g0,3)))</span>
<span class="sd">            3</span>
<span class="sd">            sage: len(list(r._all_npath_extension(g0,4)))</span>
<span class="sd">            5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">g</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">_end</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">_fast_append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_npath_extension</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="k">yield</span> <span class="n">h</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_all_path_extension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all path extension of p.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: r = p.rauzy_diagram()</span>
<span class="sd">            sage: g0 = r.path(p)</span>
<span class="sd">            sage: for g in r._all_path_extension(g0,0):</span>
<span class="sd">            ....:     print(g)</span>
<span class="sd">            Path of length 0 in a Rauzy diagram</span>
<span class="sd">            sage: for g in r._all_path_extension(g0, 1):</span>
<span class="sd">            ....:     print(g)</span>
<span class="sd">            Path of length 0 in a Rauzy diagram</span>
<span class="sd">            Path of length 1 in a Rauzy diagram</span>
<span class="sd">            Path of length 1 in a Rauzy diagram</span>

<span class="sd">        ::</span>

<span class="sd">            sage: p = iet.GeneralizedPermutation(&#39;a a&#39;,&#39;b b c c&#39;)</span>
<span class="sd">            sage: r = p.rauzy_diagram()</span>
<span class="sd">            sage: g0 = r.path(p)</span>
<span class="sd">            sage: len(list(r._all_path_extension(g0,0)))</span>
<span class="sd">            1</span>
<span class="sd">            sage: len(list(r._all_path_extension(g0,1)))</span>
<span class="sd">            2</span>
<span class="sd">            sage: len(list(r._all_path_extension(g0,2)))</span>
<span class="sd">            4</span>
<span class="sd">            sage: len(list(r._all_path_extension(g0,3)))</span>
<span class="sd">            7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="n">g</span>

        <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">_end</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">_fast_append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_path_extension</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="k">yield</span> <span class="n">h</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over the permutations of the Rauzy diagram.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: for p in r: print(p)</span>
<span class="sd">            a b</span>
<span class="sd">            b a</span>
<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: for p in r: print(p.stratum())</span>
<span class="sd">            H_1(0^2)</span>
<span class="sd">            H_1(0^2)</span>
<span class="sd">            H_1(0^2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Containance test.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c d&#39;,&#39;d c b a&#39;,reduced=True)</span>
<span class="sd">            sage: q = iet.Permutation(&#39;a b c d&#39;,&#39;d b c a&#39;,reduced=True)</span>
<span class="sd">            sage: r = p.rauzy_diagram()</span>
<span class="sd">            sage: s = q.rauzy_diagram()</span>
<span class="sd">            sage: p in r</span>
<span class="sd">            True</span>
<span class="sd">            sage: p in s</span>
<span class="sd">            False</span>
<span class="sd">            sage: q in r</span>
<span class="sd">            False</span>
<span class="sd">            sage: q in s</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">element</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a representation of self</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)   #indirect doctest</span>
<span class="sd">            Rauzy diagram with 1 permutation</span>
<span class="sd">            sage: iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;)   #indirect doctest</span>
<span class="sd">            Rauzy diagram with 3 permutations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Empty Rauzy diagram&quot;</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Rauzy diagram with 1 permutation&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Rauzy diagram with </span><span class="si">%d</span><span class="s2"> permutations&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the neighbors of p.</span>

<span class="sd">        Just use the function vertex_to_permutation that must be defined</span>
<span class="sd">        in each child.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``p`` - a permutation in the Rauzy diagram</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>


<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: p0 = iet.Permutation(&#39;a b c&#39;,&#39;c a b&#39;,alphabet=&quot;abc&quot;)</span>
<span class="sd">            sage: p1 = iet.Permutation(&#39;a c b&#39;,&#39;c b a&#39;,alphabet=&quot;abc&quot;)</span>
<span class="sd">            sage: r = p.rauzy_diagram()</span>
<span class="sd">            sage: r[p] == [p0, p1]</span>
<span class="sd">            True</span>
<span class="sd">            sage: r[p1] == [p1, p]</span>
<span class="sd">            True</span>
<span class="sd">            sage: r[p0] == [p, p0]</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element_class</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your element does not have the good type&quot;</span><span class="p">)</span>

        <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_permutation_to_vertex</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">perm</span><span class="p">]))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated use cardinality.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: r.cardinality()</span>
<span class="sd">            1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>

<div class="viewcode-block" id="RauzyDiagram.cardinality">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.cardinality">[docs]</a>
    <span class="k">def</span> <span class="nf">cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of permutations in this Rauzy diagram.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        - `integer` - the number of vertices in the diagram</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b&#39;,&#39;b a&#39;)</span>
<span class="sd">            sage: r.cardinality()</span>
<span class="sd">            1</span>
<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: r.cardinality()</span>
<span class="sd">            3</span>
<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c d&#39;,&#39;d c b a&#39;)</span>
<span class="sd">            sage: r.cardinality()</span>
<span class="sd">            7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">)</span></div>


<div class="viewcode-block" id="RauzyDiagram.complete">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.complete">[docs]</a>
    <span class="k">def</span> <span class="nf">complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Completion of the Rauzy diagram.</span>

<span class="sd">        Add to the Rauzy diagram all permutations that are obtained by</span>
<span class="sd">        successive operations defined by edge_types(). The permutation must be</span>
<span class="sd">        of the same type and the same length as the one used for the creation.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``p`` - a permutation of Interval exchange transformation</span>

<span class="sd">        Rauzy diagram is the reunion of all permutations that could be</span>
<span class="sd">        obtained with successive rauzy moves. This function just use the</span>
<span class="sd">        functions __getitem__ and has_rauzy_move and rauzy_move which must</span>
<span class="sd">        be defined for child and their corresponding permutation types.</span>

<span class="sd">        TESTS::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;)   #indirect doctest</span>
<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;,left_induction=True) #indirect doctest</span>
<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;,symmetric=True)   #indirect doctest</span>
<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;,lr_inversion=True)   #indirect doctest</span>
<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;,tb_inversion=True)   #indirect doctest</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element_class</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;wrong permutation type&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong length&quot;</span><span class="p">)</span>

        <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pred</span>
        <span class="n">succ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_permutation_to_vertex</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">succ</span><span class="p">:</span>
            <span class="n">succ</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="n">pred</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">l</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_element</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="s1">&#39;has_&#39;</span><span class="o">+</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span>
                  <span class="nb">getattr</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="s1">&#39;has_&#39;</span><span class="o">+</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])(</span><span class="o">*</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))):</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])(</span><span class="o">*</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_permutation_to_vertex</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">q</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">succ</span><span class="p">:</span>
                        <span class="n">succ</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
                        <span class="n">pred</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
                        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                    <span class="n">succ</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>
                    <span class="n">pred</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span></div>


<div class="viewcode-block" id="RauzyDiagram.path">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.path">[docs]</a>
    <span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a path over this Rauzy diagram.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``initial_vertex`` - the initial vertex (starting point of the path)</span>

<span class="sd">        - ``data`` - a sequence of edges</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: r = p.rauzy_diagram()</span>
<span class="sd">            sage: g = r.path(p, &#39;top&#39;, &#39;bottom&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must be non empty&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Path</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="RauzyDiagram.graph">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.RauzyDiagram.graph">[docs]</a>
    <span class="k">def</span> <span class="nf">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Rauzy diagram as a Graph object</span>

<span class="sd">        The graph returned is more precisely a DiGraph (directed graph) with</span>
<span class="sd">        loops and multiedges allowed.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: r = iet.RauzyDiagram(&#39;a b c&#39;,&#39;c b a&#39;)</span>
<span class="sd">            sage: r</span>
<span class="sd">            Rauzy diagram with 3 permutations</span>
<span class="sd">            sage: r.graph()</span>
<span class="sd">            Looped digraph on 3 vertices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sage.graphs.digraph</span> <span class="kn">import</span> <span class="n">DiGraph</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">p</span><span class="p">,</span><span class="n">neighbours</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbours</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>
</div>


<div class="viewcode-block" id="FlippedRauzyDiagram">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.FlippedRauzyDiagram">[docs]</a>
<span class="k">class</span> <span class="nc">FlippedRauzyDiagram</span><span class="p">(</span><span class="n">RauzyDiagram</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Template for flipped Rauzy diagrams.</span>

<span class="sd">    .. warning:</span>

<span class="sd">        Internal class! Do not use directly!</span>

<span class="sd">    AUTHORS:</span>

<span class="sd">    - Vincent Delecroix (2009-09-29): initial version</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FlippedRauzyDiagram.complete">
<a class="viewcode-back" href="../../../interval_exchanges/template.html#surface_dynamics.interval_exchanges.template.FlippedRauzyDiagram.complete">[docs]</a>
    <span class="k">def</span> <span class="nf">complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">reducible</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Completion of the Rauzy diagram</span>

<span class="sd">        Add all successors of p for defined operations in edge_types. Could be</span>
<span class="sd">        used for generating non (strongly) connected Rauzy diagrams. Sometimes,</span>
<span class="sd">        for flipped permutations, the maximal connected graph in all</span>
<span class="sd">        permutations is not strongly connected. Finding such components needs to</span>
<span class="sd">        call most than once the .complete() method.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``p`` - a permutation</span>

<span class="sd">        - ``reducible`` - put or not reducible permutations</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: from surface_dynamics import *</span>

<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;,flips=&#39;a&#39;)</span>
<span class="sd">            sage: d = p.rauzy_diagram()</span>
<span class="sd">            sage: d</span>
<span class="sd">            Rauzy diagram with 3 permutations</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;,flips=&#39;b&#39;)</span>
<span class="sd">            sage: d.complete(p)</span>
<span class="sd">            sage: d</span>
<span class="sd">            Rauzy diagram with 8 permutations</span>
<span class="sd">            sage: p = iet.Permutation(&#39;a b c&#39;,&#39;c b a&#39;,flips=&#39;a&#39;)</span>
<span class="sd">            sage: d.complete(p)</span>
<span class="sd">            sage: d</span>
<span class="sd">            Rauzy diagram with 8 permutations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element_class</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;your permutation is not of good type&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;your permutation has not the good length&quot;</span><span class="p">)</span>

        <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pred</span>
        <span class="n">succ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_permutation_to_vertex</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">succ</span><span class="p">:</span>
            <span class="n">succ</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="n">pred</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">l</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">edge_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">):</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_to_permutation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span><span class="s1">&#39;has_&#39;</span> <span class="o">+</span> <span class="n">edge_type</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span>
                  <span class="nb">getattr</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="s1">&#39;has_&#39;</span> <span class="o">+</span> <span class="n">edge_type</span><span class="p">[</span><span class="mi">0</span><span class="p">])(</span><span class="o">*</span><span class="p">(</span><span class="n">edge_type</span><span class="p">[</span><span class="mi">1</span><span class="p">]))):</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="n">perm</span><span class="o">.</span><span class="n">rauzy_move</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_permutation_to_vertex</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">reducible</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">perm</span><span class="o">.</span><span class="n">is_irreducible</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">q</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">succ</span><span class="p">:</span>
                            <span class="n">succ</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
                            <span class="n">pred</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_types</span><span class="p">)</span>
                            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

                        <span class="n">succ</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>
                        <span class="n">pred</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span></div>
</div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2021-2023, the surface-dynamics authors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=1dd76d02"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=4e2eecee"></script>
    </body>
</html>